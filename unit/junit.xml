<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="jest tests" tests="7667" failures="0" errors="0" time="166.164">
  <testsuite name="packages/dom-event-testing-library/__tests__/index-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:10:55" time="5.284" tests="22">
    <testcase classname="describeWithPointerEvent: PointerEvent provides boolean to tests" name="describeWithPointerEvent: PointerEvent provides boolean to tests" time="0.015">
    </testcase>
    <testcase classname="describeWithPointerEvent: PointerEvent testWithPointerType: mouse" name="describeWithPointerEvent: PointerEvent testWithPointerType: mouse" time="0.001">
    </testcase>
    <testcase classname="describeWithPointerEvent: PointerEvent testWithPointerType: touch" name="describeWithPointerEvent: PointerEvent testWithPointerType: touch" time="0">
    </testcase>
    <testcase classname="describeWithPointerEvent: PointerEvent testWithPointerType: pen" name="describeWithPointerEvent: PointerEvent testWithPointerType: pen" time="0">
    </testcase>
    <testcase classname="describeWithPointerEvent: MouseEvent/TouchEvent provides boolean to tests" name="describeWithPointerEvent: MouseEvent/TouchEvent provides boolean to tests" time="0">
    </testcase>
    <testcase classname="describeWithPointerEvent: MouseEvent/TouchEvent testWithPointerType: mouse" name="describeWithPointerEvent: MouseEvent/TouchEvent testWithPointerType: mouse" time="0">
    </testcase>
    <testcase classname="describeWithPointerEvent: MouseEvent/TouchEvent testWithPointerType: touch" name="describeWithPointerEvent: MouseEvent/TouchEvent testWithPointerType: touch" time="0.001">
    </testcase>
    <testcase classname="createEventTarget returns expected API" name="createEventTarget returns expected API" time="0.003">
    </testcase>
    <testcase classname="createEventTarget .blur() default" name="createEventTarget .blur() default" time="0.001">
    </testcase>
    <testcase classname="createEventTarget .blur() custom payload" name="createEventTarget .blur() custom payload" time="0.015">
    </testcase>
    <testcase classname="createEventTarget .click() default" name="createEventTarget .click() default" time="0.008">
    </testcase>
    <testcase classname="createEventTarget .click() custom payload" name="createEventTarget .click() custom payload" time="0.003">
    </testcase>
    <testcase classname="createEventTarget .focus() default" name="createEventTarget .focus() default" time="0">
    </testcase>
    <testcase classname="createEventTarget .focus() custom payload" name="createEventTarget .focus() custom payload" time="0.001">
    </testcase>
    <testcase classname="createEventTarget .keydown() default" name="createEventTarget .keydown() default" time="0.001">
    </testcase>
    <testcase classname="createEventTarget .keydown() custom payload" name="createEventTarget .keydown() custom payload" time="0.001">
    </testcase>
    <testcase classname="createEventTarget .keyup() default" name="createEventTarget .keyup() default" time="0.015">
    </testcase>
    <testcase classname="createEventTarget .keyup() custom payload" name="createEventTarget .keyup() custom payload" time="0.001">
    </testcase>
    <testcase classname="createEventTarget .scroll() default" name="createEventTarget .scroll() default" time="0.001">
    </testcase>
    <testcase classname="createEventTarget .virtualclick() default" name="createEventTarget .virtualclick() default" time="0.001">
    </testcase>
    <testcase classname="createEventTarget .virtualclick() custom payload" name="createEventTarget .virtualclick() custom payload" time="0.004">
    </testcase>
    <testcase classname="createEventTarget .setBoundingClientRect()" name="createEventTarget .setBoundingClientRect()" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="packages/scheduler/src/__tests__/Scheduler-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:01" time="0.789" tests="11">
    <testcase classname="SchedulerBrowser task that finishes before deadline" name="SchedulerBrowser task that finishes before deadline" time="0.216">
    </testcase>
    <testcase classname="SchedulerBrowser task with continuation" name="SchedulerBrowser task with continuation" time="0.002">
    </testcase>
    <testcase classname="SchedulerBrowser multiple tasks" name="SchedulerBrowser multiple tasks" time="0.007">
    </testcase>
    <testcase classname="SchedulerBrowser multiple tasks with a yield in between" name="SchedulerBrowser multiple tasks with a yield in between" time="0.002">
    </testcase>
    <testcase classname="SchedulerBrowser cancels tasks" name="SchedulerBrowser cancels tasks" time="0.002">
    </testcase>
    <testcase classname="SchedulerBrowser throws when a task errors then continues in a new event" name="SchedulerBrowser throws when a task errors then continues in a new event" time="0.017">
    </testcase>
    <testcase classname="SchedulerBrowser schedule new task after queue has emptied" name="SchedulerBrowser schedule new task after queue has emptied" time="0.002">
    </testcase>
    <testcase classname="SchedulerBrowser schedule new task after a cancellation" name="SchedulerBrowser schedule new task after a cancellation" time="0.051">
    </testcase>
    <testcase classname="SchedulerBrowser when isInputPending is available, we can wait longer before yielding" name="SchedulerBrowser when isInputPending is available, we can wait longer before yielding" time="0.007">
    </testcase>
    <testcase classname="SchedulerBrowser isInputPending will also check for continuous inputs, but after a slightly larger threshold" name="SchedulerBrowser isInputPending will also check for continuous inputs, but after a slightly larger threshold" time="0.003">
    </testcase>
    <testcase classname="SchedulerBrowser requestPaint forces a yield at the end of the next frame interval" name="SchedulerBrowser requestPaint forces a yield at the end of the next frame interval" time="0.018">
    </testcase>
  </testsuite>
  <testsuite name="packages/scheduler/src/__tests__/SchedulerMock-test.js" errors="0" failures="0" skipped="1" timestamp="2022-08-05T04:11:02" time="0.774" tests="25">
    <testcase classname="Scheduler flushes work incrementally" name="Scheduler flushes work incrementally" time="0.004">
    </testcase>
    <testcase classname="Scheduler cancels work" name="Scheduler cancels work" time="0.01">
    </testcase>
    <testcase classname="Scheduler executes the highest priority callbacks first" name="Scheduler executes the highest priority callbacks first" time="0.003">
    </testcase>
    <testcase classname="Scheduler expires work" name="Scheduler expires work" time="0.006">
    </testcase>
    <testcase classname="Scheduler has a default expiration of ~5 seconds" name="Scheduler has a default expiration of ~5 seconds" time="0.003">
    </testcase>
    <testcase classname="Scheduler continues working on same task after yielding" name="Scheduler continues working on same task after yielding" time="0.022">
    </testcase>
    <testcase classname="Scheduler continuation callbacks inherit the expiration of the previous callback" name="Scheduler continuation callbacks inherit the expiration of the previous callback" time="0.002">
    </testcase>
    <testcase classname="Scheduler continuations are interrupted by higher priority work" name="Scheduler continuations are interrupted by higher priority work" time="0.003">
    </testcase>
    <testcase classname="Scheduler continuations do not block higher priority work scheduled inside an executing callback" name="Scheduler continuations do not block higher priority work scheduled inside an executing callback" time="0.002">
    </testcase>
    <testcase classname="Scheduler cancelling a continuation" name="Scheduler cancelling a continuation" time="0.02">
    </testcase>
    <testcase classname="Scheduler top-level immediate callbacks fire in a subsequent task" name="Scheduler top-level immediate callbacks fire in a subsequent task" time="0.002">
    </testcase>
    <testcase classname="Scheduler nested immediate callbacks are added to the queue of immediate callbacks" name="Scheduler nested immediate callbacks are added to the queue of immediate callbacks" time="0.028">
    </testcase>
    <testcase classname="Scheduler wrapped callbacks have same signature as original callback" name="Scheduler wrapped callbacks have same signature as original callback" time="0.002">
    </testcase>
    <testcase classname="Scheduler wrapped callbacks inherit the current priority" name="Scheduler wrapped callbacks inherit the current priority" time="0.004">
    </testcase>
    <testcase classname="Scheduler wrapped callbacks inherit the current priority even when nested" name="Scheduler wrapped callbacks inherit the current priority even when nested" time="0.001">
    </testcase>
    <testcase classname="Scheduler immediate callbacks fire even if there&apos;s an error" name="Scheduler immediate callbacks fire even if there&apos;s an error" time="0.019">
    </testcase>
    <testcase classname="Scheduler multiple immediate callbacks can throw and there will be an error for each one" name="Scheduler multiple immediate callbacks can throw and there will be an error for each one" time="0.002">
    </testcase>
    <testcase classname="Scheduler exposes the current priority level" name="Scheduler exposes the current priority level" time="0.002">
    </testcase>
    <testcase classname="Scheduler adds extra function to the JS stack whose name includes the priority level" name="Scheduler adds extra function to the JS stack whose name includes the priority level" time="0">
      <skipped/>
    </testcase>
    <testcase classname="Scheduler delayed tasks schedules a delayed task" name="Scheduler delayed tasks schedules a delayed task" time="0.002">
    </testcase>
    <testcase classname="Scheduler delayed tasks schedules multiple delayed tasks" name="Scheduler delayed tasks schedules multiple delayed tasks" time="0.012">
    </testcase>
    <testcase classname="Scheduler delayed tasks interleaves normal tasks and delayed tasks" name="Scheduler delayed tasks interleaves normal tasks and delayed tasks" time="0.002">
    </testcase>
    <testcase classname="Scheduler delayed tasks interleaves delayed tasks with time-sliced tasks" name="Scheduler delayed tasks interleaves delayed tasks with time-sliced tasks" time="0.002">
    </testcase>
    <testcase classname="Scheduler delayed tasks cancels a delayed task" name="Scheduler delayed tasks cancels a delayed task" time="0.001">
    </testcase>
    <testcase classname="Scheduler delayed tasks gracefully handles scheduled tasks that are not a function" name="Scheduler delayed tasks gracefully handles scheduled tasks that are not a function" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="packages/scheduler/src/__tests__/SchedulerPostTask-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:03" time="0.749" tests="8">
    <testcase classname="SchedulerPostTask task that finishes before deadline" name="SchedulerPostTask task that finishes before deadline" time="0.135">
    </testcase>
    <testcase classname="SchedulerPostTask task with continuation" name="SchedulerPostTask task with continuation" time="0.001">
    </testcase>
    <testcase classname="SchedulerPostTask multiple tasks" name="SchedulerPostTask multiple tasks" time="0.002">
    </testcase>
    <testcase classname="SchedulerPostTask cancels tasks" name="SchedulerPostTask cancels tasks" time="0.001">
    </testcase>
    <testcase classname="SchedulerPostTask an error in one task does not affect execution of other tasks" name="SchedulerPostTask an error in one task does not affect execution of other tasks" time="0.025">
    </testcase>
    <testcase classname="SchedulerPostTask schedule new task after queue has emptied" name="SchedulerPostTask schedule new task after queue has emptied" time="0.002">
    </testcase>
    <testcase classname="SchedulerPostTask schedule new task after a cancellation" name="SchedulerPostTask schedule new task after a cancellation" time="0.001">
    </testcase>
    <testcase classname="SchedulerPostTask schedules tasks at different priorities" name="SchedulerPostTask schedules tasks at different priorities" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="packages/use-sync-external-store/src/__tests__/useSyncExternalStoreNative-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:10:54" time="17.363" tests="2">
    <testcase classname="useSyncExternalStore (userspace shim, server rendering) native version" name="useSyncExternalStore (userspace shim, server rendering) native version" time="11.791">
    </testcase>
    <testcase classname="useSyncExternalStore (userspace shim, server rendering) [GATED, SHOULD FAIL] Using isEqual to bailout" name="useSyncExternalStore (userspace shim, server rendering) [GATED, SHOULD FAIL] Using isEqual to bailout" time="0.086">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-is/src/__tests__/ReactIs-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:10:55" time="17.006" tests="14">
    <testcase classname="ReactIs should return undefined for unknown/invalid types" name="ReactIs should return undefined for unknown/invalid types" time="11.792">
    </testcase>
    <testcase classname="ReactIs identifies valid element types" name="ReactIs identifies valid element types" time="0.073">
    </testcase>
    <testcase classname="ReactIs should identify context consumers" name="ReactIs should identify context consumers" time="0.118">
    </testcase>
    <testcase classname="ReactIs should identify context providers" name="ReactIs should identify context providers" time="0.114">
    </testcase>
    <testcase classname="ReactIs should identify elements" name="ReactIs should identify elements" time="0.079">
    </testcase>
    <testcase classname="ReactIs should identify ref forwarding component" name="ReactIs should identify ref forwarding component" time="0.071">
    </testcase>
    <testcase classname="ReactIs should identify fragments" name="ReactIs should identify fragments" time="0.06">
    </testcase>
    <testcase classname="ReactIs should identify portals" name="ReactIs should identify portals" time="0.035">
    </testcase>
    <testcase classname="ReactIs should identify memo" name="ReactIs should identify memo" time="0.069">
    </testcase>
    <testcase classname="ReactIs should identify lazy" name="ReactIs should identify lazy" time="0.077">
    </testcase>
    <testcase classname="ReactIs should identify strict mode" name="ReactIs should identify strict mode" time="0.036">
    </testcase>
    <testcase classname="ReactIs should identify suspense" name="ReactIs should identify suspense" time="0.035">
    </testcase>
    <testcase classname="ReactIs should identify suspense list" name="ReactIs should identify suspense list" time="0.06">
    </testcase>
    <testcase classname="ReactIs should identify profile root" name="ReactIs should identify profile root" time="0.057">
    </testcase>
  </testsuite>
  <testsuite name="packages/scheduler/src/__tests__/SchedulerSetImmediate-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:12" time="0.42" tests="11">
    <testcase classname="SchedulerDOMSetImmediate does not use setImmediate override" name="SchedulerDOMSetImmediate does not use setImmediate override" time="0.018">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate task that finishes before deadline" name="SchedulerDOMSetImmediate task that finishes before deadline" time="0.001">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate task with continuation" name="SchedulerDOMSetImmediate task with continuation" time="0.002">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate multiple tasks" name="SchedulerDOMSetImmediate multiple tasks" time="0.004">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate multiple tasks at different priority" name="SchedulerDOMSetImmediate multiple tasks at different priority" time="0.003">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate multiple tasks with a yield in between" name="SchedulerDOMSetImmediate multiple tasks with a yield in between" time="0.013">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate cancels tasks" name="SchedulerDOMSetImmediate cancels tasks" time="0.002">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate throws when a task errors then continues in a new event" name="SchedulerDOMSetImmediate throws when a task errors then continues in a new event" time="0.004">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate schedule new task after queue has emptied" name="SchedulerDOMSetImmediate schedule new task after queue has emptied" time="0.003">
    </testcase>
    <testcase classname="SchedulerDOMSetImmediate schedule new task after a cancellation" name="SchedulerDOMSetImmediate schedule new task after a cancellation" time="0.001">
    </testcase>
    <testcase classname=" does not crash if setImmediate is undefined" name=" does not crash if setImmediate is undefined" time="0.009">
    </testcase>
  </testsuite>
  <testsuite name="packages/use-sync-external-store/src/__tests__/useSyncExternalStoreShimServer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:10:54" time="18.772" tests="1">
    <testcase classname="useSyncExternalStore (userspace shim, server rendering) basic server render" name="useSyncExternalStore (userspace shim, server rendering) basic server render" time="13.345">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-interactions/events/src/dom/create-event-handle/__tests__/useFocus-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:10:55" time="17.781" tests="22">
    <testcase classname="useFocus hasPointerEvents=true disabled does not call callbacks" name="useFocus hasPointerEvents=true disabled does not call callbacks" time="10.855">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onBlur is called after &quot;blur&quot; event" name="useFocus hasPointerEvents=true onBlur is called after &quot;blur&quot; event" time="0.116">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onFocus is called after &quot;focus&quot; event" name="useFocus hasPointerEvents=true onFocus is called after &quot;focus&quot; event" time="0.086">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onFocus is not called if descendants of target receive focus" name="useFocus hasPointerEvents=true onFocus is not called if descendants of target receive focus" time="0.098">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onFocusChange is called after &quot;blur&quot; and &quot;focus&quot; events" name="useFocus hasPointerEvents=true onFocusChange is called after &quot;blur&quot; and &quot;focus&quot; events" time="0.156">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onFocusChange is not called after &quot;blur&quot; and &quot;focus&quot; events on descendants" name="useFocus hasPointerEvents=true onFocusChange is not called after &quot;blur&quot; and &quot;focus&quot; events on descendants" time="0.055">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onFocusVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; if keyboard navigation is active" name="useFocus hasPointerEvents=true onFocusVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; if keyboard navigation is active" time="0.112">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onFocusVisibleChange is called if non-keyboard event is dispatched on target previously focused with keyboard" name="useFocus hasPointerEvents=true onFocusVisibleChange is called if non-keyboard event is dispatched on target previously focused with keyboard" time="0.069">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onFocusVisibleChange is not called after &quot;focus&quot; and &quot;blur&quot; events without keyboard" name="useFocus hasPointerEvents=true onFocusVisibleChange is not called after &quot;focus&quot; and &quot;blur&quot; events without keyboard" time="0.09">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true onFocusVisibleChange is not called after &quot;blur&quot; and &quot;focus&quot; events on descendants" name="useFocus hasPointerEvents=true onFocusVisibleChange is not called after &quot;blur&quot; and &quot;focus&quot; events on descendants" time="0.063">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=true nested Focus components propagates events in the correct order" name="useFocus hasPointerEvents=true nested Focus components propagates events in the correct order" time="0.072">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false disabled does not call callbacks" name="useFocus hasPointerEvents=false disabled does not call callbacks" time="0.058">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onBlur is called after &quot;blur&quot; event" name="useFocus hasPointerEvents=false onBlur is called after &quot;blur&quot; event" time="0.056">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onFocus is called after &quot;focus&quot; event" name="useFocus hasPointerEvents=false onFocus is called after &quot;focus&quot; event" time="0.07">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onFocus is not called if descendants of target receive focus" name="useFocus hasPointerEvents=false onFocus is not called if descendants of target receive focus" time="0.059">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onFocusChange is called after &quot;blur&quot; and &quot;focus&quot; events" name="useFocus hasPointerEvents=false onFocusChange is called after &quot;blur&quot; and &quot;focus&quot; events" time="0.086">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onFocusChange is not called after &quot;blur&quot; and &quot;focus&quot; events on descendants" name="useFocus hasPointerEvents=false onFocusChange is not called after &quot;blur&quot; and &quot;focus&quot; events on descendants" time="0.079">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onFocusVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; if keyboard navigation is active" name="useFocus hasPointerEvents=false onFocusVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; if keyboard navigation is active" time="0.061">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onFocusVisibleChange is called if non-keyboard event is dispatched on target previously focused with keyboard" name="useFocus hasPointerEvents=false onFocusVisibleChange is called if non-keyboard event is dispatched on target previously focused with keyboard" time="0.061">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onFocusVisibleChange is not called after &quot;focus&quot; and &quot;blur&quot; events without keyboard" name="useFocus hasPointerEvents=false onFocusVisibleChange is not called after &quot;focus&quot; and &quot;blur&quot; events without keyboard" time="0.093">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false onFocusVisibleChange is not called after &quot;blur&quot; and &quot;focus&quot; events on descendants" name="useFocus hasPointerEvents=false onFocusVisibleChange is not called after &quot;blur&quot; and &quot;focus&quot; events on descendants" time="0.065">
    </testcase>
    <testcase classname="useFocus hasPointerEvents=false nested Focus components propagates events in the correct order" name="useFocus hasPointerEvents=false nested Focus components propagates events in the correct order" time="0.062">
    </testcase>
  </testsuite>
  <testsuite name="packages/use-sync-external-store/src/__tests__/useSyncExternalStoreShared-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:10:55" time="17.761" tests="19">
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) basic usage" name="Shared useSyncExternalStore behavior (shim and built-in) basic usage" time="11.018">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) skips re-rendering if nothing changes" name="Shared useSyncExternalStore behavior (shim and built-in) skips re-rendering if nothing changes" time="0.044">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) switch to a different store" name="Shared useSyncExternalStore behavior (shim and built-in) switch to a different store" time="0.118">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) selecting a specific value inside getSnapshot" name="Shared useSyncExternalStore behavior (shim and built-in) selecting a specific value inside getSnapshot" time="0.082">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) [GATED, SHOULD FAIL] compares to current state before bailing out, even when there&apos;s a mutation in between the sync and passive effects" name="Shared useSyncExternalStore behavior (shim and built-in) [GATED, SHOULD FAIL] compares to current state before bailing out, even when there&apos;s a mutation in between the sync and passive effects" time="0.169">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) mutating the store in between render and commit when getSnapshot has changed" name="Shared useSyncExternalStore behavior (shim and built-in) mutating the store in between render and commit when getSnapshot has changed" time="0.078">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) mutating the store in between render and commit when getSnapshot has _not_ changed" name="Shared useSyncExternalStore behavior (shim and built-in) mutating the store in between render and commit when getSnapshot has _not_ changed" time="0.058">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) does not bail out if the previous update hasn&apos;t finished yet" name="Shared useSyncExternalStore behavior (shim and built-in) does not bail out if the previous update hasn&apos;t finished yet" time="0.084">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) uses the latest getSnapshot, even if it changed in the same batch as a store update" name="Shared useSyncExternalStore behavior (shim and built-in) uses the latest getSnapshot, even if it changed in the same batch as a store update" time="0.106">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) handles errors thrown by getSnapshot" name="Shared useSyncExternalStore behavior (shim and built-in) handles errors thrown by getSnapshot" time="0.076">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) Infinite loop if getSnapshot keeps returning new reference" name="Shared useSyncExternalStore behavior (shim and built-in) Infinite loop if getSnapshot keeps returning new reference" time="0.103">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) getSnapshot can return NaN without infinite loop warning" name="Shared useSyncExternalStore behavior (shim and built-in) getSnapshot can return NaN without infinite loop warning" time="0.057">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) extra features implemented in user-space [GATED, SHOULD FAIL] memoized selectors are only called once per update" name="Shared useSyncExternalStore behavior (shim and built-in) extra features implemented in user-space [GATED, SHOULD FAIL] memoized selectors are only called once per update" time="0.084">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) extra features implemented in user-space [GATED, SHOULD FAIL] Using isEqual to bailout" name="Shared useSyncExternalStore behavior (shim and built-in) extra features implemented in user-space [GATED, SHOULD FAIL] Using isEqual to bailout" time="0.107">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) extra features implemented in user-space basic server hydration" name="Shared useSyncExternalStore behavior (shim and built-in) extra features implemented in user-space basic server hydration" time="0.139">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) regression test for #23150" name="Shared useSyncExternalStore behavior (shim and built-in) regression test for #23150" time="0.17">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) [GATED, SHOULD FAIL] compares selection to rendered selection even if selector changes" name="Shared useSyncExternalStore behavior (shim and built-in) [GATED, SHOULD FAIL] compares selection to rendered selection even if selector changes" time="0.181">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) selector and isEqual error handling in extra selector can throw on update" name="Shared useSyncExternalStore behavior (shim and built-in) selector and isEqual error handling in extra selector can throw on update" time="0.055">
    </testcase>
    <testcase classname="Shared useSyncExternalStore behavior (shim and built-in) selector and isEqual error handling in extra isEqual can throw on update" name="Shared useSyncExternalStore behavior (shim and built-in) selector and isEqual error handling in extra isEqual can throw on update" time="0.089">
    </testcase>
  </testsuite>
  <testsuite name="packages/scheduler/src/__tests__/SchedulerSetTimeout-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:13" time="0.298" tests="5">
    <testcase classname="SchedulerNoDOM runAllTimers flushes all scheduled callbacks" name="SchedulerNoDOM runAllTimers flushes all scheduled callbacks" time="0.003">
    </testcase>
    <testcase classname="SchedulerNoDOM executes callbacks in order of priority" name="SchedulerNoDOM executes callbacks in order of priority" time="0.001">
    </testcase>
    <testcase classname="SchedulerNoDOM handles errors" name="SchedulerNoDOM handles errors" time="0.002">
    </testcase>
    <testcase classname="does not crash non-node SSR environments if setTimeout is undefined" name="does not crash non-node SSR environments if setTimeout is undefined" time="0.001">
    </testcase>
    <testcase classname="does not crash non-node SSR environments if clearTimeout is undefined" name="does not crash non-node SSR environments if clearTimeout is undefined" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="packages/scheduler/src/__tests__/SchedulerUMDBundle-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:13" time="0.426" tests="1">
    <testcase classname="Scheduling UMD bundle should define the same scheduling API" name="Scheduling UMD bundle should define the same scheduling API" time="0.151">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-interactions/events/src/dom/create-event-handle/__tests__/useFocusWithin-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:10:55" time="18.697" tests="32">
    <testcase classname="useFocus disabled prevents custom events being dispatched" name="useFocus disabled prevents custom events being dispatched" time="10.82">
    </testcase>
    <testcase classname="useFocus onFocusWithinChange is called after &quot;blur&quot; and &quot;focus&quot; events on focus target" name="useFocus onFocusWithinChange is called after &quot;blur&quot; and &quot;focus&quot; events on focus target" time="0.119">
    </testcase>
    <testcase classname="useFocus onFocusWithinChange is called after &quot;blur&quot; and &quot;focus&quot; events on descendants" name="useFocus onFocusWithinChange is called after &quot;blur&quot; and &quot;focus&quot; events on descendants" time="0.097">
    </testcase>
    <testcase classname="useFocus onFocusWithinChange is only called once when focus moves within and outside the subtree" name="useFocus onFocusWithinChange is only called once when focus moves within and outside the subtree" time="0.18">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; on focus target if keyboard was used" name="useFocus onFocusWithinVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; on focus target if keyboard was used" time="0.079">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; on descendants if keyboard was used" name="useFocus onFocusWithinVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; on descendants if keyboard was used" time="0.104">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is called if non-keyboard event is dispatched on target previously focused with keyboard" name="useFocus onFocusWithinVisibleChange is called if non-keyboard event is dispatched on target previously focused with keyboard" time="0.087">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is not called after &quot;focus&quot; and &quot;blur&quot; events without keyboard" name="useFocus onFocusWithinVisibleChange is not called after &quot;focus&quot; and &quot;blur&quot; events without keyboard" time="0.11">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is only called once when focus moves within and outside the subtree" name="useFocus onFocusWithinVisibleChange is only called once when focus moves within and outside the subtree" time="0.066">
    </testcase>
    <testcase classname="useFocus should correctly handle focus visibility when typing into an input" name="useFocus should correctly handle focus visibility when typing into an input" time="0.084">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a focused element is unmounted" name="useFocus onBeforeBlurWithin is called after a focused element is unmounted" time="0.081">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a nested focused element is unmounted" name="useFocus onBeforeBlurWithin is called after a nested focused element is unmounted" time="0.084">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after many elements are unmounted" name="useFocus onBeforeBlurWithin is called after many elements are unmounted" time="0.111">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a nested focused element is unmounted (with scope query)" name="useFocus onBeforeBlurWithin is called after a nested focused element is unmounted (with scope query)" time="0.085">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a focused suspended element is hidden" name="useFocus onBeforeBlurWithin is called after a focused suspended element is hidden" time="0.101">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a focused suspended element is hidden then shown" name="useFocus onBeforeBlurWithin is called after a focused suspended element is hidden then shown" time="0.117">
    </testcase>
    <testcase classname="useFocus disabled prevents custom events being dispatched" name="useFocus disabled prevents custom events being dispatched" time="0.048">
    </testcase>
    <testcase classname="useFocus onFocusWithinChange is called after &quot;blur&quot; and &quot;focus&quot; events on focus target" name="useFocus onFocusWithinChange is called after &quot;blur&quot; and &quot;focus&quot; events on focus target" time="0.076">
    </testcase>
    <testcase classname="useFocus onFocusWithinChange is called after &quot;blur&quot; and &quot;focus&quot; events on descendants" name="useFocus onFocusWithinChange is called after &quot;blur&quot; and &quot;focus&quot; events on descendants" time="0.055">
    </testcase>
    <testcase classname="useFocus onFocusWithinChange is only called once when focus moves within and outside the subtree" name="useFocus onFocusWithinChange is only called once when focus moves within and outside the subtree" time="0.08">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; on focus target if keyboard was used" name="useFocus onFocusWithinVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; on focus target if keyboard was used" time="0.067">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; on descendants if keyboard was used" name="useFocus onFocusWithinVisibleChange is called after &quot;focus&quot; and &quot;blur&quot; on descendants if keyboard was used" time="0.059">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is called if non-keyboard event is dispatched on target previously focused with keyboard" name="useFocus onFocusWithinVisibleChange is called if non-keyboard event is dispatched on target previously focused with keyboard" time="0.067">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is not called after &quot;focus&quot; and &quot;blur&quot; events without keyboard" name="useFocus onFocusWithinVisibleChange is not called after &quot;focus&quot; and &quot;blur&quot; events without keyboard" time="0.078">
    </testcase>
    <testcase classname="useFocus onFocusWithinVisibleChange is only called once when focus moves within and outside the subtree" name="useFocus onFocusWithinVisibleChange is only called once when focus moves within and outside the subtree" time="0.073">
    </testcase>
    <testcase classname="useFocus should correctly handle focus visibility when typing into an input" name="useFocus should correctly handle focus visibility when typing into an input" time="0.072">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a focused element is unmounted" name="useFocus onBeforeBlurWithin is called after a focused element is unmounted" time="0.07">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a nested focused element is unmounted" name="useFocus onBeforeBlurWithin is called after a nested focused element is unmounted" time="0.06">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after many elements are unmounted" name="useFocus onBeforeBlurWithin is called after many elements are unmounted" time="0.076">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a nested focused element is unmounted (with scope query)" name="useFocus onBeforeBlurWithin is called after a nested focused element is unmounted (with scope query)" time="0.063">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a focused suspended element is hidden" name="useFocus onBeforeBlurWithin is called after a focused suspended element is hidden" time="0.068">
    </testcase>
    <testcase classname="useFocus onBeforeBlurWithin is called after a focused suspended element is hidden then shown" name="useFocus onBeforeBlurWithin is called after a focused suspended element is hidden then shown" time="0.104">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/ReactNativeError-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:13" time="2.334" tests="2">
    <testcase classname="ReactNativeError should throw error if null component registration getter is used" name="ReactNativeError should throw error if null component registration getter is used" time="1.918">
    </testcase>
    <testcase classname="ReactNativeError should be able to extract a component stack from a native view" name="ReactNativeError should be able to extract a component stack from a native view" time="0.088">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/ReactNativeEvents-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:14" time="2.069" tests="7">
    <testcase classname=" fails to register the same event name with different types" name=" fails to register the same event name with different types" time="1.171">
    </testcase>
    <testcase classname=" fails if unknown/unsupported event types are dispatched" name=" fails if unknown/unsupported event types are dispatched" time="0.053">
    </testcase>
    <testcase classname=" handles events" name=" handles events" time="0.065">
    </testcase>
    <testcase classname=" handles events on text nodes" name=" handles events on text nodes" time="0.037">
    </testcase>
    <testcase classname=" handles when a responder is unmounted while a touch sequence is in progress" name=" handles when a responder is unmounted while a touch sequence is in progress" time="0.048">
    </testcase>
    <testcase classname=" handles events without target" name=" handles events without target" time="0.125">
    </testcase>
    <testcase classname=" dispatches event with target as instance" name=" dispatches event with target as instance" time="0.035">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/ReactFabricAndNative-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:13" time="3.11" tests="8">
    <testcase classname="created with ReactFabric called with ReactNative find Fabric instances with the RN renderer" name="created with ReactFabric called with ReactNative find Fabric instances with the RN renderer" time="2.066">
    </testcase>
    <testcase classname="created with ReactFabric called with ReactNative find Fabric nodes with the RN renderer" name="created with ReactFabric called with ReactNative find Fabric nodes with the RN renderer" time="0.093">
    </testcase>
    <testcase classname="created with ReactFabric called with ReactNative dispatches commands on Fabric nodes with the RN renderer" name="created with ReactFabric called with ReactNative dispatches commands on Fabric nodes with the RN renderer" time="0.138">
    </testcase>
    <testcase classname="created with ReactFabric called with ReactNative dispatches sendAccessibilityEvent on Fabric nodes with the RN renderer" name="created with ReactFabric called with ReactNative dispatches sendAccessibilityEvent on Fabric nodes with the RN renderer" time="0.094">
    </testcase>
    <testcase classname="created with ReactNative called with ReactFabric find Paper instances with the Fabric renderer" name="created with ReactNative called with ReactFabric find Paper instances with the Fabric renderer" time="0.09">
    </testcase>
    <testcase classname="created with ReactNative called with ReactFabric find Paper nodes with the Fabric renderer" name="created with ReactNative called with ReactFabric find Paper nodes with the Fabric renderer" time="0.092">
    </testcase>
    <testcase classname="created with ReactNative called with ReactFabric dispatches commands on Paper nodes with the Fabric renderer" name="created with ReactNative called with ReactFabric dispatches commands on Paper nodes with the Fabric renderer" time="0.074">
    </testcase>
    <testcase classname="created with ReactNative called with ReactFabric dispatches sendAccessibilityEvent on Paper nodes with the Fabric renderer" name="created with ReactNative called with ReactFabric dispatches sendAccessibilityEvent on Paper nodes with the Fabric renderer" time="0.079">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/ReactFabric-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:13" time="3.513" tests="24">
    <testcase classname="ReactFabric should be able to create and render a native component" name="ReactFabric should be able to create and render a native component" time="1.847">
    </testcase>
    <testcase classname="ReactFabric should be able to create and update a native component" name="ReactFabric should be able to create and update a native component" time="0.047">
    </testcase>
    <testcase classname="ReactFabric should not call FabricUIManager.cloneNode after render for properties that have not changed" name="ReactFabric should not call FabricUIManager.cloneNode after render for properties that have not changed" time="0.047">
    </testcase>
    <testcase classname="ReactFabric should only pass props diffs to FabricUIManager.cloneNode" name="ReactFabric should only pass props diffs to FabricUIManager.cloneNode" time="0.068">
    </testcase>
    <testcase classname="ReactFabric should call dispatchCommand for native refs" name="ReactFabric should call dispatchCommand for native refs" time="0.03">
    </testcase>
    <testcase classname="ReactFabric should warn and no-op if calling dispatchCommand on non native refs" name="ReactFabric should warn and no-op if calling dispatchCommand on non native refs" time="0.032">
    </testcase>
    <testcase classname="ReactFabric should call sendAccessibilityEvent for native refs" name="ReactFabric should call sendAccessibilityEvent for native refs" time="0.045">
    </testcase>
    <testcase classname="ReactFabric should warn and no-op if calling sendAccessibilityEvent on non native refs" name="ReactFabric should warn and no-op if calling sendAccessibilityEvent on non native refs" time="0.033">
    </testcase>
    <testcase classname="ReactFabric returns the correct instance and calls it in the callback" name="ReactFabric returns the correct instance and calls it in the callback" time="0.053">
    </testcase>
    <testcase classname="ReactFabric renders and reorders children" name="ReactFabric renders and reorders children" time="0.081">
    </testcase>
    <testcase classname="ReactFabric recreates host parents even if only children changed" name="ReactFabric recreates host parents even if only children changed" time="0.042">
    </testcase>
    <testcase classname="ReactFabric calls setState with no arguments" name="ReactFabric calls setState with no arguments" time="0.064">
    </testcase>
    <testcase classname="ReactFabric should call complete after inserting children" name="ReactFabric should call complete after inserting children" time="0.021">
    </testcase>
    <testcase classname="ReactFabric should not throw when &lt;View&gt; is used inside of a &lt;Text&gt; ancestor" name="ReactFabric should not throw when &lt;View&gt; is used inside of a &lt;Text&gt; ancestor" time="0.042">
    </testcase>
    <testcase classname="ReactFabric should console error for text not inside of a &lt;Text&gt; ancestor" name="ReactFabric should console error for text not inside of a &lt;Text&gt; ancestor" time="0.059">
    </testcase>
    <testcase classname="ReactFabric should not throw for text inside of an indirect &lt;Text&gt; ancestor" name="ReactFabric should not throw for text inside of an indirect &lt;Text&gt; ancestor" time="0.043">
    </testcase>
    <testcase classname="ReactFabric dispatches events to the last committed props" name="ReactFabric dispatches events to the last committed props" time="0.039">
    </testcase>
    <testcase classname="ReactFabric skipBubbling should skip bubbling to ancestor if specified" name="ReactFabric skipBubbling should skip bubbling to ancestor if specified" time="0.045">
    </testcase>
    <testcase classname="ReactFabric dispatches event with target as instance" name="ReactFabric dispatches event with target as instance" time="0.048">
    </testcase>
    <testcase classname="ReactFabric findHostInstance_DEPRECATED should warn if used to find a host component inside StrictMode" name="ReactFabric findHostInstance_DEPRECATED should warn if used to find a host component inside StrictMode" time="0.043">
    </testcase>
    <testcase classname="ReactFabric findHostInstance_DEPRECATED should warn if passed a component that is inside StrictMode" name="ReactFabric findHostInstance_DEPRECATED should warn if passed a component that is inside StrictMode" time="0.053">
    </testcase>
    <testcase classname="ReactFabric findNodeHandle should warn if used to find a host component inside StrictMode" name="ReactFabric findNodeHandle should warn if used to find a host component inside StrictMode" time="0.024">
    </testcase>
    <testcase classname="ReactFabric findNodeHandle should warn if passed a component that is inside StrictMode" name="ReactFabric findNodeHandle should warn if passed a component that is inside StrictMode" time="0.017">
    </testcase>
    <testcase classname="ReactFabric should no-op if calling sendAccessibilityEvent on unmounted refs" name="ReactFabric should no-op if calling sendAccessibilityEvent on unmounted refs" time="0.065">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/ReactNativeAttributePayload-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:17" time="0.436" tests="17">
    <testcase classname="ReactNativeAttributePayload should work with simple example" name="ReactNativeAttributePayload should work with simple example" time="0.001">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should skip fields that are equal" name="ReactNativeAttributePayload should skip fields that are equal" time="0">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should remove fields" name="ReactNativeAttributePayload should remove fields" time="0.001">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should remove fields that are set to undefined" name="ReactNativeAttributePayload should remove fields that are set to undefined" time="0">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should ignore invalid fields" name="ReactNativeAttributePayload should ignore invalid fields" time="0">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should use the diff attribute" name="ReactNativeAttributePayload should use the diff attribute" time="0.001">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should not use the diff attribute on addition/removal" name="ReactNativeAttributePayload should not use the diff attribute on addition/removal" time="0.001">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should do deep diffs of Objects by default" name="ReactNativeAttributePayload should do deep diffs of Objects by default" time="0.063">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should work with undefined styles" name="ReactNativeAttributePayload should work with undefined styles" time="0.001">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should work with empty styles" name="ReactNativeAttributePayload should work with empty styles" time="0">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should flatten nested styles and predefined styles" name="ReactNativeAttributePayload should flatten nested styles and predefined styles" time="0.002">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should reset a value to a previous if it is removed" name="ReactNativeAttributePayload should reset a value to a previous if it is removed" time="0">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should not clear removed props if they are still in another slot" name="ReactNativeAttributePayload should not clear removed props if they are still in another slot" time="0.001">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should clear a prop if a later style is explicit null/undefined" name="ReactNativeAttributePayload should clear a prop if a later style is explicit null/undefined" time="0.001">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should convert functions to booleans" name="ReactNativeAttributePayload should convert functions to booleans" time="0.008">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should skip changed functions" name="ReactNativeAttributePayload should skip changed functions" time="0.005">
    </testcase>
    <testcase classname="ReactNativeAttributePayload should skip deeply-nested changed functions" name="ReactNativeAttributePayload should skip deeply-nested changed functions" time="0">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/createReactNativeComponentClass-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:17" time="0.499" tests="2">
    <testcase classname="createReactNativeComponentClass should register viewConfigs" name="createReactNativeComponentClass should register viewConfigs" time="0.134">
    </testcase>
    <testcase classname="createReactNativeComponentClass should not allow viewConfigs with duplicate uiViewClassNames to be registered" name="createReactNativeComponentClass should not allow viewConfigs with duplicate uiViewClassNames to be registered" time="0.082">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/ResponderEventPlugin-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:16" time="1.207" tests="21">
    <testcase classname="ResponderEventPlugin should do nothing when no one wants to respond" name="ResponderEventPlugin should do nothing when no one wants to respond" time="0.043">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder grandParent while capturing" name="ResponderEventPlugin should grant responder grandParent while capturing" time="0.015">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder parent while capturing" name="ResponderEventPlugin should grant responder parent while capturing" time="0.006">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder child while capturing" name="ResponderEventPlugin should grant responder child while capturing" time="0.009">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder child while bubbling" name="ResponderEventPlugin should grant responder child while bubbling" time="0.021">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder parent while bubbling" name="ResponderEventPlugin should grant responder parent while bubbling" time="0.008">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder grandParent while bubbling" name="ResponderEventPlugin should grant responder grandParent while bubbling" time="0.019">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder grandParent while capturing move" name="ResponderEventPlugin should grant responder grandParent while capturing move" time="0.012">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder parent while capturing move" name="ResponderEventPlugin should grant responder parent while capturing move" time="0.005">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder child while capturing move" name="ResponderEventPlugin should grant responder child while capturing move" time="0.029">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder child while bubbling move" name="ResponderEventPlugin should grant responder child while bubbling move" time="0.024">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder parent while bubbling move" name="ResponderEventPlugin should grant responder parent while bubbling move" time="0.006">
    </testcase>
    <testcase classname="ResponderEventPlugin should grant responder grandParent while bubbling move" name="ResponderEventPlugin should grant responder grandParent while bubbling move" time="0.016">
    </testcase>
    <testcase classname="ResponderEventPlugin should bubble negotiation to first common ancestor of responder" name="ResponderEventPlugin should bubble negotiation to first common ancestor of responder" time="0.008">
    </testcase>
    <testcase classname="ResponderEventPlugin should bubble negotiation to first common ancestor of responder then transfer" name="ResponderEventPlugin should bubble negotiation to first common ancestor of responder then transfer" time="0.012">
    </testcase>
    <testcase classname="ResponderEventPlugin should negotiate with deepest target on second touch if nothing is responder" name="ResponderEventPlugin should negotiate with deepest target on second touch if nothing is responder" time="0.015">
    </testcase>
    <testcase classname="ResponderEventPlugin should negotiate until first common ancestor when there are siblings" name="ResponderEventPlugin should negotiate until first common ancestor when there are siblings" time="0.03">
    </testcase>
    <testcase classname="ResponderEventPlugin should notify of being rejected. responderStart/Move happens on current responder" name="ResponderEventPlugin should notify of being rejected. responderStart/Move happens on current responder" time="0.016">
    </testcase>
    <testcase classname="ResponderEventPlugin should negotiate scroll" name="ResponderEventPlugin should negotiate scroll" time="0.007">
    </testcase>
    <testcase classname="ResponderEventPlugin should cancel correctly" name="ResponderEventPlugin should cancel correctly" time="0.005">
    </testcase>
    <testcase classname="ResponderEventPlugin should determine the first common ancestor correctly" name="ResponderEventPlugin should determine the first common ancestor correctly" time="0.331">
    </testcase>
  </testsuite>
  <testsuite name="packages/scheduler/src/__tests__/SchedulerProfiling-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:05" time="12.954" tests="9">
    <testcase classname="Scheduler creates a basic flamegraph" name="Scheduler creates a basic flamegraph" time="0.012">
    </testcase>
    <testcase classname="Scheduler marks when a task is canceled" name="Scheduler marks when a task is canceled" time="0.018">
    </testcase>
    <testcase classname="Scheduler marks when a task errors" name="Scheduler marks when a task errors" time="0.003">
    </testcase>
    <testcase classname="Scheduler marks when multiple tasks are canceled" name="Scheduler marks when multiple tasks are canceled" time="0.002">
    </testcase>
    <testcase classname="Scheduler handles cancelling a task that already finished" name="Scheduler handles cancelling a task that already finished" time="0.002">
    </testcase>
    <testcase classname="Scheduler handles cancelling a task multiple times" name="Scheduler handles cancelling a task multiple times" time="0.002">
    </testcase>
    <testcase classname="Scheduler handles delayed tasks" name="Scheduler handles delayed tasks" time="0.002">
    </testcase>
    <testcase classname="Scheduler handles cancelling a delayed task" name="Scheduler handles cancelling a delayed task" time="0.001">
    </testcase>
    <testcase classname="Scheduler automatically stops profiling and warns if event log gets too big" name="Scheduler automatically stops profiling and warns if event log gets too big" time="12.315">
    </testcase>
  </testsuite>
  <testsuite name="packages/eslint-plugin-react-hooks/__tests__/ESLintRulesOfHooks-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:14" time="4.149" tests="73">
    <testcase classname="react-hooks valid 
      // Valid because components can use hooks.
      function ComponentWithHook() {
        useHook();
      }
    " name="react-hooks valid 
      // Valid because components can use hooks.
      function ComponentWithHook() {
        useHook();
      }
    " time="0.98">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because components can use hooks.
      function createComponentWithHook() {
        return function ComponentWithHook() {
          useHook();
        };
      }
    " name="react-hooks valid 
      // Valid because components can use hooks.
      function createComponentWithHook() {
        return function ComponentWithHook() {
          useHook();
        };
      }
    " time="0.008">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can use hooks.
      function useHookWithHook() {
        useHook();
      }
    " name="react-hooks valid 
      // Valid because hooks can use hooks.
      function useHookWithHook() {
        useHook();
      }
    " time="0.007">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can use hooks.
      function createHook() {
        return function useHookWithHook() {
          useHook();
        }
      }
    " name="react-hooks valid 
      // Valid because hooks can use hooks.
      function createHook() {
        return function useHookWithHook() {
          useHook();
        }
      }
    " time="0.018">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because components can call functions.
      function ComponentWithNormalFunction() {
        doSomething();
      }
    " name="react-hooks valid 
      // Valid because components can call functions.
      function ComponentWithNormalFunction() {
        doSomething();
      }
    " time="0.004">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because functions can call functions.
      function normalFunctionWithNormalFunction() {
        doSomething();
      }
    " name="react-hooks valid 
      // Valid because functions can call functions.
      function normalFunctionWithNormalFunction() {
        doSomething();
      }
    " time="0.007">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because functions can call functions.
      function normalFunctionWithConditionalFunction() {
        if (cond) {
          doSomething();
        }
      }
    " name="react-hooks valid 
      // Valid because functions can call functions.
      function normalFunctionWithConditionalFunction() {
        if (cond) {
          doSomething();
        }
      }
    " time="0.019">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because functions can call functions.
      function functionThatStartsWithUseButIsntAHook() {
        if (cond) {
          userFetch();
        }
      }
    " name="react-hooks valid 
      // Valid because functions can call functions.
      function functionThatStartsWithUseButIsntAHook() {
        if (cond) {
          userFetch();
        }
      }
    " time="0.017">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid although unconditional return doesn&apos;t make sense and would fail other rules.
      // We could make it invalid but it doesn&apos;t matter.
      function useUnreachable() {
        return;
        useHook();
      }
    " name="react-hooks valid 
      // Valid although unconditional return doesn&apos;t make sense and would fail other rules.
      // We could make it invalid but it doesn&apos;t matter.
      function useUnreachable() {
        return;
        useHook();
      }
    " time="0.006">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() { useState(); }
      const whatever = function useHook() { useState(); };
      const useHook1 = () =&gt; { useState(); };
      let useHook2 = () =&gt; useState();
      useHook2 = () =&gt; { useState(); };
      ({useHook: () =&gt; { useState(); }});
      ({useHook() { useState(); }});
      const {useHook3 = () =&gt; { useState(); }} = {};
      ({useHook = () =&gt; { useState(); }} = {});
      Namespace.useHook = () =&gt; { useState(); };
    " name="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() { useState(); }
      const whatever = function useHook() { useState(); };
      const useHook1 = () =&gt; { useState(); };
      let useHook2 = () =&gt; useState();
      useHook2 = () =&gt; { useState(); };
      ({useHook: () =&gt; { useState(); }});
      ({useHook() { useState(); }});
      const {useHook3 = () =&gt; { useState(); }} = {};
      ({useHook = () =&gt; { useState(); }} = {});
      Namespace.useHook = () =&gt; { useState(); };
    " time="0.073">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() {
        useHook1();
        useHook2();
      }
    " name="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() {
        useHook1();
        useHook2();
      }
    " time="0.015">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can call hooks.
      function createHook() {
        return function useHook() {
          useHook1();
          useHook2();
        };
      }
    " name="react-hooks valid 
      // Valid because hooks can call hooks.
      function createHook() {
        return function useHook() {
          useHook1();
          useHook2();
        };
      }
    " time="0.006">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() {
        useState() &amp;&amp; a;
      }
    " name="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() {
        useState() &amp;&amp; a;
      }
    " time="0.018">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() {
        return useHook1() + useHook2();
      }
    " name="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() {
        return useHook1() + useHook2();
      }
    " time="0.005">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() {
        return useHook1(useHook2());
      }
    " name="react-hooks valid 
      // Valid because hooks can call hooks.
      function useHook() {
        return useHook1(useHook2());
      }
    " time="0.032">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can be used in anonymous arrow-function arguments
      // to forwardRef.
      const FancyButton = React.forwardRef((props, ref) =&gt; {
        useHook();
        return &lt;button {...props} ref={ref} /&gt;
      });
    " name="react-hooks valid 
      // Valid because hooks can be used in anonymous arrow-function arguments
      // to forwardRef.
      const FancyButton = React.forwardRef((props, ref) =&gt; {
        useHook();
        return &lt;button {...props} ref={ref} /&gt;
      });
    " time="0.02">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can be used in anonymous function arguments to
      // forwardRef.
      const FancyButton = React.forwardRef(function (props, ref) {
        useHook();
        return &lt;button {...props} ref={ref} /&gt;
      });
    " name="react-hooks valid 
      // Valid because hooks can be used in anonymous function arguments to
      // forwardRef.
      const FancyButton = React.forwardRef(function (props, ref) {
        useHook();
        return &lt;button {...props} ref={ref} /&gt;
      });
    " time="0.007">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can be used in anonymous function arguments to
      // forwardRef.
      const FancyButton = forwardRef(function (props, ref) {
        useHook();
        return &lt;button {...props} ref={ref} /&gt;
      });
    " name="react-hooks valid 
      // Valid because hooks can be used in anonymous function arguments to
      // forwardRef.
      const FancyButton = forwardRef(function (props, ref) {
        useHook();
        return &lt;button {...props} ref={ref} /&gt;
      });
    " time="0.021">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can be used in anonymous function arguments to
      // React.memo.
      const MemoizedFunction = React.memo(props =&gt; {
        useHook();
        return &lt;button {...props} /&gt;
      });
    " name="react-hooks valid 
      // Valid because hooks can be used in anonymous function arguments to
      // React.memo.
      const MemoizedFunction = React.memo(props =&gt; {
        useHook();
        return &lt;button {...props} /&gt;
      });
    " time="0.021">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because hooks can be used in anonymous function arguments to
      // memo.
      const MemoizedFunction = memo(function (props) {
        useHook();
        return &lt;button {...props} /&gt;
      });
    " name="react-hooks valid 
      // Valid because hooks can be used in anonymous function arguments to
      // memo.
      const MemoizedFunction = memo(function (props) {
        useHook();
        return &lt;button {...props} /&gt;
      });
    " time="0.006">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because classes can call functions.
      // We don&apos;t consider these to be hooks.
      class C {
        m() {
          this.useHook();
          super.useHook();
        }
      }
    " name="react-hooks valid 
      // Valid because classes can call functions.
      // We don&apos;t consider these to be hooks.
      class C {
        m() {
          this.useHook();
          super.useHook();
        }
      }
    " time="0.017">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid -- this is a regression test.
      jest.useFakeTimers();
      beforeEach(() =&gt; {
        jest.useRealTimers();
      })
    " name="react-hooks valid 
      // Valid -- this is a regression test.
      jest.useFakeTimers();
      beforeEach(() =&gt; {
        jest.useRealTimers();
      })
    " time="0.003">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because they&apos;re not matching use[A-Z].
      fooState();
      use();
      _use();
      _useState();
      use_hook();
      // also valid because it&apos;s not matching the PascalCase namespace
      jest.useFakeTimer()
    " name="react-hooks valid 
      // Valid because they&apos;re not matching use[A-Z].
      fooState();
      use();
      _use();
      _useState();
      use_hook();
      // also valid because it&apos;s not matching the PascalCase namespace
      jest.useFakeTimer()
    " time="0.009">
    </testcase>
    <testcase classname="react-hooks valid 
      // Regression test for some internal code.
      // This shows how the &quot;callback rule&quot; is more relaxed,
      // and doesn&apos;t kick in unless we&apos;re confident we&apos;re in
      // a component or a hook.
      function makeListener(instance) {
        each(pixelsWithInferredEvents, pixel =&gt; {
          if (useExtendedSelector(pixel.id) &amp;&amp; extendedButton) {
            foo();
          }
        });
      }
    " name="react-hooks valid 
      // Regression test for some internal code.
      // This shows how the &quot;callback rule&quot; is more relaxed,
      // and doesn&apos;t kick in unless we&apos;re confident we&apos;re in
      // a component or a hook.
      function makeListener(instance) {
        each(pixelsWithInferredEvents, pixel =&gt; {
          if (useExtendedSelector(pixel.id) &amp;&amp; extendedButton) {
            foo();
          }
        });
      }
    " time="0.009">
    </testcase>
    <testcase classname="react-hooks valid 
      // This is valid because &quot;use&quot;-prefixed functions called in
      // unnamed function arguments are not assumed to be hooks.
      React.unknownFunction((foo, bar) =&gt; {
        if (foo) {
          useNotAHook(bar)
        }
      });
    " name="react-hooks valid 
      // This is valid because &quot;use&quot;-prefixed functions called in
      // unnamed function arguments are not assumed to be hooks.
      React.unknownFunction((foo, bar) =&gt; {
        if (foo) {
          useNotAHook(bar)
        }
      });
    " time="0.009">
    </testcase>
    <testcase classname="react-hooks valid 
      // This is valid because &quot;use&quot;-prefixed functions called in
      // unnamed function arguments are not assumed to be hooks.
      unknownFunction(function(foo, bar) {
        if (foo) {
          useNotAHook(bar)
        }
      });
    " name="react-hooks valid 
      // This is valid because &quot;use&quot;-prefixed functions called in
      // unnamed function arguments are not assumed to be hooks.
      unknownFunction(function(foo, bar) {
        if (foo) {
          useNotAHook(bar)
        }
      });
    " time="0.021">
    </testcase>
    <testcase classname="react-hooks valid 
      // Regression test for incorrectly flagged valid code.
      function RegressionTest() {
        const foo = cond ? a : b;
        useState();
      }
    " name="react-hooks valid 
      // Regression test for incorrectly flagged valid code.
      function RegressionTest() {
        const foo = cond ? a : b;
        useState();
      }
    " time="0.005">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because exceptions abort rendering
      function RegressionTest() {
        if (page == null) {
          throw new Error(&apos;oh no!&apos;);
        }
        useState();
      }
    " name="react-hooks valid 
      // Valid because exceptions abort rendering
      function RegressionTest() {
        if (page == null) {
          throw new Error(&apos;oh no!&apos;);
        }
        useState();
      }
    " time="0.012">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because the loop doesn&apos;t change the order of hooks calls.
      function RegressionTest() {
        const res = [];
        const additionalCond = true;
        for (let i = 0; i !== 10 &amp;&amp; additionalCond; ++i ) {
          res.push(i);
        }
        React.useLayoutEffect(() =&gt; {});
      }
    " name="react-hooks valid 
      // Valid because the loop doesn&apos;t change the order of hooks calls.
      function RegressionTest() {
        const res = [];
        const additionalCond = true;
        for (let i = 0; i !== 10 &amp;&amp; additionalCond; ++i ) {
          res.push(i);
        }
        React.useLayoutEffect(() =&gt; {});
      }
    " time="0.031">
    </testcase>
    <testcase classname="react-hooks valid 
      // Is valid but hard to compute by brute-forcing
      function MyComponent() {
        // 40 conditions
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}

        // 10 hooks
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
      }
    " name="react-hooks valid 
      // Is valid but hard to compute by brute-forcing
      function MyComponent() {
        // 40 conditions
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}
        if (c) {} else {}

        // 10 hooks
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
        useHook();
      }
    " time="0.16">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because the neither the conditions before or after the hook affect the hook call
      // Failed prior to implementing BigInt because pathsFromStartToEnd and allPathsFromStartToEnd were too big and had rounding errors
      const useSomeHook = () =&gt; {};

      const SomeName = () =&gt; {
        const filler = FILLER ?? FILLER ?? FILLER;
        const filler2 = FILLER ?? FILLER ?? FILLER;
        const filler3 = FILLER ?? FILLER ?? FILLER;
        const filler4 = FILLER ?? FILLER ?? FILLER;
        const filler5 = FILLER ?? FILLER ?? FILLER;
        const filler6 = FILLER ?? FILLER ?? FILLER;
        const filler7 = FILLER ?? FILLER ?? FILLER;
        const filler8 = FILLER ?? FILLER ?? FILLER;

        useSomeHook();

        if (anyConditionCanEvenBeFalse) {
          return null;
        }

        return (
          &lt;React.Fragment&gt;
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
          &lt;/React.Fragment&gt;
        );
      };
    " name="react-hooks valid 
      // Valid because the neither the conditions before or after the hook affect the hook call
      // Failed prior to implementing BigInt because pathsFromStartToEnd and allPathsFromStartToEnd were too big and had rounding errors
      const useSomeHook = () =&gt; {};

      const SomeName = () =&gt; {
        const filler = FILLER ?? FILLER ?? FILLER;
        const filler2 = FILLER ?? FILLER ?? FILLER;
        const filler3 = FILLER ?? FILLER ?? FILLER;
        const filler4 = FILLER ?? FILLER ?? FILLER;
        const filler5 = FILLER ?? FILLER ?? FILLER;
        const filler6 = FILLER ?? FILLER ?? FILLER;
        const filler7 = FILLER ?? FILLER ?? FILLER;
        const filler8 = FILLER ?? FILLER ?? FILLER;

        useSomeHook();

        if (anyConditionCanEvenBeFalse) {
          return null;
        }

        return (
          &lt;React.Fragment&gt;
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
            {FILLER ? FILLER : FILLER}
          &lt;/React.Fragment&gt;
        );
      };
    " time="0.064">
    </testcase>
    <testcase classname="react-hooks valid 
      // Valid because the neither the condition nor the loop affect the hook call.
      function App(props) {
        const someObject = {propA: true};
        for (const propName in someObject) {
          if (propName === true) {
          } else {
          }
        }
        const [myState, setMyState] = useState(null);
      }
    " name="react-hooks valid 
      // Valid because the neither the condition nor the loop affect the hook call.
      function App(props) {
        const someObject = {propA: true};
        for (const propName in someObject) {
          if (propName === true) {
          } else {
          }
        }
        const [myState, setMyState] = useState(null);
      }
    " time="0.019">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function ComponentWithConditionalHook() {
          if (cond) {
            useConditionalHook();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function ComponentWithConditionalHook() {
          if (cond) {
            useConditionalHook();
          }
        }
      " time="0.008">
    </testcase>
    <testcase classname="react-hooks invalid 
        Hook.use();
        Hook._use();
        Hook.useState();
        Hook._useState();
        Hook.use42();
        Hook.useHook();
        Hook.use_hook();
      " name="react-hooks invalid 
        Hook.use();
        Hook._use();
        Hook.useState();
        Hook._useState();
        Hook.use42();
        Hook.useHook();
        Hook.use_hook();
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        class C {
          m() {
            This.useHook();
            Super.useHook();
          }
        }
      " name="react-hooks invalid 
        class C {
          m() {
            This.useHook();
            Super.useHook();
          }
        }
      " time="0.031">
    </testcase>
    <testcase classname="react-hooks invalid 
        // This is a false positive (it&apos;s valid) that unfortunately 
        // we cannot avoid. Prefer to rename it to not start with &quot;use&quot;
        class Foo extends Component {
          render() {
            if (cond) {
              FooStore.useFeatureFlag();
            }
          }
        }
      " name="react-hooks invalid 
        // This is a false positive (it&apos;s valid) that unfortunately 
        // we cannot avoid. Prefer to rename it to not start with &quot;use&quot;
        class Foo extends Component {
          render() {
            if (cond) {
              FooStore.useFeatureFlag();
            }
          }
        }
      " time="0.005">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function ComponentWithConditionalHook() {
          if (cond) {
            Namespace.useConditionalHook();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function ComponentWithConditionalHook() {
          if (cond) {
            Namespace.useConditionalHook();
          }
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function createComponent() {
          return function ComponentWithConditionalHook() {
            if (cond) {
              useConditionalHook();
            }
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function createComponent() {
          return function ComponentWithConditionalHook() {
            if (cond) {
              useConditionalHook();
            }
          }
        }
      " time="0.005">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHookWithConditionalHook() {
          if (cond) {
            useConditionalHook();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHookWithConditionalHook() {
          if (cond) {
            useConditionalHook();
          }
        }
      " time="0.005">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function createHook() {
          return function useHookWithConditionalHook() {
            if (cond) {
              useConditionalHook();
            }
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function createHook() {
          return function useHookWithConditionalHook() {
            if (cond) {
              useConditionalHook();
            }
          }
        }
      " time="0.002">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function ComponentWithTernaryHook() {
          cond ? useTernaryHook() : null;
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function ComponentWithTernaryHook() {
          cond ? useTernaryHook() : null;
        }
      " time="0.027">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        function ComponentWithHookInsideCallback() {
          useEffect(() =&gt; {
            useHookInsideCallback();
          });
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        function ComponentWithHookInsideCallback() {
          useEffect(() =&gt; {
            useHookInsideCallback();
          });
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        function createComponent() {
          return function ComponentWithHookInsideCallback() {
            useEffect(() =&gt; {
              useHookInsideCallback();
            });
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        function createComponent() {
          return function ComponentWithHookInsideCallback() {
            useEffect(() =&gt; {
              useHookInsideCallback();
            });
          }
        }
      " time="0.007">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        const ComponentWithHookInsideCallback = React.forwardRef((props, ref) =&gt; {
          useEffect(() =&gt; {
            useHookInsideCallback();
          });
          return &lt;button {...props} ref={ref} /&gt;
        });
      " name="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        const ComponentWithHookInsideCallback = React.forwardRef((props, ref) =&gt; {
          useEffect(() =&gt; {
            useHookInsideCallback();
          });
          return &lt;button {...props} ref={ref} /&gt;
        });
      " time="0.005">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        const ComponentWithHookInsideCallback = React.memo(props =&gt; {
          useEffect(() =&gt; {
            useHookInsideCallback();
          });
          return &lt;button {...props} /&gt;
        });
      " name="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        const ComponentWithHookInsideCallback = React.memo(props =&gt; {
          useEffect(() =&gt; {
            useHookInsideCallback();
          });
          return &lt;button {...props} /&gt;
        });
      " time="0.017">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        function ComponentWithHookInsideCallback() {
          function handleClick() {
            useState();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        function ComponentWithHookInsideCallback() {
          function handleClick() {
            useState();
          }
        }
      " time="0.002">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        function createComponent() {
          return function ComponentWithHookInsideCallback() {
            function handleClick() {
              useState();
            }
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s a common misunderstanding.
        // We *could* make it valid but the runtime error could be confusing.
        function createComponent() {
          return function ComponentWithHookInsideCallback() {
            function handleClick() {
              useState();
            }
          }
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function ComponentWithHookInsideLoop() {
          while (cond) {
            useHookInsideLoop();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function ComponentWithHookInsideLoop() {
          while (cond) {
            useHookInsideLoop();
          }
        }
      " time="0.002">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function renderItem() {
          useState();
        }

        function List(props) {
          return props.items.map(renderItem);
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function renderItem() {
          useState();
        }

        function List(props) {
          return props.items.map(renderItem);
        }
      " time="0.014">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Currently invalid because it violates the convention and removes the &quot;taint&quot;
        // from a hook. We *could* make it valid to avoid some false positives but let&apos;s
        // ensure that we don&apos;t break the &quot;renderItem&quot; and &quot;normalFunctionWithConditionalHook&quot;
        // cases which must remain invalid.
        function normalFunctionWithHook() {
          useHookInsideNormalFunction();
        }
      " name="react-hooks invalid 
        // Currently invalid because it violates the convention and removes the &quot;taint&quot;
        // from a hook. We *could* make it valid to avoid some false positives but let&apos;s
        // ensure that we don&apos;t break the &quot;renderItem&quot; and &quot;normalFunctionWithConditionalHook&quot;
        // cases which must remain invalid.
        function normalFunctionWithHook() {
          useHookInsideNormalFunction();
        }
      " time="0.002">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function normalFunctionWithConditionalHook() {
          if (cond) {
            useHookInsideNormalFunction();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function normalFunctionWithConditionalHook() {
          if (cond) {
            useHookInsideNormalFunction();
          }
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHookInLoops() {
          while (a) {
            useHook1();
            if (b) return;
            useHook2();
          }
          while (c) {
            useHook3();
            if (d) return;
            useHook4();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHookInLoops() {
          while (a) {
            useHook1();
            if (b) return;
            useHook2();
          }
          while (c) {
            useHook3();
            if (d) return;
            useHook4();
          }
        }
      " time="0.016">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHookInLoops() {
          while (a) {
            useHook1();
            if (b) continue;
            useHook2();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHookInLoops() {
          while (a) {
            useHook1();
            if (b) continue;
            useHook2();
          }
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useLabeledBlock() {
          label: {
            if (a) break label;
            useHook();
          }
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useLabeledBlock() {
          label: {
            if (a) break label;
            useHook();
          }
        }
      " time="0.005">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Currently invalid.
        // These are variations capturing the current heuristic--
        // we only allow hooks in PascalCase or useFoo functions.
        // We *could* make some of these valid. But before doing it,
        // consider specific cases documented above that contain reasoning.
        function a() { useState(); }
        const whatever = function b() { useState(); };
        const c = () =&gt; { useState(); };
        let d = () =&gt; useState();
        e = () =&gt; { useState(); };
        ({f: () =&gt; { useState(); }});
        ({g() { useState(); }});
        const {j = () =&gt; { useState(); }} = {};
        ({k = () =&gt; { useState(); }} = {});
      " name="react-hooks invalid 
        // Currently invalid.
        // These are variations capturing the current heuristic--
        // we only allow hooks in PascalCase or useFoo functions.
        // We *could* make some of these valid. But before doing it,
        // consider specific cases documented above that contain reasoning.
        function a() { useState(); }
        const whatever = function b() { useState(); };
        const c = () =&gt; { useState(); };
        let d = () =&gt; useState();
        e = () =&gt; { useState(); };
        ({f: () =&gt; { useState(); }});
        ({g() { useState(); }});
        const {j = () =&gt; { useState(); }} = {};
        ({k = () =&gt; { useState(); }} = {});
      " time="0.024">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          if (a) return;
          useState();
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          if (a) return;
          useState();
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          if (a) return;
          if (b) {
            console.log(&apos;true&apos;);
          } else {
            console.log(&apos;false&apos;);
          }
          useState();
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          if (a) return;
          if (b) {
            console.log(&apos;true&apos;);
          } else {
            console.log(&apos;false&apos;);
          }
          useState();
        }
      " time="0.013">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          if (b) {
            console.log(&apos;true&apos;);
          } else {
            console.log(&apos;false&apos;);
          }
          if (a) return;
          useState();
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          if (b) {
            console.log(&apos;true&apos;);
          } else {
            console.log(&apos;false&apos;);
          }
          if (a) return;
          useState();
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          a &amp;&amp; useHook1();
          b &amp;&amp; useHook2();
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          a &amp;&amp; useHook1();
          b &amp;&amp; useHook2();
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          try {
            f();
            useState();
          } catch {}
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook() {
          try {
            f();
            useState();
          } catch {}
        }
      " time="0.021">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook({ bar }) {
          let foo1 = bar &amp;&amp; useState();
          let foo2 = bar || useState();
          let foo3 = bar ?? useState();
        }
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        function useHook({ bar }) {
          let foo1 = bar &amp;&amp; useState();
          let foo2 = bar || useState();
          let foo3 = bar ?? useState();
        }
      " time="0.004">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        const FancyButton = React.forwardRef((props, ref) =&gt; {
          if (props.fancy) {
            useCustomHook();
          }
          return &lt;button ref={ref}&gt;{props.children}&lt;/button&gt;;
        });
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        const FancyButton = React.forwardRef((props, ref) =&gt; {
          if (props.fancy) {
            useCustomHook();
          }
          return &lt;button ref={ref}&gt;{props.children}&lt;/button&gt;;
        });
      " time="0.004">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        const FancyButton = forwardRef(function(props, ref) {
          if (props.fancy) {
            useCustomHook();
          }
          return &lt;button ref={ref}&gt;{props.children}&lt;/button&gt;;
        });
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        const FancyButton = forwardRef(function(props, ref) {
          if (props.fancy) {
            useCustomHook();
          }
          return &lt;button ref={ref}&gt;{props.children}&lt;/button&gt;;
        });
      " time="0.051">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        const MemoizedButton = memo(function(props) {
          if (props.fancy) {
            useCustomHook();
          }
          return &lt;button&gt;{props.children}&lt;/button&gt;;
        });
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous and might not warn otherwise.
        // This *must* be invalid.
        const MemoizedButton = memo(function(props) {
          if (props.fancy) {
            useCustomHook();
          }
          return &lt;button&gt;{props.children}&lt;/button&gt;;
        });
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks invalid 
        // This is invalid because &quot;use&quot;-prefixed functions used in named
        // functions are assumed to be hooks.
        React.unknownFunction(function notAComponent(foo, bar) {
          useProbablyAHook(bar)
        });
      " name="react-hooks invalid 
        // This is invalid because &quot;use&quot;-prefixed functions used in named
        // functions are assumed to be hooks.
        React.unknownFunction(function notAComponent(foo, bar) {
          useProbablyAHook(bar)
        });
      " time="0.007">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Invalid because it&apos;s dangerous.
        // Normally, this would crash, but not if you use inline requires.
        // This *must* be invalid.
        // It&apos;s expected to have some false positives, but arguably
        // they are confusing anyway due to the use*() convention
        // already being associated with Hooks.
        useState();
        if (foo) {
          const foo = React.useCallback(() =&gt; {});
        }
        useCustomHook();
      " name="react-hooks invalid 
        // Invalid because it&apos;s dangerous.
        // Normally, this would crash, but not if you use inline requires.
        // This *must* be invalid.
        // It&apos;s expected to have some false positives, but arguably
        // they are confusing anyway due to the use*() convention
        // already being associated with Hooks.
        useState();
        if (foo) {
          const foo = React.useCallback(() =&gt; {});
        }
        useCustomHook();
      " time="0.015">
    </testcase>
    <testcase classname="react-hooks invalid 
        // Technically this is a false positive.
        // We *could* make it valid (and it used to be).
        //
        // However, top-level Hook-like calls can be very dangerous
        // in environments with inline requires because they can mask
        // the runtime error by accident.
        // So we prefer to disallow it despite the false positive.

        const {createHistory, useBasename} = require(&apos;history-2.1.2&apos;);
        const browserHistory = useBasename(createHistory)({
          basename: &apos;/&apos;,
        });
      " name="react-hooks invalid 
        // Technically this is a false positive.
        // We *could* make it valid (and it used to be).
        //
        // However, top-level Hook-like calls can be very dangerous
        // in environments with inline requires because they can mask
        // the runtime error by accident.
        // So we prefer to disallow it despite the false positive.

        const {createHistory, useBasename} = require(&apos;history-2.1.2&apos;);
        const browserHistory = useBasename(createHistory)({
          basename: &apos;/&apos;,
        });
      " time="0.005">
    </testcase>
    <testcase classname="react-hooks invalid 
        class ClassComponentWithFeatureFlag extends React.Component {
          render() {
            if (foo) {
              useFeatureFlag();
            }
          }
        }
      " name="react-hooks invalid 
        class ClassComponentWithFeatureFlag extends React.Component {
          render() {
            if (foo) {
              useFeatureFlag();
            }
          }
        }
      " time="0.002">
    </testcase>
    <testcase classname="react-hooks invalid 
        class ClassComponentWithHook extends React.Component {
          render() {
            React.useState();
          }
        }
      " name="react-hooks invalid 
        class ClassComponentWithHook extends React.Component {
          render() {
            React.useState();
          }
        }
      " time="0.005">
    </testcase>
    <testcase classname="react-hooks invalid 
        (class {useHook = () =&gt; { useState(); }});
      " name="react-hooks invalid 
        (class {useHook = () =&gt; { useState(); }});
      " time="0.002">
    </testcase>
    <testcase classname="react-hooks invalid 
        (class {useHook() { useState(); }});
      " name="react-hooks invalid 
        (class {useHook() { useState(); }});
      " time="0.002">
    </testcase>
    <testcase classname="react-hooks invalid 
        (class {h = () =&gt; { useState(); }});
      " name="react-hooks invalid 
        (class {h = () =&gt; { useState(); }});
      " time="0.002">
    </testcase>
    <testcase classname="react-hooks invalid 
        (class {i() { useState(); }});
      " name="react-hooks invalid 
        (class {i() { useState(); }});
      " time="0.031">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/EventPluginRegistry-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:18" time="0.39" tests="10">
    <testcase classname="EventPluginRegistry should be able to inject ordering before plugins" name="EventPluginRegistry should be able to inject ordering before plugins" time="0.002">
    </testcase>
    <testcase classname="EventPluginRegistry should be able to inject plugins before and after ordering" name="EventPluginRegistry should be able to inject plugins before and after ordering" time="0.001">
    </testcase>
    <testcase classname="EventPluginRegistry should be able to inject repeated plugins and out-of-order" name="EventPluginRegistry should be able to inject repeated plugins and out-of-order" time="0.001">
    </testcase>
    <testcase classname="EventPluginRegistry should throw if plugin does not implement `extractEvents`" name="EventPluginRegistry should throw if plugin does not implement `extractEvents`" time="0.002">
    </testcase>
    <testcase classname="EventPluginRegistry should throw if plugin does not exist in ordering" name="EventPluginRegistry should throw if plugin does not exist in ordering" time="0.014">
    </testcase>
    <testcase classname="EventPluginRegistry should throw if ordering is injected more than once" name="EventPluginRegistry should throw if ordering is injected more than once" time="0.001">
    </testcase>
    <testcase classname="EventPluginRegistry should throw if different plugins injected using same name" name="EventPluginRegistry should throw if different plugins injected using same name" time="0.002">
    </testcase>
    <testcase classname="EventPluginRegistry should publish registration names of injected plugins" name="EventPluginRegistry should publish registration names of injected plugins" time="0.001">
    </testcase>
    <testcase classname="EventPluginRegistry should throw if multiple registration names collide" name="EventPluginRegistry should throw if multiple registration names collide" time="0.002">
    </testcase>
    <testcase classname="EventPluginRegistry should throw if an invalid event is published" name="EventPluginRegistry should throw if an invalid event is published" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-server/src/__tests__/ReactServer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:18" time="0.366" tests="1">
    <testcase classname="ReactServer can call render" name="ReactServer can call render" time="0.139">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/ReactNativeMount-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:17" time="1.58" tests="24">
    <testcase classname="ReactNative should be able to create and render a native component" name="ReactNative should be able to create and render a native component" time="0.127">
    </testcase>
    <testcase classname="ReactNative should be able to create and update a native component" name="ReactNative should be able to create and update a native component" time="0.055">
    </testcase>
    <testcase classname="ReactNative should not call UIManager.updateView after render for properties that have not changed" name="ReactNative should not call UIManager.updateView after render for properties that have not changed" time="0.033">
    </testcase>
    <testcase classname="ReactNative should call dispatchCommand for native refs" name="ReactNative should call dispatchCommand for native refs" time="0.035">
    </testcase>
    <testcase classname="ReactNative should warn and no-op if calling dispatchCommand on non native refs" name="ReactNative should warn and no-op if calling dispatchCommand on non native refs" time="0.022">
    </testcase>
    <testcase classname="ReactNative should call sendAccessibilityEvent for native refs" name="ReactNative should call sendAccessibilityEvent for native refs" time="0.047">
    </testcase>
    <testcase classname="ReactNative should warn and no-op if calling sendAccessibilityEvent on non native refs" name="ReactNative should warn and no-op if calling sendAccessibilityEvent on non native refs" time="0.092">
    </testcase>
    <testcase classname="ReactNative should not call UIManager.updateView from ref.setNativeProps for properties that have not changed" name="ReactNative should not call UIManager.updateView from ref.setNativeProps for properties that have not changed" time="0.022">
    </testcase>
    <testcase classname="ReactNative should call UIManager.measure on ref.measure" name="ReactNative should call UIManager.measure on ref.measure" time="0.037">
    </testcase>
    <testcase classname="ReactNative should call UIManager.measureInWindow on ref.measureInWindow" name="ReactNative should call UIManager.measureInWindow on ref.measureInWindow" time="0.03">
    </testcase>
    <testcase classname="ReactNative should support reactTag in ref.measureLayout" name="ReactNative should support reactTag in ref.measureLayout" time="0.036">
    </testcase>
    <testcase classname="ReactNative should support ref in ref.measureLayout of host components" name="ReactNative should support ref in ref.measureLayout of host components" time="0.034">
    </testcase>
    <testcase classname="ReactNative returns the correct instance and calls it in the callback" name="ReactNative returns the correct instance and calls it in the callback" time="0.024">
    </testcase>
    <testcase classname="ReactNative renders and reorders children" name="ReactNative renders and reorders children" time="0.042">
    </testcase>
    <testcase classname="ReactNative calls setState with no arguments" name="ReactNative calls setState with no arguments" time="0.029">
    </testcase>
    <testcase classname="ReactNative should not throw when &lt;View&gt; is used inside of a &lt;Text&gt; ancestor" name="ReactNative should not throw when &lt;View&gt; is used inside of a &lt;Text&gt; ancestor" time="0.038">
    </testcase>
    <testcase classname="ReactNative should throw for text not inside of a &lt;Text&gt; ancestor" name="ReactNative should throw for text not inside of a &lt;Text&gt; ancestor" time="0.037">
    </testcase>
    <testcase classname="ReactNative should not throw for text inside of an indirect &lt;Text&gt; ancestor" name="ReactNative should not throw for text inside of an indirect &lt;Text&gt; ancestor" time="0.031">
    </testcase>
    <testcase classname="ReactNative findHostInstance_DEPRECATED should warn if used to find a host component inside StrictMode" name="ReactNative findHostInstance_DEPRECATED should warn if used to find a host component inside StrictMode" time="0.057">
    </testcase>
    <testcase classname="ReactNative findHostInstance_DEPRECATED should warn if passed a component that is inside StrictMode" name="ReactNative findHostInstance_DEPRECATED should warn if passed a component that is inside StrictMode" time="0.024">
    </testcase>
    <testcase classname="ReactNative findNodeHandle should warn if used to find a host component inside StrictMode" name="ReactNative findNodeHandle should warn if used to find a host component inside StrictMode" time="0.034">
    </testcase>
    <testcase classname="ReactNative findNodeHandle should warn if passed a component that is inside StrictMode" name="ReactNative findNodeHandle should warn if passed a component that is inside StrictMode" time="0.056">
    </testcase>
    <testcase classname="ReactNative blur on host component calls TextInputState" name="ReactNative blur on host component calls TextInputState" time="0.035">
    </testcase>
    <testcase classname="ReactNative focus on host component calls TextInputState" name="ReactNative focus on host component calls TextInputState" time="0.033">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-native-renderer/src/__tests__/ReactFabricHostComponent-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:18" time="0.857" tests="11">
    <testcase classname="blur blur() invokes TextInputState" name="blur blur() invokes TextInputState" time="0.075">
    </testcase>
    <testcase classname="focus focus() invokes TextInputState" name="focus focus() invokes TextInputState" time="0.029">
    </testcase>
    <testcase classname="measure component.measure(...) invokes callback" name="measure component.measure(...) invokes callback" time="0.07">
    </testcase>
    <testcase classname="measure unmounted.measure(...) does nothing" name="measure unmounted.measure(...) does nothing" time="0.017">
    </testcase>
    <testcase classname="measureInWindow component.measureInWindow(...) invokes callback" name="measureInWindow component.measureInWindow(...) invokes callback" time="0.046">
    </testcase>
    <testcase classname="measureInWindow unmounted.measureInWindow(...) does nothing" name="measureInWindow unmounted.measureInWindow(...) does nothing" time="0.075">
    </testcase>
    <testcase classname="measureLayout component.measureLayout(component, ...) invokes callback" name="measureLayout component.measureLayout(component, ...) invokes callback" time="0.021">
    </testcase>
    <testcase classname="measureLayout unmounted.measureLayout(component, ...) does nothing" name="measureLayout unmounted.measureLayout(component, ...) does nothing" time="0.041">
    </testcase>
    <testcase classname="measureLayout component.measureLayout(unmounted, ...) does nothing" name="measureLayout component.measureLayout(unmounted, ...) does nothing" time="0.07">
    </testcase>
    <testcase classname="measureLayout unmounted.measureLayout(unmounted, ...) does nothing" name="measureLayout unmounted.measureLayout(unmounted, ...) does nothing" time="0.033">
    </testcase>
    <testcase classname="setNativeProps setNativeProps(...) emits a warning" name="setNativeProps setNativeProps(...) emits a warning" time="0.031">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-debug-tools/src/__tests__/ReactHooksInspection-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:19" time="0.852" tests="8">
    <testcase classname="ReactHooksInspection should inspect a simple useState hook" name="ReactHooksInspection should inspect a simple useState hook" time="0.308">
    </testcase>
    <testcase classname="ReactHooksInspection should inspect a simple custom hook" name="ReactHooksInspection should inspect a simple custom hook" time="0.023">
    </testcase>
    <testcase classname="ReactHooksInspection should inspect a tree of multiple hooks" name="ReactHooksInspection should inspect a tree of multiple hooks" time="0.038">
    </testcase>
    <testcase classname="ReactHooksInspection should inspect a tree of multiple levels of hooks" name="ReactHooksInspection should inspect a tree of multiple levels of hooks" time="0.023">
    </testcase>
    <testcase classname="ReactHooksInspection should inspect the default value using the useContext hook" name="ReactHooksInspection should inspect the default value using the useContext hook" time="0.037">
    </testcase>
    <testcase classname="ReactHooksInspection should support an injected dispatcher" name="ReactHooksInspection should support an injected dispatcher" time="0.023">
    </testcase>
    <testcase classname="ReactHooksInspection useDebugValue should be ignored when called outside of a custom hook" name="ReactHooksInspection useDebugValue should be ignored when called outside of a custom hook" time="0.008">
    </testcase>
    <testcase classname="ReactHooksInspection useDebugValue should support an optional formatter function param" name="ReactHooksInspection useDebugValue should support an optional formatter function param" time="0.018">
    </testcase>
  </testsuite>
  <testsuite name="packages/shared/__tests__/ReactError-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:19" time="0.5" tests="2">
    <testcase classname="ReactError [GATED, SHOULD FAIL] should error with minified error code" name="ReactError [GATED, SHOULD FAIL] should error with minified error code" time="0.133">
    </testcase>
    <testcase classname="ReactError should serialize arguments" name="ReactError should serialize arguments" time="0.064">
    </testcase>
  </testsuite>
  <testsuite name="packages/shared/__tests__/ReactErrorUtils-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:19" time="0.44" tests="9">
    <testcase classname="ReactErrorUtils it should rethrow caught errors" name="ReactErrorUtils it should rethrow caught errors" time="0.004">
    </testcase>
    <testcase classname="ReactErrorUtils should call the callback the passed arguments" name="ReactErrorUtils should call the callback the passed arguments" time="0.001">
    </testcase>
    <testcase classname="ReactErrorUtils should call the callback with the provided context" name="ReactErrorUtils should call the callback with the provided context" time="0.001">
    </testcase>
    <testcase classname="ReactErrorUtils should catch errors" name="ReactErrorUtils should catch errors" time="0.002">
    </testcase>
    <testcase classname="ReactErrorUtils should return false from clearCaughtError if no error was thrown" name="ReactErrorUtils should return false from clearCaughtError if no error was thrown" time="0.001">
    </testcase>
    <testcase classname="ReactErrorUtils can nest with same debug name" name="ReactErrorUtils can nest with same debug name" time="0.015">
    </testcase>
    <testcase classname="ReactErrorUtils handles nested errors" name="ReactErrorUtils handles nested errors" time="0.001">
    </testcase>
    <testcase classname="ReactErrorUtils handles nested errors in separate renderers" name="ReactErrorUtils handles nested errors in separate renderers" time="0.003">
    </testcase>
    <testcase classname="ReactErrorUtils can be shimmed" name="ReactErrorUtils can be shimmed" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-debug-tools/src/__tests__/ReactDevToolsHooksIntegration-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:18" time="1.629" tests="5">
    <testcase classname="React hooks DevTools integration should support editing useState hooks" name="React hooks DevTools integration should support editing useState hooks" time="0.962">
    </testcase>
    <testcase classname="React hooks DevTools integration should support editable useReducer hooks" name="React hooks DevTools integration should support editable useReducer hooks" time="0.081">
    </testcase>
    <testcase classname="React hooks DevTools integration should handle interleaved stateful hooks (e.g. useState) and non-stateful hooks (e.g. useContext)" name="React hooks DevTools integration should handle interleaved stateful hooks (e.g. useState) and non-stateful hooks (e.g. useContext)" time="0.053">
    </testcase>
    <testcase classname="React hooks DevTools integration should support overriding suspense in legacy mode" name="React hooks DevTools integration should support overriding suspense in legacy mode" time="0.048">
    </testcase>
    <testcase classname="React hooks DevTools integration should support overriding suspense in concurrent mode" name="React hooks DevTools integration should support overriding suspense in concurrent mode" time="0.066">
    </testcase>
  </testsuite>
  <testsuite name="packages/shared/__tests__/describeComponentFrame-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:20" time="0.401" tests="1">
    <testcase classname="Component stack trace displaying [GATED, SHOULD FAIL] should provide filenames in stack traces" name="Component stack trace displaying [GATED, SHOULD FAIL] should provide filenames in stack traces" time="0.135">
    </testcase>
  </testsuite>
  <testsuite name="packages/shared/__tests__/ReactErrorProd-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:20" time="0.25" tests="1">
    <testcase classname="ReactErrorProd should throw with the correct number of `%s`s in the URL" name="ReactErrorProd should throw with the correct number of `%s`s in the URL" time="0.01">
    </testcase>
  </testsuite>
  <testsuite name="packages/shared/__tests__/ReactDOMFrameScheduling-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:20" time="0.376" tests="1">
    <testcase classname="ReactDOMFrameScheduling can import findDOMNode in Node environment" name="ReactDOMFrameScheduling can import findDOMNode in Node environment" time="0.124">
    </testcase>
  </testsuite>
  <testsuite name="packages/shared/__tests__/ReactSymbols-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:21" time="0.317" tests="2">
    <testcase classname="ReactSymbols Symbol values should be unique" name="ReactSymbols Symbol values should be unique" time="0.001">
    </testcase>
    <testcase classname="ReactSymbols numeric values should be unique" name="ReactSymbols numeric values should be unique" time="0.021">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-fetch/src/__tests__/ReactFetchNode-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:21" time="0.736" tests="5">
    <testcase classname="ReactFetchNode can fetch text from a server component" name="ReactFetchNode can fetch text from a server component" time="0.183">
    </testcase>
    <testcase classname="ReactFetchNode can fetch json from a server component" name="ReactFetchNode can fetch json from a server component" time="0.009">
    </testcase>
    <testcase classname="ReactFetchNode provides response status" name="ReactFetchNode provides response status" time="0.198">
    </testcase>
    <testcase classname="ReactFetchNode handles different paths" name="ReactFetchNode handles different paths" time="0.011">
    </testcase>
    <testcase classname="ReactFetchNode can produce an error" name="ReactFetchNode can produce an error" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-fetch/src/__tests__/ReactFetchBrowser-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:21" time="0.421" tests="1">
    <testcase classname="ReactFetchBrowser exports something" name="ReactFetchBrowser exports something" time="0.009">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-debug-tools/src/__tests__/ReactHooksInspectionIntegration-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:18" time="3.178" tests="20">
    <testcase classname="ReactHooksInspectionIntegration should inspect the current state of useState hooks" name="ReactHooksInspectionIntegration should inspect the current state of useState hooks" time="0.502">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should inspect the current state of all stateful hooks" name="ReactHooksInspectionIntegration should inspect the current state of all stateful hooks" time="0.135">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should inspect the current state of all stateful hooks, including useInsertionEffect" name="ReactHooksInspectionIntegration should inspect the current state of all stateful hooks, including useInsertionEffect" time="0.159">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should inspect the value of the current provider in useContext" name="ReactHooksInspectionIntegration should inspect the value of the current provider in useContext" time="0.059">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should inspect forwardRef" name="ReactHooksInspectionIntegration should inspect forwardRef" time="0.039">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should inspect memo" name="ReactHooksInspectionIntegration should inspect memo" time="0.095">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should inspect custom hooks" name="ReactHooksInspectionIntegration should inspect custom hooks" time="0.047">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should support composite useTransition hook" name="ReactHooksInspectionIntegration should support composite useTransition hook" time="0.063">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should support composite useDeferredValue hook" name="ReactHooksInspectionIntegration should support composite useDeferredValue hook" time="0.041">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should support useId hook" name="ReactHooksInspectionIntegration should support useId hook" time="0.041">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration useDebugValue should support inspectable values for multiple custom hooks" name="ReactHooksInspectionIntegration useDebugValue should support inspectable values for multiple custom hooks" time="0.061">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration useDebugValue should support inspectable values for nested custom hooks" name="ReactHooksInspectionIntegration useDebugValue should support inspectable values for nested custom hooks" time="0.029">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration useDebugValue should support multiple inspectable values per custom hooks" name="ReactHooksInspectionIntegration useDebugValue should support multiple inspectable values per custom hooks" time="0.059">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration useDebugValue should ignore useDebugValue() made outside of a custom hook" name="ReactHooksInspectionIntegration useDebugValue should ignore useDebugValue() made outside of a custom hook" time="0.034">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration useDebugValue should support an optional formatter function param" name="ReactHooksInspectionIntegration useDebugValue should support an optional formatter function param" time="0.213">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should support defaultProps and lazy" name="ReactHooksInspectionIntegration should support defaultProps and lazy" time="0.053">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should support an injected dispatcher" name="ReactHooksInspectionIntegration should support an injected dispatcher" time="0.021">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should properly advance the current hook for useContext" name="ReactHooksInspectionIntegration should properly advance the current hook for useContext" time="0.056">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should support composite useMutableSource hook" name="ReactHooksInspectionIntegration should support composite useMutableSource hook" time="0.05">
    </testcase>
    <testcase classname="ReactHooksInspectionIntegration should support composite useSyncExternalStore hook" name="ReactHooksInspectionIntegration should support composite useSyncExternalStore hook" time="0.046">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-test-renderer/src/__tests__/ReactTestRendererTraversal-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:22" time="0.969" tests="6">
    <testcase classname="ReactTestRendererTraversal initializes" name="ReactTestRendererTraversal initializes" time="0.069">
    </testcase>
    <testcase classname="ReactTestRendererTraversal searches via .find() / .findAll()" name="ReactTestRendererTraversal searches via .find() / .findAll()" time="0.058">
    </testcase>
    <testcase classname="ReactTestRendererTraversal searches via .findByType() / .findAllByType()" name="ReactTestRendererTraversal searches via .findByType() / .findAllByType()" time="0.054">
    </testcase>
    <testcase classname="ReactTestRendererTraversal searches via .findByProps() / .findAllByProps()" name="ReactTestRendererTraversal searches via .findByProps() / .findAllByProps()" time="0.075">
    </testcase>
    <testcase classname="ReactTestRendererTraversal skips special nodes" name="ReactTestRendererTraversal skips special nodes" time="0.026">
    </testcase>
    <testcase classname="ReactTestRendererTraversal can have special nodes as roots" name="ReactTestRendererTraversal can have special nodes as roots" time="0.038">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-refresh/src/__tests__/ReactFreshMultipleRenderer-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:22" time="1.185" tests="1">
    <testcase classname="ReactFresh can update components managed by different renderers independently" name="ReactFresh can update components managed by different renderers independently" time="0.099">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-refresh/src/__tests__/ReactFreshBabelPlugin-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:22" time="2.083" tests="26">
    <testcase classname="ReactFreshBabelPlugin registers top-level function declarations" name="ReactFreshBabelPlugin registers top-level function declarations" time="0.682">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin registers top-level exported function declarations" name="ReactFreshBabelPlugin registers top-level exported function declarations" time="0.042">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin registers top-level exported named arrow functions" name="ReactFreshBabelPlugin registers top-level exported named arrow functions" time="0.025">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin uses original function declaration if it get reassigned" name="ReactFreshBabelPlugin uses original function declaration if it get reassigned" time="0.009">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin only registers pascal case functions" name="ReactFreshBabelPlugin only registers pascal case functions" time="0.003">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin registers top-level variable declarations with function expressions" name="ReactFreshBabelPlugin registers top-level variable declarations with function expressions" time="0.007">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin registers top-level variable declarations with arrow functions" name="ReactFreshBabelPlugin registers top-level variable declarations with arrow functions" time="0.008">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin ignores HOC definitions" name="ReactFreshBabelPlugin ignores HOC definitions" time="0.01">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin ignores complex definitions" name="ReactFreshBabelPlugin ignores complex definitions" time="0.006">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin ignores unnamed function declarations" name="ReactFreshBabelPlugin ignores unnamed function declarations" time="0.041">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin registers likely HOCs with inline functions" name="ReactFreshBabelPlugin registers likely HOCs with inline functions" time="0.027">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin ignores higher-order functions that are not HOCs" name="ReactFreshBabelPlugin ignores higher-order functions that are not HOCs" time="0.014">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin registers identifiers used in JSX at definition site" name="ReactFreshBabelPlugin registers identifiers used in JSX at definition site" time="0.056">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin registers identifiers used in React.createElement at definition site" name="ReactFreshBabelPlugin registers identifiers used in React.createElement at definition site" time="0.025">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin registers capitalized identifiers in HOC calls" name="ReactFreshBabelPlugin registers capitalized identifiers in HOC calls" time="0.006">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin generates signatures for function declarations calling hooks" name="ReactFreshBabelPlugin generates signatures for function declarations calling hooks" time="0.175">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin generates signatures for function expressions calling hooks" name="ReactFreshBabelPlugin generates signatures for function expressions calling hooks" time="0.052">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin includes custom hooks into the signatures" name="ReactFreshBabelPlugin includes custom hooks into the signatures" time="0.039">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin includes custom hooks into the signatures when commonjs target is used" name="ReactFreshBabelPlugin includes custom hooks into the signatures when commonjs target is used" time="0.135">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin generates valid signature for exotic ways to call Hooks" name="ReactFreshBabelPlugin generates valid signature for exotic ways to call Hooks" time="0.018">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin does not consider require-like methods to be HOCs" name="ReactFreshBabelPlugin does not consider require-like methods to be HOCs" time="0.005">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin can handle implicit arrow returns" name="ReactFreshBabelPlugin can handle implicit arrow returns" time="0.023">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin uses custom identifiers for $RefreshReg$ and $RefreshSig$" name="ReactFreshBabelPlugin uses custom identifiers for $RefreshReg$ and $RefreshSig$" time="0.004">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin respects Babel&apos;s envName option" name="ReactFreshBabelPlugin respects Babel&apos;s envName option" time="0.003">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin does not get tripped by IIFEs" name="ReactFreshBabelPlugin does not get tripped by IIFEs" time="0.024">
    </testcase>
    <testcase classname="ReactFreshBabelPlugin supports typescript namespace syntax" name="ReactFreshBabelPlugin supports typescript namespace syntax" time="0.027">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-art/src/__tests__/ReactART-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:22" time="1.914" tests="23">
    <testcase classname="ReactART should have the correct lifecycle state" name="ReactART should have the correct lifecycle state" time="0.051">
    </testcase>
    <testcase classname="ReactART should render a reasonable SVG structure in SVG mode" name="ReactART should render a reasonable SVG structure in SVG mode" time="0.046">
    </testcase>
    <testcase classname="ReactART should be able to reorder components" name="ReactART should be able to reorder components" time="0.09">
    </testcase>
    <testcase classname="ReactART should be able to reorder many components" name="ReactART should be able to reorder many components" time="0.059">
    </testcase>
    <testcase classname="ReactART renders composite with lifecycle inside group" name="ReactART renders composite with lifecycle inside group" time="0.026">
    </testcase>
    <testcase classname="ReactART resolves refs before componentDidMount" name="ReactART resolves refs before componentDidMount" time="0.016">
    </testcase>
    <testcase classname="ReactART resolves refs before componentDidUpdate" name="ReactART resolves refs before componentDidUpdate" time="0.019">
    </testcase>
    <testcase classname="ReactART adds and updates event handlers" name="ReactART adds and updates event handlers" time="0.03">
    </testcase>
    <testcase classname="ReactART [GATED, SHOULD FAIL] can concurrently render with a &quot;primary&quot; renderer while sharing context" name="ReactART [GATED, SHOULD FAIL] can concurrently render with a &quot;primary&quot; renderer while sharing context" time="0.038">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with props for drawing the Circle" name="ReactARTComponents should generate a &lt;Shape&gt; with props for drawing the Circle" time="0.017">
    </testcase>
    <testcase classname="ReactARTComponents should warn if radius is missing on a Circle component" name="ReactARTComponents should warn if radius is missing on a Circle component" time="0.015">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with props for drawing the Rectangle" name="ReactARTComponents should generate a &lt;Shape&gt; with props for drawing the Rectangle" time="0.004">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with positive width when width prop is negative" name="ReactARTComponents should generate a &lt;Shape&gt; with positive width when width prop is negative" time="0.002">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with positive height when height prop is negative" name="ReactARTComponents should generate a &lt;Shape&gt; with positive height when height prop is negative" time="0.002">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with a radius property of 0 when top left radius prop is negative" name="ReactARTComponents should generate a &lt;Shape&gt; with a radius property of 0 when top left radius prop is negative" time="0.012">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with a radius property of 0 when top right radius prop is negative" name="ReactARTComponents should generate a &lt;Shape&gt; with a radius property of 0 when top right radius prop is negative" time="0.04">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with a radius property of 0 when bottom right radius prop is negative" name="ReactARTComponents should generate a &lt;Shape&gt; with a radius property of 0 when bottom right radius prop is negative" time="0.001">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with a radius property of 0 when bottom left radius prop is negative" name="ReactARTComponents should generate a &lt;Shape&gt; with a radius property of 0 when bottom left radius prop is negative" time="0.002">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; where top radius is 0 if the sum of the top radius is greater than width" name="ReactARTComponents should generate a &lt;Shape&gt; where top radius is 0 if the sum of the top radius is greater than width" time="0.001">
    </testcase>
    <testcase classname="ReactARTComponents should warn if width/height is missing on a Rectangle component" name="ReactARTComponents should warn if width/height is missing on a Rectangle component" time="0.01">
    </testcase>
    <testcase classname="ReactARTComponents should generate a &lt;Shape&gt; with props for drawing the Wedge" name="ReactARTComponents should generate a &lt;Shape&gt; with props for drawing the Wedge" time="0.001">
    </testcase>
    <testcase classname="ReactARTComponents should return null if startAngle equals to endAngle on Wedge" name="ReactARTComponents should return null if startAngle equals to endAngle on Wedge" time="0.001">
    </testcase>
    <testcase classname="ReactARTComponents should warn if outerRadius/startAngle/endAngle is missing on a Wedge component" name="ReactARTComponents should warn if outerRadius/startAngle/endAngle is missing on a Wedge component" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-test-renderer/src/__tests__/ReactTestRenderer-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:24" time="1.056" tests="32">
    <testcase classname="ReactTestRenderer renders a simple component" name="ReactTestRenderer renders a simple component" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer renders a top-level empty component" name="ReactTestRenderer renders a top-level empty component" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer exposes a type flag" name="ReactTestRenderer exposes a type flag" time="0.034">
    </testcase>
    <testcase classname="ReactTestRenderer can render a composite component" name="ReactTestRenderer can render a composite component" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer renders some basics with an update" name="ReactTestRenderer renders some basics with an update" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer exposes the instance" name="ReactTestRenderer exposes the instance" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer updates types" name="ReactTestRenderer updates types" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer updates children" name="ReactTestRenderer updates children" time="0.013">
    </testcase>
    <testcase classname="ReactTestRenderer does the full lifecycle" name="ReactTestRenderer does the full lifecycle" time="0.004">
    </testcase>
    <testcase classname="ReactTestRenderer gives a ref to native components" name="ReactTestRenderer gives a ref to native components" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer warns correctly for refs on SFCs" name="ReactTestRenderer warns correctly for refs on SFCs" time="0.024">
    </testcase>
    <testcase classname="ReactTestRenderer allows an optional createNodeMock function" name="ReactTestRenderer allows an optional createNodeMock function" time="0.003">
    </testcase>
    <testcase classname="ReactTestRenderer supports unmounting when using refs" name="ReactTestRenderer supports unmounting when using refs" time="0.009">
    </testcase>
    <testcase classname="ReactTestRenderer supports unmounting inner instances" name="ReactTestRenderer supports unmounting inner instances" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer supports updates when using refs" name="ReactTestRenderer supports updates when using refs" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer supports error boundaries" name="ReactTestRenderer supports error boundaries" time="0.005">
    </testcase>
    <testcase classname="ReactTestRenderer can update text nodes" name="ReactTestRenderer can update text nodes" time="0.008">
    </testcase>
    <testcase classname="ReactTestRenderer toTree() renders simple components returning host components" name="ReactTestRenderer toTree() renders simple components returning host components" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer toTree() handles nested Fragments" name="ReactTestRenderer toTree() handles nested Fragments" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer toTree() handles null rendering components" name="ReactTestRenderer toTree() handles null rendering components" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer toTree() handles simple components that return arrays" name="ReactTestRenderer toTree() handles simple components that return arrays" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer toTree() handles complicated tree of arrays" name="ReactTestRenderer toTree() handles complicated tree of arrays" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer toTree() handles complicated tree of fragments" name="ReactTestRenderer toTree() handles complicated tree of fragments" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer root instance and createNodeMock ref return the same value" name="ReactTestRenderer root instance and createNodeMock ref return the same value" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer toTree() renders complicated trees of composites and hosts" name="ReactTestRenderer toTree() renders complicated trees of composites and hosts" time="0.014">
    </testcase>
    <testcase classname="ReactTestRenderer can update text nodes when rendered as root" name="ReactTestRenderer can update text nodes when rendered as root" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer can render and update root fragments" name="ReactTestRenderer can render and update root fragments" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer supports context providers and consumers" name="ReactTestRenderer supports context providers and consumers" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer supports modes" name="ReactTestRenderer supports modes" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer supports forwardRef" name="ReactTestRenderer supports forwardRef" time="0.001">
    </testcase>
    <testcase classname="ReactTestRenderer can concurrently render context with a &quot;primary&quot; renderer" name="ReactTestRenderer can concurrently render context with a &quot;primary&quot; renderer" time="0.002">
    </testcase>
    <testcase classname="ReactTestRenderer calling findByType() with an invalid component will fall back to &quot;Unknown&quot; for component name" name="ReactTestRenderer calling findByType() with an invalid component will fall back to &quot;Unknown&quot; for component name" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-test-renderer/src/__tests__/ReactShallowRendererHooks-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:24" time="0.585" tests="14">
    <testcase classname="ReactShallowRenderer with hooks should work with useState" name="ReactShallowRenderer with hooks should work with useState" time="0.003">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should work with updating a value from useState" name="ReactShallowRenderer with hooks should work with updating a value from useState" time="0.012">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should work with updating a derived value from useState" name="ReactShallowRenderer with hooks should work with updating a derived value from useState" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should work with useReducer" name="ReactShallowRenderer with hooks should work with useReducer" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should work with a dispatched state change for a useReducer" name="ReactShallowRenderer with hooks should work with a dispatched state change for a useReducer" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should not trigger effects" name="ReactShallowRenderer with hooks should not trigger effects" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should work with useRef" name="ReactShallowRenderer with hooks should work with useRef" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should work with useMemo" name="ReactShallowRenderer with hooks should work with useMemo" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should work with useContext" name="ReactShallowRenderer with hooks should work with useContext" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should not leak state when component type changes" name="ReactShallowRenderer with hooks should not leak state when component type changes" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should work with with forwardRef + any hook" name="ReactShallowRenderer with hooks should work with with forwardRef + any hook" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should update a value from useState outside the render" name="ReactShallowRenderer with hooks should update a value from useState outside the render" time="0.014">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should ignore a foreign update outside the render" name="ReactShallowRenderer with hooks should ignore a foreign update outside the render" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRenderer with hooks should not forget render phase updates" name="ReactShallowRenderer with hooks should not forget render phase updates" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-test-renderer/src/__tests__/ReactShallowRendererMemo-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:24" time="1.103" tests="54">
    <testcase classname="ReactShallowRendererMemo should call all of the legacy lifecycle hooks" name="ReactShallowRendererMemo should call all of the legacy lifecycle hooks" time="0.003">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should call all of the new lifecycle hooks" name="ReactShallowRendererMemo should call all of the new lifecycle hooks" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" name="ReactShallowRendererMemo should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" name="ReactShallowRendererMemo should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" time="0.005">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should not call getSnapshotBeforeUpdate or componentDidUpdate when updating since refs wont exist" name="ReactShallowRendererMemo should not call getSnapshotBeforeUpdate or componentDidUpdate when updating since refs wont exist" time="0.009">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should only render 1 level deep" name="ReactShallowRendererMemo should only render 1 level deep" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should have shallow rendering" name="ReactShallowRendererMemo should have shallow rendering" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should handle Profiler" name="ReactShallowRendererMemo should handle Profiler" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should enable shouldComponentUpdate to prevent a re-render" name="ReactShallowRendererMemo should enable shouldComponentUpdate to prevent a re-render" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should enable PureComponent to prevent a re-render" name="ReactShallowRendererMemo should enable PureComponent to prevent a re-render" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should not run shouldComponentUpdate during forced update" name="ReactShallowRendererMemo should not run shouldComponentUpdate during forced update" time="0.028">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should rerender when calling forceUpdate" name="ReactShallowRendererMemo should rerender when calling forceUpdate" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should shallow render a function component" name="ReactShallowRendererMemo should shallow render a function component" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should shallow render a component returning strings directly from render" name="ReactShallowRendererMemo should shallow render a component returning strings directly from render" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should shallow render a component returning numbers directly from render" name="ReactShallowRendererMemo should shallow render a component returning numbers directly from render" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should shallow render a fragment" name="ReactShallowRendererMemo should shallow render a fragment" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should shallow render a React.fragment" name="ReactShallowRendererMemo should shallow render a React.fragment" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should throw for invalid elements" name="ReactShallowRendererMemo should throw for invalid elements" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should have shallow unmounting" name="ReactShallowRendererMemo should have shallow unmounting" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can shallow render to null" name="ReactShallowRendererMemo can shallow render to null" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can shallow render with a ref" name="ReactShallowRendererMemo can shallow render with a ref" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo lets you update shallowly rendered components" name="ReactShallowRendererMemo lets you update shallowly rendered components" time="0.015">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can access the mounted component instance" name="ReactShallowRendererMemo can access the mounted component instance" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can shallowly render components with contextTypes" name="ReactShallowRendererMemo can shallowly render components with contextTypes" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo passes expected params to legacy component lifecycle methods" name="ReactShallowRendererMemo passes expected params to legacy component lifecycle methods" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo passes expected params to new component lifecycle methods" name="ReactShallowRendererMemo passes expected params to new component lifecycle methods" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can shallowly render components with ref as function" name="ReactShallowRendererMemo can shallowly render components with ref as function" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can initialize state via static getDerivedStateFromProps" name="ReactShallowRendererMemo can initialize state via static getDerivedStateFromProps" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can setState in componentWillMount when shallow rendering" name="ReactShallowRendererMemo can setState in componentWillMount when shallow rendering" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can setState in componentWillMount repeatedly when shallow rendering" name="ReactShallowRendererMemo can setState in componentWillMount repeatedly when shallow rendering" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can setState in componentWillMount with an updater function repeatedly when shallow rendering" name="ReactShallowRendererMemo can setState in componentWillMount with an updater function repeatedly when shallow rendering" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can setState in componentWillReceiveProps when shallow rendering" name="ReactShallowRendererMemo can setState in componentWillReceiveProps when shallow rendering" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can update state with static getDerivedStateFromProps when shallow rendering" name="ReactShallowRendererMemo can update state with static getDerivedStateFromProps when shallow rendering" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should not override state with stale values if prevState is spread within getDerivedStateFromProps" name="ReactShallowRendererMemo should not override state with stale values if prevState is spread within getDerivedStateFromProps" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should pass previous state to shouldComponentUpdate even with getDerivedStateFromProps" name="ReactShallowRendererMemo should pass previous state to shouldComponentUpdate even with getDerivedStateFromProps" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can setState with an updater function" name="ReactShallowRendererMemo can setState with an updater function" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can access component instance from setState updater function" name="ReactShallowRendererMemo can access component instance from setState updater function" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can setState with a callback" name="ReactShallowRendererMemo can setState with a callback" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can replaceState with a callback" name="ReactShallowRendererMemo can replaceState with a callback" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can forceUpdate with a callback" name="ReactShallowRendererMemo can forceUpdate with a callback" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can pass context when shallowly rendering" name="ReactShallowRendererMemo can pass context when shallowly rendering" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should track context across updates" name="ReactShallowRendererMemo should track context across updates" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should filter context by contextTypes" name="ReactShallowRendererMemo should filter context by contextTypes" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo can fail context when shallowly rendering" name="ReactShallowRendererMemo can fail context when shallowly rendering" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should warn about propTypes (but only once)" name="ReactShallowRendererMemo should warn about propTypes (but only once)" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should enable rendering of cloned element" name="ReactShallowRendererMemo should enable rendering of cloned element" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo this.state should be updated on setState callback inside componentWillMount" name="ReactShallowRendererMemo this.state should be updated on setState callback inside componentWillMount" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should handle multiple callbacks" name="ReactShallowRendererMemo should handle multiple callbacks" time="0.011">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should call the setState callback even if shouldComponentUpdate = false" name="ReactShallowRendererMemo should call the setState callback even if shouldComponentUpdate = false" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo throws usefully when rendering badly-typed elements" name="ReactShallowRendererMemo throws usefully when rendering badly-typed elements" time="0.003">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should have initial state of null if not defined" name="ReactShallowRendererMemo should have initial state of null if not defined" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should invoke both deprecated and new lifecycles if both are present" name="ReactShallowRendererMemo should invoke both deprecated and new lifecycles if both are present" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should stop the update when setState returns null or undefined" name="ReactShallowRendererMemo should stop the update when setState returns null or undefined" time="0">
    </testcase>
    <testcase classname="ReactShallowRendererMemo should not get this in a function component" name="ReactShallowRendererMemo should not get this in a function component" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-test-renderer/src/__tests__/ReactTestRendererAct-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:25" time="0.705" tests="3">
    <testcase classname="ReactTestRenderer.act() can use .act() to flush effects" name="ReactTestRenderer.act() can use .act() to flush effects" time="0.065">
    </testcase>
    <testcase classname="ReactTestRenderer.act() async should work with async/await" name="ReactTestRenderer.act() async should work with async/await" time="0.035">
    </testcase>
    <testcase classname="ReactTestRenderer.act() async should not flush effects without also flushing microtasks" name="ReactTestRenderer.act() async should not flush effects without also flushing microtasks" time="0.086">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-test-renderer/src/__tests__/ReactTestRendererAsync-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:25" time="0.867" tests="9">
    <testcase classname="ReactTestRendererAsync flushAll flushes all work" name="ReactTestRendererAsync flushAll flushes all work" time="0.105">
    </testcase>
    <testcase classname="ReactTestRendererAsync flushAll returns array of yielded values" name="ReactTestRendererAsync flushAll returns array of yielded values" time="0.018">
    </testcase>
    <testcase classname="ReactTestRendererAsync flushThrough flushes until the expected values is yielded" name="ReactTestRendererAsync flushThrough flushes until the expected values is yielded" time="0.055">
    </testcase>
    <testcase classname="ReactTestRendererAsync supports high priority interruptions" name="ReactTestRendererAsync supports high priority interruptions" time="0.032">
    </testcase>
    <testcase classname="ReactTestRendererAsync Jest matchers toFlushAndYieldThrough" name="ReactTestRendererAsync Jest matchers toFlushAndYieldThrough" time="0.034">
    </testcase>
    <testcase classname="ReactTestRendererAsync Jest matchers toFlushAndYield" name="ReactTestRendererAsync Jest matchers toFlushAndYield" time="0.039">
    </testcase>
    <testcase classname="ReactTestRendererAsync Jest matchers toFlushAndThrow" name="ReactTestRendererAsync Jest matchers toFlushAndThrow" time="0.063">
    </testcase>
    <testcase classname="ReactTestRendererAsync toHaveYielded" name="ReactTestRendererAsync toHaveYielded" time="0.042">
    </testcase>
    <testcase classname="ReactTestRendererAsync flush methods throw if log is not empty" name="ReactTestRendererAsync flush methods throw if log is not empty" time="0.021">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-test-renderer/src/__tests__/ReactTestRenderer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:25" time="0.824" tests="3">
    <testcase classname="ReactTestRenderer should warn if used to render a ReactDOM portal" name="ReactTestRenderer should warn if used to render a ReactDOM portal" time="0.264">
    </testcase>
    <testcase classname="ReactTestRenderer timed out Suspense hidden subtrees should not be observable via toJSON for root Suspense components" name="ReactTestRenderer timed out Suspense hidden subtrees should not be observable via toJSON for root Suspense components" time="0.099">
    </testcase>
    <testcase classname="ReactTestRenderer timed out Suspense hidden subtrees should not be observable via toJSON for nested Suspense components" name="ReactTestRenderer timed out Suspense hidden subtrees should not be observable via toJSON for nested Suspense components" time="0.122">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-test-renderer/src/__tests__/ReactShallowRenderer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:25" time="1.169" tests="63">
    <testcase classname="ReactShallowRenderer should call all of the legacy lifecycle hooks" name="ReactShallowRenderer should call all of the legacy lifecycle hooks" time="0.01">
    </testcase>
    <testcase classname="ReactShallowRenderer should call all of the new lifecycle hooks" name="ReactShallowRenderer should call all of the new lifecycle hooks" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" name="ReactShallowRenderer should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" name="ReactShallowRenderer should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should not call getSnapshotBeforeUpdate or componentDidUpdate when updating since refs wont exist" name="ReactShallowRenderer should not call getSnapshotBeforeUpdate or componentDidUpdate when updating since refs wont exist" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should only render 1 level deep" name="ReactShallowRenderer should only render 1 level deep" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should have shallow rendering" name="ReactShallowRenderer should have shallow rendering" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should handle ForwardRef" name="ReactShallowRenderer should handle ForwardRef" time="0.007">
    </testcase>
    <testcase classname="ReactShallowRenderer should handle Profiler" name="ReactShallowRenderer should handle Profiler" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should enable shouldComponentUpdate to prevent a re-render" name="ReactShallowRenderer should enable shouldComponentUpdate to prevent a re-render" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should enable PureComponent to prevent a re-render" name="ReactShallowRenderer should enable PureComponent to prevent a re-render" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should not run shouldComponentUpdate during forced update" name="ReactShallowRenderer should not run shouldComponentUpdate during forced update" time="0.017">
    </testcase>
    <testcase classname="ReactShallowRenderer should rerender when calling forceUpdate" name="ReactShallowRenderer should rerender when calling forceUpdate" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should shallow render a function component" name="ReactShallowRenderer should shallow render a function component" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should shallow render a component returning strings directly from render" name="ReactShallowRenderer should shallow render a component returning strings directly from render" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should shallow render a component returning numbers directly from render" name="ReactShallowRenderer should shallow render a component returning numbers directly from render" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should shallow render a fragment" name="ReactShallowRenderer should shallow render a fragment" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should shallow render a React.fragment" name="ReactShallowRenderer should shallow render a React.fragment" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should throw for invalid elements" name="ReactShallowRenderer should throw for invalid elements" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should have shallow unmounting" name="ReactShallowRenderer should have shallow unmounting" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer can shallow render to null" name="ReactShallowRenderer can shallow render to null" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can shallow render with a ref" name="ReactShallowRenderer can shallow render with a ref" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer lets you update shallowly rendered components" name="ReactShallowRenderer lets you update shallowly rendered components" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can access the mounted component instance" name="ReactShallowRenderer can access the mounted component instance" time="0.012">
    </testcase>
    <testcase classname="ReactShallowRenderer can shallowly render components with contextTypes" name="ReactShallowRenderer can shallowly render components with contextTypes" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer passes expected params to legacy component lifecycle methods" name="ReactShallowRenderer passes expected params to legacy component lifecycle methods" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRenderer passes expected params to new component lifecycle methods" name="ReactShallowRenderer passes expected params to new component lifecycle methods" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can shallowly render components with ref as function" name="ReactShallowRenderer can shallowly render components with ref as function" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can initialize state via static getDerivedStateFromProps" name="ReactShallowRenderer can initialize state via static getDerivedStateFromProps" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can setState in componentWillMount when shallow rendering" name="ReactShallowRenderer can setState in componentWillMount when shallow rendering" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer can setState in componentWillMount repeatedly when shallow rendering" name="ReactShallowRenderer can setState in componentWillMount repeatedly when shallow rendering" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can setState in componentWillMount with an updater function repeatedly when shallow rendering" name="ReactShallowRenderer can setState in componentWillMount with an updater function repeatedly when shallow rendering" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer can setState in componentWillReceiveProps when shallow rendering" name="ReactShallowRenderer can setState in componentWillReceiveProps when shallow rendering" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can update state with static getDerivedStateFromProps when shallow rendering" name="ReactShallowRenderer can update state with static getDerivedStateFromProps when shallow rendering" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should not override state with stale values if prevState is spread within getDerivedStateFromProps" name="ReactShallowRenderer should not override state with stale values if prevState is spread within getDerivedStateFromProps" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should pass previous state to shouldComponentUpdate even with getDerivedStateFromProps" name="ReactShallowRenderer should pass previous state to shouldComponentUpdate even with getDerivedStateFromProps" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can setState with an updater function" name="ReactShallowRenderer can setState with an updater function" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can access component instance from setState updater function" name="ReactShallowRenderer can access component instance from setState updater function" time="0.017">
    </testcase>
    <testcase classname="ReactShallowRenderer can setState with a callback" name="ReactShallowRenderer can setState with a callback" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer can replaceState with a callback" name="ReactShallowRenderer can replaceState with a callback" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer can forceUpdate with a callback" name="ReactShallowRenderer can forceUpdate with a callback" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can pass context when shallowly rendering" name="ReactShallowRenderer can pass context when shallowly rendering" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should track context across updates" name="ReactShallowRenderer should track context across updates" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should filter context by contextTypes" name="ReactShallowRenderer should filter context by contextTypes" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer can fail context when shallowly rendering" name="ReactShallowRenderer can fail context when shallowly rendering" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should warn about propTypes (but only once)" name="ReactShallowRenderer should warn about propTypes (but only once)" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRenderer should enable rendering of cloned element" name="ReactShallowRenderer should enable rendering of cloned element" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer this.state should be updated on setState callback inside componentWillMount" name="ReactShallowRenderer this.state should be updated on setState callback inside componentWillMount" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should handle multiple callbacks" name="ReactShallowRenderer should handle multiple callbacks" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRenderer should call the setState callback even if shouldComponentUpdate = false" name="ReactShallowRenderer should call the setState callback even if shouldComponentUpdate = false" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer throws usefully when rendering badly-typed elements" name="ReactShallowRenderer throws usefully when rendering badly-typed elements" time="0.009">
    </testcase>
    <testcase classname="ReactShallowRenderer should have initial state of null if not defined" name="ReactShallowRenderer should have initial state of null if not defined" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should invoke both deprecated and new lifecycles if both are present" name="ReactShallowRenderer should invoke both deprecated and new lifecycles if both are present" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should stop the update when setState returns null or undefined" name="ReactShallowRenderer should stop the update when setState returns null or undefined" time="0.026">
    </testcase>
    <testcase classname="ReactShallowRenderer should not get this in a function component" name="ReactShallowRenderer should not get this in a function component" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should handle memo" name="ReactShallowRenderer should handle memo" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should enable React.memo to prevent a re-render" name="ReactShallowRenderer should enable React.memo to prevent a re-render" time="0">
    </testcase>
    <testcase classname="ReactShallowRenderer should respect a custom comparison function with React.memo" name="ReactShallowRenderer should respect a custom comparison function with React.memo" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should not call the comparison function with React.memo on the initial render" name="ReactShallowRenderer should not call the comparison function with React.memo on the initial render" time="0.002">
    </testcase>
    <testcase classname="ReactShallowRenderer should handle memo(forwardRef())" name="ReactShallowRenderer should handle memo(forwardRef())" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should warn for forwardRef(memo())" name="ReactShallowRenderer should warn for forwardRef(memo())" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should let you change type" name="ReactShallowRenderer should let you change type" time="0.001">
    </testcase>
    <testcase classname="ReactShallowRenderer should let you change class type" name="ReactShallowRenderer should let you change class type" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMShorthandCSSPropertyCollision-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:27" time="0.653" tests="1">
    <testcase classname="ReactDOMShorthandCSSPropertyCollision should warn for conflicting CSS shorthand updates" name="ReactDOMShorthandCSSPropertyCollision should warn for conflicting CSS shorthand updates" time="0.371">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-server-native-relay/src/__tests__/ReactFlightNativeRelay-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:26" time="1.665" tests="3">
    <testcase classname="ReactFlightNativeRelay can render a server component" name="ReactFlightNativeRelay can render a server component" time="1.301">
    </testcase>
    <testcase classname="ReactFlightNativeRelay can render a client component using a module reference and render there" name="ReactFlightNativeRelay can render a client component using a module reference and render there" time="0.038">
    </testcase>
    <testcase classname="ReactFlightNativeRelay should warn in DEV if a class instance polyfill is passed to a host component" name="ReactFlightNativeRelay should warn in DEV if a class instance polyfill is passed to a host component" time="0.038">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/quoteAttributeValueForBrowser-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:27" time="0.947" tests="8">
    <testcase classname="quoteAttributeValueForBrowser ampersand is escaped inside attributes" name="quoteAttributeValueForBrowser ampersand is escaped inside attributes" time="0.039">
    </testcase>
    <testcase classname="quoteAttributeValueForBrowser double quote is escaped inside attributes" name="quoteAttributeValueForBrowser double quote is escaped inside attributes" time="0.011">
    </testcase>
    <testcase classname="quoteAttributeValueForBrowser single quote is escaped inside attributes" name="quoteAttributeValueForBrowser single quote is escaped inside attributes" time="0.01">
    </testcase>
    <testcase classname="quoteAttributeValueForBrowser greater than entity is escaped inside attributes" name="quoteAttributeValueForBrowser greater than entity is escaped inside attributes" time="0.04">
    </testcase>
    <testcase classname="quoteAttributeValueForBrowser lower than entity is escaped inside attributes" name="quoteAttributeValueForBrowser lower than entity is escaped inside attributes" time="0.012">
    </testcase>
    <testcase classname="quoteAttributeValueForBrowser number is escaped to string inside attributes" name="quoteAttributeValueForBrowser number is escaped to string inside attributes" time="0.032">
    </testcase>
    <testcase classname="quoteAttributeValueForBrowser object is passed to a string inside attributes" name="quoteAttributeValueForBrowser object is passed to a string inside attributes" time="0.032">
    </testcase>
    <testcase classname="quoteAttributeValueForBrowser script tag is escaped inside attributes" name="quoteAttributeValueForBrowser script tag is escaped inside attributes" time="0.04">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMIframe-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:28" time="0.321" tests="1">
    <testcase classname="ReactDOMIframe should trigger load events" name="ReactDOMIframe should trigger load events" time="0.085">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMFiberAsync-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:28" time="2.018" tests="17">
    <testcase classname="ReactDOMFiberAsync renders synchronously by default" name="ReactDOMFiberAsync renders synchronously by default" time="0.104">
    </testcase>
    <testcase classname="ReactDOMFiberAsync flushSync batches sync updates and flushes them at the end of the batch" name="ReactDOMFiberAsync flushSync batches sync updates and flushes them at the end of the batch" time="0.087">
    </testcase>
    <testcase classname="ReactDOMFiberAsync flushSync flushes updates even if nested inside another flushSync" name="ReactDOMFiberAsync flushSync flushes updates even if nested inside another flushSync" time="0.063">
    </testcase>
    <testcase classname="ReactDOMFiberAsync flushSync logs an error if already performing work" name="ReactDOMFiberAsync flushSync logs an error if already performing work" time="0.052">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode does not perform deferred updates synchronously" name="ReactDOMFiberAsync concurrent mode does not perform deferred updates synchronously" time="0.07">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode top-level updates are concurrent" name="ReactDOMFiberAsync concurrent mode top-level updates are concurrent" time="0.034">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode deep updates (setState) are concurrent" name="ReactDOMFiberAsync concurrent mode deep updates (setState) are concurrent" time="0.056">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode flushSync flushes updates before end of the tick" name="ReactDOMFiberAsync concurrent mode flushSync flushes updates before end of the tick" time="0.044">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode flushControlled flushes updates before yielding to browser" name="ReactDOMFiberAsync concurrent mode flushControlled flushes updates before yielding to browser" time="0.059">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode flushControlled does not flush until end of outermost batchedUpdates" name="ReactDOMFiberAsync concurrent mode flushControlled does not flush until end of outermost batchedUpdates" time="0.062">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode flushControlled returns nothing" name="ReactDOMFiberAsync concurrent mode flushControlled returns nothing" time="0.061">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode ignores discrete events on a pending removed element" name="ReactDOMFiberAsync concurrent mode ignores discrete events on a pending removed element" time="0.085">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode ignores discrete events on a pending removed event listener" name="ReactDOMFiberAsync concurrent mode ignores discrete events on a pending removed event listener" time="0.149">
    </testcase>
    <testcase classname="ReactDOMFiberAsync concurrent mode uses the newest discrete events on a pending changed event listener" name="ReactDOMFiberAsync concurrent mode uses the newest discrete events on a pending changed event listener" time="0.292">
    </testcase>
    <testcase classname="ReactDOMFiberAsync regression test: does not drop passive effects across roots (#17066)" name="ReactDOMFiberAsync regression test: does not drop passive effects across roots (#17066)" time="0.046">
    </testcase>
    <testcase classname="ReactDOMFiberAsync updates flush without yielding in the next event" name="ReactDOMFiberAsync updates flush without yielding in the next event" time="0.104">
    </testcase>
    <testcase classname="ReactDOMFiberAsync unmounted roots should never clear newer root content from a container" name="ReactDOMFiberAsync unmounted roots should never clear newer root content from a container" time="0.087">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationFragment-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:29" time="2.765" tests="20">
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with one child with server string render" name="ReactDOMServerIntegration React.Fragment renders a fragment with one child with server string render" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with one child with server stream render" name="ReactDOMServerIntegration React.Fragment renders a fragment with one child with server stream render" time="0.166">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with one child with clean client render" name="ReactDOMServerIntegration React.Fragment renders a fragment with one child with clean client render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with one child with client render on top of good server markup" name="ReactDOMServerIntegration React.Fragment renders a fragment with one child with client render on top of good server markup" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with one child with client render on top of bad server markup" name="ReactDOMServerIntegration React.Fragment renders a fragment with one child with client render on top of bad server markup" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with several children with server string render" name="ReactDOMServerIntegration React.Fragment renders a fragment with several children with server string render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with several children with server stream render" name="ReactDOMServerIntegration React.Fragment renders a fragment with several children with server stream render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with several children with clean client render" name="ReactDOMServerIntegration React.Fragment renders a fragment with several children with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with several children with client render on top of good server markup" name="ReactDOMServerIntegration React.Fragment renders a fragment with several children with client render on top of good server markup" time="0.134">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a fragment with several children with client render on top of bad server markup" name="ReactDOMServerIntegration React.Fragment renders a fragment with several children with client render on top of bad server markup" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a nested fragment with server string render" name="ReactDOMServerIntegration React.Fragment renders a nested fragment with server string render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a nested fragment with server stream render" name="ReactDOMServerIntegration React.Fragment renders a nested fragment with server stream render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a nested fragment with clean client render" name="ReactDOMServerIntegration React.Fragment renders a nested fragment with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a nested fragment with client render on top of good server markup" name="ReactDOMServerIntegration React.Fragment renders a nested fragment with client render on top of good server markup" time="0.16">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders a nested fragment with client render on top of bad server markup" name="ReactDOMServerIntegration React.Fragment renders a nested fragment with client render on top of bad server markup" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders an empty fragment with server string render" name="ReactDOMServerIntegration React.Fragment renders an empty fragment with server string render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders an empty fragment with server stream render" name="ReactDOMServerIntegration React.Fragment renders an empty fragment with server stream render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders an empty fragment with clean client render" name="ReactDOMServerIntegration React.Fragment renders an empty fragment with clean client render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders an empty fragment with client render on top of good server markup" name="ReactDOMServerIntegration React.Fragment renders an empty fragment with client render on top of good server markup" time="0.114">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.Fragment renders an empty fragment with client render on top of bad server markup" name="ReactDOMServerIntegration React.Fragment renders an empty fragment with client render on top of bad server markup" time="0.047">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactLegacyErrorBoundaries-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:27" time="4.999" tests="41">
    <testcase classname="ReactLegacyErrorBoundaries does not swallow exceptions on mounting without boundaries" name="ReactLegacyErrorBoundaries does not swallow exceptions on mounting without boundaries" time="0.255">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries does not swallow exceptions on updating without boundaries" name="ReactLegacyErrorBoundaries does not swallow exceptions on updating without boundaries" time="0.233">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries does not swallow exceptions on unmounting without boundaries" name="ReactLegacyErrorBoundaries does not swallow exceptions on unmounting without boundaries" time="0.152">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries prevents errors from leaking into other roots" name="ReactLegacyErrorBoundaries prevents errors from leaking into other roots" time="0.058">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries logs a single error using both error boundaries" name="ReactLegacyErrorBoundaries logs a single error using both error boundaries" time="0.09">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries renders an error state if child throws in render" name="ReactLegacyErrorBoundaries renders an error state if child throws in render" time="0.08">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries renders an error state if child throws in constructor" name="ReactLegacyErrorBoundaries renders an error state if child throws in constructor" time="0.054">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries renders an error state if child throws in componentWillMount" name="ReactLegacyErrorBoundaries renders an error state if child throws in componentWillMount" time="0.074">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries renders an error state if context provider throws in componentWillMount" name="ReactLegacyErrorBoundaries renders an error state if context provider throws in componentWillMount" time="0.047">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries mounts the error message if mounting fails" name="ReactLegacyErrorBoundaries mounts the error message if mounting fails" time="0.106">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries propagates errors on retry on mounting" name="ReactLegacyErrorBoundaries propagates errors on retry on mounting" time="0.077">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries propagates errors inside boundary during componentWillMount" name="ReactLegacyErrorBoundaries propagates errors inside boundary during componentWillMount" time="0.067">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries propagates errors inside boundary while rendering error state" name="ReactLegacyErrorBoundaries propagates errors inside boundary while rendering error state" time="0.056">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries does not call componentWillUnmount when aborting initial mount" name="ReactLegacyErrorBoundaries does not call componentWillUnmount when aborting initial mount" time="0.066">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries resets callback refs if mounting aborts" name="ReactLegacyErrorBoundaries resets callback refs if mounting aborts" time="0.079">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries resets object refs if mounting aborts" name="ReactLegacyErrorBoundaries resets object refs if mounting aborts" time="0.056">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries successfully mounts if no error occurs" name="ReactLegacyErrorBoundaries successfully mounts if no error occurs" time="0.053">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries catches if child throws in constructor during update" name="ReactLegacyErrorBoundaries catches if child throws in constructor during update" time="0.081">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries catches if child throws in componentWillMount during update" name="ReactLegacyErrorBoundaries catches if child throws in componentWillMount during update" time="0.049">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries catches if child throws in componentWillReceiveProps during update" name="ReactLegacyErrorBoundaries catches if child throws in componentWillReceiveProps during update" time="0.07">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries catches if child throws in componentWillUpdate during update" name="ReactLegacyErrorBoundaries catches if child throws in componentWillUpdate during update" time="0.074">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries catches if child throws in render during update" name="ReactLegacyErrorBoundaries catches if child throws in render during update" time="0.048">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries keeps refs up-to-date during updates" name="ReactLegacyErrorBoundaries keeps refs up-to-date during updates" time="0.065">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries recovers from componentWillUnmount errors on update" name="ReactLegacyErrorBoundaries recovers from componentWillUnmount errors on update" time="0.054">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries recovers from nested componentWillUnmount errors on update" name="ReactLegacyErrorBoundaries recovers from nested componentWillUnmount errors on update" time="0.09">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries picks the right boundary when handling unmounting errors" name="ReactLegacyErrorBoundaries picks the right boundary when handling unmounting errors" time="0.088">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries can recover from error state" name="ReactLegacyErrorBoundaries can recover from error state" time="0.093">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries can update multiple times in error state" name="ReactLegacyErrorBoundaries can update multiple times in error state" time="0.109">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries doesn&apos;t get into inconsistent state during removals" name="ReactLegacyErrorBoundaries doesn&apos;t get into inconsistent state during removals" time="0.054">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries doesn&apos;t get into inconsistent state during additions" name="ReactLegacyErrorBoundaries doesn&apos;t get into inconsistent state during additions" time="0.069">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries doesn&apos;t get into inconsistent state during reorders" name="ReactLegacyErrorBoundaries doesn&apos;t get into inconsistent state during reorders" time="0.128">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries catches errors originating downstream" name="ReactLegacyErrorBoundaries catches errors originating downstream" time="0.055">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries catches errors in componentDidMount" name="ReactLegacyErrorBoundaries catches errors in componentDidMount" time="0.082">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries catches errors in componentDidUpdate" name="ReactLegacyErrorBoundaries catches errors in componentDidUpdate" time="0.062">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries propagates errors inside boundary during componentDidMount" name="ReactLegacyErrorBoundaries propagates errors inside boundary during componentDidMount" time="0.054">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries calls componentDidCatch for each error that is captured" name="ReactLegacyErrorBoundaries calls componentDidCatch for each error that is captured" time="0.074">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries discards a bad root if the root component fails" name="ReactLegacyErrorBoundaries discards a bad root if the root component fails" time="0.057">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries renders empty output if error boundary does not handle the error" name="ReactLegacyErrorBoundaries renders empty output if error boundary does not handle the error" time="0.061">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries passes first error when two errors happen in commit" name="ReactLegacyErrorBoundaries passes first error when two errors happen in commit" time="0.073">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries propagates uncaught error inside unbatched initial mount" name="ReactLegacyErrorBoundaries propagates uncaught error inside unbatched initial mount" time="0.034">
    </testcase>
    <testcase classname="ReactLegacyErrorBoundaries handles errors that occur in before-mutation commit hook" name="ReactLegacyErrorBoundaries handles errors that occur in before-mutation commit hook" time="0.075">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/refs-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:30" time="1.905" tests="10">
    <testcase classname="reactiverefs Should increase refs with an increase in divs" name="reactiverefs Should increase refs with an increase in divs" time="0.123">
    </testcase>
    <testcase classname="ref swapping Allow refs to hop around children correctly" name="ref swapping Allow refs to hop around children correctly" time="0.175">
    </testcase>
    <testcase classname="ref swapping always has a value for this.refs" name="ref swapping always has a value for this.refs" time="0.138">
    </testcase>
    <testcase classname="ref swapping ref called correctly for stateless component" name="ref swapping ref called correctly for stateless component" time="0.101">
    </testcase>
    <testcase classname="ref swapping coerces numbers to strings" name="ref swapping coerces numbers to strings" time="0.057">
    </testcase>
    <testcase classname="ref swapping provides an error for invalid refs" name="ref swapping provides an error for invalid refs" time="0.112">
    </testcase>
    <testcase classname="ref swapping should warn about callback refs returning a function" name="ref swapping should warn about callback refs returning a function" time="0.066">
    </testcase>
    <testcase classname="root level refs attaches and detaches root refs" name="root level refs attaches and detaches root refs" time="0.018">
    </testcase>
    <testcase classname="creating element with ref in constructor throws an error" name="creating element with ref in constructor throws an error" time="0.03">
    </testcase>
    <testcase classname="strings refs across renderers does not break" name="strings refs across renderers does not break" time="0.042">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactRenderDocument-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:32" time="1.097" tests="9">
    <testcase classname="rendering React components at document with new explicit hydration API should be able to adopt server markup" name="rendering React components at document with new explicit hydration API should be able to adopt server markup" time="0.153">
    </testcase>
    <testcase classname="rendering React components at document with new explicit hydration API should not be able to unmount component from document node" name="rendering React components at document with new explicit hydration API should not be able to unmount component from document node" time="0.056">
    </testcase>
    <testcase classname="rendering React components at document with new explicit hydration API should not be able to switch root constructors" name="rendering React components at document with new explicit hydration API should not be able to switch root constructors" time="0.075">
    </testcase>
    <testcase classname="rendering React components at document with new explicit hydration API should be able to mount into document" name="rendering React components at document with new explicit hydration API should be able to mount into document" time="0.081">
    </testcase>
    <testcase classname="rendering React components at document with new explicit hydration API cannot render over an existing text child at the root" name="rendering React components at document with new explicit hydration API cannot render over an existing text child at the root" time="0.067">
    </testcase>
    <testcase classname="rendering React components at document with new explicit hydration API renders over an existing nested text child without throwing" name="rendering React components at document with new explicit hydration API renders over an existing nested text child without throwing" time="0.074">
    </testcase>
    <testcase classname="rendering React components at document with new explicit hydration API should give helpful errors on state desync" name="rendering React components at document with new explicit hydration API should give helpful errors on state desync" time="0.062">
    </testcase>
    <testcase classname="rendering React components at document with new explicit hydration API should render w/ no markup to full document" name="rendering React components at document with new explicit hydration API should render w/ no markup to full document" time="0.067">
    </testcase>
    <testcase classname="rendering React components at document with new explicit hydration API supports findDOMNode on full-page components" name="rendering React components at document with new explicit hydration API supports findDOMNode on full-page components" time="0.057">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerSelectiveHydration-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:33" time="2.941" tests="16">
    <testcase classname="ReactDOMServerSelectiveHydration hydrates the target boundary synchronously during a click" name="ReactDOMServerSelectiveHydration hydrates the target boundary synchronously during a click" time="0.191">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates at higher pri if sync did not work first time" name="ReactDOMServerSelectiveHydration hydrates at higher pri if sync did not work first time" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates at higher pri for secondary discrete events" name="ReactDOMServerSelectiveHydration hydrates at higher pri for secondary discrete events" time="0.118">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates the target boundary synchronously during a click (createEventHandle)" name="ReactDOMServerSelectiveHydration hydrates the target boundary synchronously during a click (createEventHandle)" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates at higher pri if sync did not work first time (createEventHandle)" name="ReactDOMServerSelectiveHydration hydrates at higher pri if sync did not work first time (createEventHandle)" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates at higher pri for secondary discrete events (createEventHandle)" name="ReactDOMServerSelectiveHydration hydrates at higher pri for secondary discrete events (createEventHandle)" time="0.087">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates the hovered targets as higher priority for continuous events" name="ReactDOMServerSelectiveHydration hydrates the hovered targets as higher priority for continuous events" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration replays capture phase for continuous events and respects stopPropagation" name="ReactDOMServerSelectiveHydration replays capture phase for continuous events and respects stopPropagation" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration can handle replaying events as part of multiple instances of React Inner hydrates first then Outer" name="ReactDOMServerSelectiveHydration can handle replaying events as part of multiple instances of React Inner hydrates first then Outer" time="0.273">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration can handle replaying events as part of multiple instances of React Outer hydrates first then Inner" name="ReactDOMServerSelectiveHydration can handle replaying events as part of multiple instances of React Outer hydrates first then Inner" time="0.23">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration replays event with null target when tree is dismounted" name="ReactDOMServerSelectiveHydration replays event with null target when tree is dismounted" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates the last target path first for continuous events" name="ReactDOMServerSelectiveHydration hydrates the last target path first for continuous events" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates the last explicitly hydrated target at higher priority" name="ReactDOMServerSelectiveHydration hydrates the last explicitly hydrated target at higher priority" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration hydrates before an update even if hydration moves away from it" name="ReactDOMServerSelectiveHydration hydrates before an update even if hydration moves away from it" time="0.083">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration fires capture event handlers and native events if content is hydratable during discrete event" name="ReactDOMServerSelectiveHydration fires capture event handlers and native events if content is hydratable during discrete event" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerSelectiveHydration does not propagate discrete event if it cannot be synchronously hydrated" name="ReactDOMServerSelectiveHydration does not propagate discrete event if it cannot be synchronously hydrated" time="0.065">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-refresh/src/__tests__/ReactFresh-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:22" time="14.974" tests="54">
    <testcase classname="ReactFresh can preserve state for compatible types" name="ReactFresh can preserve state for compatible types" time="0.376">
    </testcase>
    <testcase classname="ReactFresh can preserve state for forwardRef" name="ReactFresh can preserve state for forwardRef" time="0.091">
    </testcase>
    <testcase classname="ReactFresh should not consider two forwardRefs around the same type to be equivalent" name="ReactFresh should not consider two forwardRefs around the same type to be equivalent" time="0.094">
    </testcase>
    <testcase classname="ReactFresh can update forwardRef render function with its wrapper" name="ReactFresh can update forwardRef render function with its wrapper" time="0.059">
    </testcase>
    <testcase classname="ReactFresh can update forwardRef render function in isolation" name="ReactFresh can update forwardRef render function in isolation" time="0.067">
    </testcase>
    <testcase classname="ReactFresh can preserve state for simple memo" name="ReactFresh can preserve state for simple memo" time="0.057">
    </testcase>
    <testcase classname="ReactFresh can preserve state for memo with custom comparison" name="ReactFresh can preserve state for memo with custom comparison" time="0.072">
    </testcase>
    <testcase classname="ReactFresh can update simple memo function in isolation" name="ReactFresh can update simple memo function in isolation" time="0.09">
    </testcase>
    <testcase classname="ReactFresh can preserve state for memo(forwardRef)" name="ReactFresh can preserve state for memo(forwardRef)" time="0.058">
    </testcase>
    <testcase classname="ReactFresh can preserve state for lazy after resolution" name="ReactFresh can preserve state for lazy after resolution" time="0.093">
    </testcase>
    <testcase classname="ReactFresh can patch lazy before resolution" name="ReactFresh can patch lazy before resolution" time="0.081">
    </testcase>
    <testcase classname="ReactFresh can patch lazy(forwardRef) before resolution" name="ReactFresh can patch lazy(forwardRef) before resolution" time="0.066">
    </testcase>
    <testcase classname="ReactFresh can patch lazy(memo) before resolution" name="ReactFresh can patch lazy(memo) before resolution" time="0.06">
    </testcase>
    <testcase classname="ReactFresh can patch lazy(memo(forwardRef)) before resolution" name="ReactFresh can patch lazy(memo(forwardRef)) before resolution" time="0.065">
    </testcase>
    <testcase classname="ReactFresh can patch both trees while suspense is displaying the fallback" name="ReactFresh can patch both trees while suspense is displaying the fallback" time="0.132">
    </testcase>
    <testcase classname="ReactFresh does not re-render ancestor components unnecessarily during a hot update" name="ReactFresh does not re-render ancestor components unnecessarily during a hot update" time="0.079">
    </testcase>
    <testcase classname="ReactFresh batches re-renders during a hot update" name="ReactFresh batches re-renders during a hot update" time="0.064">
    </testcase>
    <testcase classname="ReactFresh does not leak state between components" name="ReactFresh does not leak state between components" time="0.083">
    </testcase>
    <testcase classname="ReactFresh can force remount by changing signature" name="ReactFresh can force remount by changing signature" time="0.09">
    </testcase>
    <testcase classname="ReactFresh keeps a valid tree when forcing remount" name="ReactFresh keeps a valid tree when forcing remount" time="7.3">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a &lt;root&gt; wrapper" name="ReactFresh can remount on signature change within a &lt;root&gt; wrapper" time="0.069">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a simple memo wrapper" name="ReactFresh can remount on signature change within a simple memo wrapper" time="0.067">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a lazy simple memo wrapper" name="ReactFresh can remount on signature change within a lazy simple memo wrapper" time="0.08">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within forwardRef" name="ReactFresh can remount on signature change within forwardRef" time="0.113">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within forwardRef render function" name="ReactFresh can remount on signature change within forwardRef render function" time="0.049">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within nested memo" name="ReactFresh can remount on signature change within nested memo" time="0.079">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a memo wrapper and custom comparison" name="ReactFresh can remount on signature change within a memo wrapper and custom comparison" time="0.069">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a class" name="ReactFresh can remount on signature change within a class" time="0.084">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a context provider" name="ReactFresh can remount on signature change within a context provider" time="0.053">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a context consumer" name="ReactFresh can remount on signature change within a context consumer" time="0.085">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a suspense node" name="ReactFresh can remount on signature change within a suspense node" time="0.078">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a mode node" name="ReactFresh can remount on signature change within a mode node" time="0.065">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a fragment node" name="ReactFresh can remount on signature change within a fragment node" time="0.072">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within multiple siblings" name="ReactFresh can remount on signature change within multiple siblings" time="0.096">
    </testcase>
    <testcase classname="ReactFresh can remount on signature change within a profiler node" name="ReactFresh can remount on signature change within a profiler node" time="0.073">
    </testcase>
    <testcase classname="ReactFresh resets hooks with dependencies on hot reload" name="ReactFresh resets hooks with dependencies on hot reload" time="0.047">
    </testcase>
    <testcase classname="ReactFresh does not get into infinite loops during render phase updates" name="ReactFresh does not get into infinite loops during render phase updates" time="0.075">
    </testcase>
    <testcase classname="ReactFresh can hot reload offscreen components" name="ReactFresh can hot reload offscreen components" time="0.096">
    </testcase>
    <testcase classname="ReactFresh remounts failed error boundaries (componentDidCatch)" name="ReactFresh remounts failed error boundaries (componentDidCatch)" time="0.247">
    </testcase>
    <testcase classname="ReactFresh remounts failed error boundaries (getDerivedStateFromError)" name="ReactFresh remounts failed error boundaries (getDerivedStateFromError)" time="0.337">
    </testcase>
    <testcase classname="ReactFresh remounts error boundaries that failed asynchronously after hot update" name="ReactFresh remounts error boundaries that failed asynchronously after hot update" time="0.201">
    </testcase>
    <testcase classname="ReactFresh remounts a failed root on mount" name="ReactFresh remounts a failed root on mount" time="0.187">
    </testcase>
    <testcase classname="ReactFresh does not retry an intentionally unmounted failed root" name="ReactFresh does not retry an intentionally unmounted failed root" time="0.062">
    </testcase>
    <testcase classname="ReactFresh remounts a failed root on update" name="ReactFresh remounts a failed root on update" time="0.128">
    </testcase>
    <testcase classname="ReactFresh regression test: does not get into an infinite loop" name="ReactFresh regression test: does not get into an infinite loop" time="0.115">
    </testcase>
    <testcase classname="ReactFresh remounts classes on every edit" name="ReactFresh remounts classes on every edit" time="0.179">
    </testcase>
    <testcase classname="ReactFresh updates refs when remounting" name="ReactFresh updates refs when remounting" time="0.159">
    </testcase>
    <testcase classname="ReactFresh remounts on conversion from class to function and back" name="ReactFresh remounts on conversion from class to function and back" time="0.214">
    </testcase>
    <testcase classname="ReactFresh can find host instances for a family" name="ReactFresh can find host instances for a family" time="0.242">
    </testcase>
    <testcase classname="ReactFresh can update multiple roots independently" name="ReactFresh can update multiple roots independently" time="0.1">
    </testcase>
    <testcase classname="ReactFresh can detect likely component types" name="ReactFresh can detect likely component types" time="0.053">
    </testcase>
    <testcase classname="ReactFresh reports updated and remounted families to the caller" name="ReactFresh reports updated and remounted families to the caller" time="0.074">
    </testcase>
    <testcase classname="ReactFresh can inject the runtime after the renderer executes" name="ReactFresh can inject the runtime after the renderer executes" time="0.098">
    </testcase>
    <testcase classname="ReactFresh does not block DevTools when an unsupported renderer is injected" name="ReactFresh does not block DevTools when an unsupported renderer is injected" time="0.157">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationUntrustedURL-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:29" time="9.017" tests="106">
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with server string render" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with server stream render" time="0.177">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with clean client render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with client render on top of good server markup" time="0.097">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a http link with the word javascript in it with client render on top of bad server markup" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with server string render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with server stream render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with clean client render" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with client render on top of good server markup" time="0.114">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol href with client render on top of bad server markup" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with server string render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with clean client render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with client render on top of good server markup" time="0.129">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with leading spaces with client render on top of bad server markup" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with server string render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with server stream render" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with clean client render" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with client render on top of good server markup" time="0.128">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol with intermediate new lines and mixed casing with client render on top of bad server markup" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with server string render" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with server stream render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with clean client render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with client render on top of good server markup" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol area href with client render on top of bad server markup" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with server string render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with server stream render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with client render on top of good server markup" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol form action with client render on top of bad server markup" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with server string render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with server stream render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with clean client render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with client render on top of good server markup" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol button formAction with client render on top of bad server markup" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with server string render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with server stream render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with clean client render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with client render on top of good server markup" time="0.109">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol input formAction with client render on top of bad server markup" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with server string render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with server stream render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with client render on top of good server markup" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol iframe src with client render on top of bad server markup" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with server string render" time="0.097">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with server stream render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with clean client render" time="0.318">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with client render on top of good server markup" time="0.402">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol frame src with client render on top of bad server markup" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with server string render" time="0.11">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with server stream render" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with clean client render" time="0.175">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with client render on top of good server markup" time="0.277">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with client render on top of bad server markup" time="0.172">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with server string render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with server string render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with server stream render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with server stream render" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with clean client render" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with clean client render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with client render on top of good server markup" time="0.16">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs renders a javascript protocol in an SVG link with a namespace with client render on top of bad server markup" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs rejects a javascript protocol href if it is added during an update" name="ReactDOMServerIntegration - Untrusted URLs rejects a javascript protocol href if it is added during an update" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with server string render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with server stream render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with server stream render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with clean client render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with client render on top of good server markup" time="0.118">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders a http link with the word javascript in it with client render on top of bad server markup" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol href with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol href with server string render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol href with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol href with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol href with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol href with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with leading spaces with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with leading spaces with server string render" time="0.032">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with leading spaces with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with leading spaces with clean client render" time="0.083">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with leading spaces with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with leading spaces with client render on top of bad server markup" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with intermediate new lines and mixed casing with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with intermediate new lines and mixed casing with server string render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with intermediate new lines and mixed casing with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with intermediate new lines and mixed casing with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with intermediate new lines and mixed casing with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol with intermediate new lines and mixed casing with client render on top of bad server markup" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol area href with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol area href with server string render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol area href with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol area href with clean client render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol area href with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol area href with client render on top of bad server markup" time="0.154">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol form action with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol form action with server string render" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol form action with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol form action with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol form action with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol form action with client render on top of bad server markup" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol button formAction with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol button formAction with server string render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol button formAction with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol button formAction with clean client render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol button formAction with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol button formAction with client render on top of bad server markup" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol input formAction with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol input formAction with server string render" time="0.087">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol input formAction with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol input formAction with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol input formAction with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol input formAction with client render on top of bad server markup" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol iframe src with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol iframe src with server string render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol iframe src with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol iframe src with clean client render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol iframe src with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol iframe src with client render on top of bad server markup" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol frame src with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol frame src with server string render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol frame src with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol frame src with clean client render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol frame src with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol frame src with client render on top of bad server markup" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with clean client render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with client render on top of bad server markup" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with a namespace with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with a namespace with server string render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with a namespace with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with a namespace with clean client render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with a namespace with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs throws when rendering a javascript protocol in an SVG link with a namespace with client render on top of bad server markup" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs rejects a javascript protocol href if it is added during an update" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs rejects a javascript protocol href if it is added during an update" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with server string render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with server string render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with server stream render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with clean client render" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with clean client render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with client render on top of good server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with client render on top of good server markup" time="0.129">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with client render on top of bad server markup" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs renders only the first invocation of toString with client render on top of bad server markup" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs rejects a javascript protocol href if it is added during an update twice" name="ReactDOMServerIntegration - Untrusted URLs - disableJavaScriptURLs rejects a javascript protocol href if it is added during an update twice" time="0.069">
    </testcase>
  </testsuite>
  <testsuite name="packages/eslint-plugin-react-hooks/__tests__/ESLintRuleExhaustiveDeps-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:13" time="26.759" tests="1718">
    <testcase classname="react-hooks parser: babel-eslint valid 
function Example({ prop }) {
  const bar = useEffect(&lt;T&gt;(a: T): Hello =&gt; {
    prop();
  }, [prop]);
}
" name="react-hooks parser: babel-eslint valid 
function Example({ prop }) {
  const bar = useEffect(&lt;T&gt;(a: T): Hello =&gt; {
    prop();
  }, [prop]);
}
" time="1.037">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" time="0.034">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" time="0.042">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" time="0.035">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" time="0.036">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" time="0.031">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" name="react-hooks parser: babel-eslint valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" time="0.043">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" time="0.033">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" name="react-hooks parser: babel-eslint valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" name="react-hooks parser: babel-eslint valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" name="react-hooks parser: babel-eslint valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: babel-eslint valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" name="react-hooks parser: babel-eslint valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.03">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" name="react-hooks parser: babel-eslint valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: babel-eslint valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" name="react-hooks parser: babel-eslint valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" name="react-hooks parser: babel-eslint valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" name="react-hooks parser: babel-eslint valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" name="react-hooks parser: babel-eslint valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" name="react-hooks parser: babel-eslint valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" name="react-hooks parser: babel-eslint valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" name="react-hooks parser: babel-eslint valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" name="react-hooks parser: babel-eslint valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" name="react-hooks parser: babel-eslint valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" name="react-hooks parser: babel-eslint valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" name="react-hooks parser: babel-eslint valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" time="0.031">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" name="react-hooks parser: babel-eslint valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = ({}: any);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = ({}: any);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" time="0.043">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" time="0.09">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" time="0.099">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" name="react-hooks parser: babel-eslint invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" time="0.035">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" name="react-hooks parser: babel-eslint invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: babel-eslint invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" name="react-hooks parser: babel-eslint invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " name="react-hooks parser: babel-eslint invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" name="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" name="react-hooks parser: babel-eslint invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.038">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: babel-eslint invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: babel-eslint invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: babel-eslint invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: babel-eslint invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" name="react-hooks parser: babel-eslint invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: babel-eslint invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: babel-eslint invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" name="react-hooks parser: babel-eslint invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" name="react-hooks parser: babel-eslint invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" name="react-hooks parser: babel-eslint invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" name="react-hooks parser: babel-eslint invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" name="react-hooks parser: babel-eslint invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" name="react-hooks parser: babel-eslint invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" name="react-hooks parser: babel-eslint invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" name="react-hooks parser: babel-eslint invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" name="react-hooks parser: babel-eslint invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: babel-eslint invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Example({ prop }) {
  const bar = useEffect(&lt;T&gt;(a: T): Hello =&gt; {
    prop();
  }, [prop]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Example({ prop }) {
  const bar = useEffect(&lt;T&gt;(a: T): Hello =&gt; {
    prop();
  }, [prop]);
}
" time="1.094">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" time="0.039">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.036">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.041">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" name="react-hooks parser: @babel/eslint-parser valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" time="0.059">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" time="0.044">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" name="react-hooks parser: @babel/eslint-parser valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" name="react-hooks parser: @babel/eslint-parser valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.035">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.055">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" name="react-hooks parser: @babel/eslint-parser valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" name="react-hooks parser: @babel/eslint-parser valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" name="react-hooks parser: @babel/eslint-parser valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = ({}: any);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = ({}: any);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.04">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.032">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" time="0.03">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" time="0.039">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" time="0.068">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" time="0.055">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" time="0.076">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" time="0.033">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.095">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" time="0.039">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" name="react-hooks parser: @babel/eslint-parser invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.035">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" time="0.04">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " name="react-hooks parser: @babel/eslint-parser invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" name="react-hooks parser: @babel/eslint-parser invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.032">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" time="0.04">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.033">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" time="0.031">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.032">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.043">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.035">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" time="0.037">
    </testcase>
    <testcase classname="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @babel/eslint-parser invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const ref = useRef() as React.MutableRefObject&lt;HTMLDivElement&gt;;
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const ref = useRef() as React.MutableRefObject&lt;HTMLDivElement&gt;;
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.887">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber);
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber);
  }, [])
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function App() {
  const foo = {x: 1};
  React.useEffect(() =&gt; {
    const bar = {x: 2};
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function App() {
  const foo = {x: 1};
  React.useEffect(() =&gt; {
    const bar = {x: 2};
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" time="0.055">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" time="0.036">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.039">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" time="0.049">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {} as string;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {} as string;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function App() {
  const foo = {x: 1};
  const bar = {x: 2};
  useEffect(() =&gt; {
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function App() {
  const foo = {x: 1};
  const bar = {x: 2};
  useEffect(() =&gt; {
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    toppings: pizza?.toppings,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    toppings: pizza?.toppings,
  }), []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza.crust.density,
  }), []);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    density: pizza?.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    density: pizza?.crust.density,
  }), []);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza?.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza?.crust.density,
  }), []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, []);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber + state);
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber + state);
  }, [])
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useMemo(() =&gt; {
    const someNumber: typeof state = 2;
    console.log(someNumber);
  }, [state])
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useMemo(() =&gt; {
    const someNumber: typeof state = 2;
    console.log(someNumber);
  }, [state])
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = {} as any;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = {} as any;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" time="0.047">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" time="0.064">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.035">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.031">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.035">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@2.x invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const ref = useRef() as React.MutableRefObject&lt;HTMLDivElement&gt;;
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const ref = useRef() as React.MutableRefObject&lt;HTMLDivElement&gt;;
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.382">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber);
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber);
  }, [])
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function App() {
  const foo = {x: 1};
  React.useEffect(() =&gt; {
    const bar = {x: 2};
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function App() {
  const foo = {x: 1};
  React.useEffect(() =&gt; {
    const bar = {x: 2};
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" time="0.043">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" time="0.042">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.04">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.042">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {} as string;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {} as string;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function App() {
  const foo = {x: 1};
  const bar = {x: 2};
  useEffect(() =&gt; {
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function App() {
  const foo = {x: 1};
  const bar = {x: 2};
  useEffect(() =&gt; {
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    toppings: pizza?.toppings,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    toppings: pizza?.toppings,
  }), []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza.crust.density,
  }), []);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    density: pizza?.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    density: pizza?.crust.density,
  }), []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza?.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza?.crust.density,
  }), []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber + state);
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber + state);
  }, [])
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useMemo(() =&gt; {
    const someNumber: typeof state = 2;
    console.log(someNumber);
  }, [state])
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useMemo(() =&gt; {
    const someNumber: typeof state = 2;
    console.log(someNumber);
  }, [state])
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = {} as any;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = {} as any;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.051">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" time="0.04">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.04">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.04">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@3.x invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const ref = useRef() as React.MutableRefObject&lt;HTMLDivElement&gt;;
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const ref = useRef() as React.MutableRefObject&lt;HTMLDivElement&gt;;
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.713">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber);
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber);
  }, [])
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function App() {
  const foo = {x: 1};
  React.useEffect(() =&gt; {
    const bar = {x: 2};
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function App() {
  const foo = {x: 1};
  React.useEffect(() =&gt; {
    const bar = {x: 2};
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.053">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.049">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.04">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" time="0.029">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" time="0.031">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo({ Component }) {
  React.useEffect(() =&gt; {
    console.log(&lt;Component /&gt;);
  }, []);
};
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo({ Component }) {
  React.useEffect(() =&gt; {
    console.log(&lt;Component /&gt;);
  }, []);
};
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {} as string;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {} as string;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function App() {
  const foo = {x: 1};
  const bar = {x: 2};
  useEffect(() =&gt; {
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function App() {
  const foo = {x: 1};
  const bar = {x: 2};
  useEffect(() =&gt; {
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    toppings: pizza?.toppings,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    toppings: pizza?.toppings,
  }), []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza.crust.density,
  }), []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    density: pizza?.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    density: pizza?.crust.density,
  }), []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza?.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza?.crust.density,
  }), []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber + state);
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber + state);
  }, [])
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useMemo(() =&gt; {
    const someNumber: typeof state = 2;
    console.log(someNumber);
  }, [state])
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useMemo(() =&gt; {
    const someNumber: typeof state = 2;
    console.log(someNumber);
  }, [state])
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = {} as any;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = {} as any;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" time="0.023">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" time="0.033">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" time="0.049">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" time="0.041">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.032">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" time="0.034">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@4.x invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.034">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const ref = useRef() as React.MutableRefObject&lt;HTMLDivElement&gt;;
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const ref = useRef() as React.MutableRefObject&lt;HTMLDivElement&gt;;
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.579">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber);
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber);
  }, [])
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function App() {
  const foo = {x: 1};
  React.useEffect(() =&gt; {
    const bar = {x: 2};
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function App() {
  const foo = {x: 1};
  React.useEffect(() =&gt; {
    const bar = {x: 2};
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  useEffect(() =&gt; {
    const local = {};
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = {};
  {
    const local2 = {};
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    });
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1, local2]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = someFunc();
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local2]);
  }
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  useEffect(() =&gt; {
    console.log(unresolved);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [,,,local,,,]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ foo }) {
  useEffect(() =&gt; {
    console.log(foo.length);
    console.log(foo.slice(0));
  }, [foo]);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, [history]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {});
  useLayoutEffect(() =&gt; {});
  useImperativeHandle(props.innerRef, () =&gt; {});
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.bar, props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props.foo, props.bar]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props.foo, props.bar, local]);
}
" time="0.03">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);

  let color = someFunc();
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz, color]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar?.baz ?? null);
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo?.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo?.bar]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar);
    console.log(props.foo?.bar);
  }, [props.foo.bar]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.foo?.bar);
  }, [props.foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useMemo(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, [props.foo]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.toString());
  }, [props.foo.bar]);
}
" time="0.031">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo.bar.toString());
  }, [props?.foo?.bar]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, [props?.foo.bar?.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const myEffect = () =&gt; {
    // Doesn&apos;t use anything
  };
  useEffect(myEffect, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local = {};
function MyComponent() {
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local = someFunc();
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  function myEffect() {
    console.log(global);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local = {};
function MyComponent() {
  const myEffect = () =&gt; {
    otherThing()
  }
  const otherThing = () =&gt; {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({delay}) {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [myEffect]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [,myEffect,,]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
let local = {};
function myEffect() {
  console.log(local);
}
function MyComponent() {
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({myEffect}) {
  useEffect(myEffect, [myEffect]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({myEffect}) {
  useEffect(myEffect);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, [props.foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useWithoutEffectSuffix(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.024">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  return renderHelperConfusedWithEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local = {};
useEffect(() =&gt; {
  console.log(local);
}, []);
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const local1 = {};
{
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ maybeRef2, foo }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();
  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();
  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();
  const [isPending1] = useTransition();
  const [isPending2, startTransition2] = useTransition();
  const [isPending3] = React.useTransition();
  const [isPending4, startTransition4] = React.useTransition();
  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();
    startTransition1();
    startTransition2();
    startTransition3();
    startTransition4();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    console.log(isPending2);
    console.log(isPending4);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,
    isPending2, isPending4,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch

    // In this test, we don&apos;t specify static deps.
    // That should be okay.
  ]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({ maybeRef2 }) {
  const definitelyRef1 = useRef();
  const definitelyRef2 = useRef();
  const maybeRef1 = useSomeOtherRefyThing();

  const [state1, setState1] = useState();
  const [state2, setState2] = React.useState();
  const [state3, dispatch1] = useReducer();
  const [state4, dispatch2] = React.useReducer();

  const [state5, maybeSetState] = useFunnyState();
  const [state6, maybeDispatch] = useFunnyReducer();

  const mySetState = useCallback(() =&gt; {}, []);
  let myDispatch = useCallback(() =&gt; {}, []);

  useEffect(() =&gt; {
    // Known to be static
    console.log(definitelyRef1.current);
    console.log(definitelyRef2.current);
    console.log(maybeRef1.current);
    console.log(maybeRef2.current);
    setState1();
    setState2();
    dispatch1();
    dispatch2();

    // Dynamic
    console.log(state1);
    console.log(state2);
    console.log(state3);
    console.log(state4);
    console.log(state5);
    console.log(state6);
    mySetState();
    myDispatch();

    // Not sure; assume dynamic
    maybeSetState();
    maybeDispatch();
  }, [
    // Dynamic
    state1, state2, state3, state4, state5, state6,
    maybeRef1, maybeRef2,

    // Not sure; assume dynamic
    mySetState, myDispatch,
    maybeSetState, maybeDispatch,

    // In this test, we specify static deps.
    // That should be okay too!
    definitelyRef1, definitelyRef2, setState1, setState2, dispatch1, dispatch2
  ]);
}
" time="0.072">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }))
});
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [props.hello])
});
" time="0.046">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  let obj = someFunc();
  useEffect(() =&gt; {
    obj.foo = true;
  }, [obj]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
  }, [foo.bar]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef?.current?.toString())
    };
  }, []);
  return &lt;div /&gt;;
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current = {};
    return () =&gt; {
      console.log(myRef.current.toString())
    };
  }, [myRef]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    const node = myRef.current;
    node.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; node.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing(myRef) {
  useCallback(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      console.log(myRef.current)
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useMyThing() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {
      return () =&gt; window.removeEventListener(&apos;mousemove&apos;, handleMove);
    };
    window.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; {};
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
  }, [local1, local2, local3]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  const local = props.local;
  useEffect(() =&gt; {}, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Foo({ activeTab }) {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [activeTab]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  useEffect(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props]);
  const fn2 = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo]);
  const fn3 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar]);
  const fn4 = useMemo(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  function handleNext() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext);
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();

  function handleNext1(value) {
    let value2 = value * 100;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(foo(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(value);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useInterval(callback, delay) {
  const savedCallback = useRef();
  useEffect(() =&gt; {
    savedCallback.current = callback;
  });
  useEffect(() =&gt; {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () =&gt; clearInterval(id);
    }
  }, [delay]);
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [setCount]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(c =&gt; c + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      dispatch(&apos;inc&apos;);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.022">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  const [count, dispatch] = useReducer((state, action) =&gt; {
    if (action === &apos;inc&apos;) {
      return state + 1;
    }
  }, 0);

  const tick = () =&gt; {
    dispatch(&apos;inc&apos;);
  };

  useEffect(() =&gt; {
    let id = setInterval(tick, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Podcasts() {
  useEffect(() =&gt; {
    setPodcasts([]);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function withFetch(fetchPodcasts) {
  return function Podcasts({ id }) {
    let [podcasts, setPodcasts] = useState(null);
    useEffect(() =&gt; {
      fetchPodcasts(id).then(setPodcasts);
    }, [id]);
  }
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Podcasts({ id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    function doFetch({ fetchPodcasts }) {
      fetchPodcasts(id).then(setPodcasts);
    }
    doFetch({ fetchPodcasts: API.fetchPodcasts });
  }, [id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Counter() {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + 1;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
import increment from &apos;./increment&apos;;
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function withStuff(increment) {
  return function Counter() {
    let [count, setCount] = useState(0);

    useEffect(() =&gt; {
      let id = setInterval(() =&gt; {
        setCount(count =&gt; count + increment);
      }, 1000);
      return () =&gt; clearInterval(id);
    }, []);

    return &lt;h1&gt;{count}&lt;/h1&gt;;
  }
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function App() {
  const [query, setQuery] = useState(&apos;react&apos;);
  const [state, setState] = useState(null);
  useEffect(() =&gt; {
    let ignore = false;
    fetchSomething();
    async function fetchSomething() {
      const result = await (await fetch(&apos;http://hn.algolia.com/api/v1/search?query=&apos; + query)).json();
      if (!ignore) setState(result);
    }
    return () =&gt; { ignore = true; };
  }, [query]);
  return (
    &lt;&gt;
      &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      {JSON.stringify(state)}
    &lt;/&gt;
  );
}
" time="0.019">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    if (prop) {
      foo();
    }
  }, [prop]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    const handleResize = () =&gt; setState(window.innerWidth);
    window.addEventListener(&apos;resize&apos;, handleResize);
    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);
  });
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example() {
  useEffect(() =&gt; {
    arguments
  }, [])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example() {
  useEffect(() =&gt; {
    const bar = () =&gt; {
      arguments;
    };
    bar();
  }, [])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, [props.upperViewHeight]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props?.upperViewHeight]);
}
" time="0.016">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, [props]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo(foo){
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo(){
  const foo = &quot;hi!&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo(){
  let {foo} = {foo: 1};
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo(){
  let [foo] = [1];
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function useFoo() {
  const foo = &quot;fine&quot;;
  if (true) {
    // Shadowed variable with constant construction in a nested scope is fine.
    const foo = {};
  }
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent({foo}) {
  return useMemo(() =&gt; foo, [foo])
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 valid 
function MyComponent() {
  const foo = true ? &quot;fine&quot; : &quot;also fine&quot;;
  return useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo({ Component }) {
  React.useEffect(() =&gt; {
    console.log(&lt;Component /&gt;);
  }, []);
};
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo({ Component }) {
  React.useEffect(() =&gt; {
    console.log(&lt;Component /&gt;);
  }, []);
};
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {} as string;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {} as string;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function App() {
  const foo = {x: 1};
  const bar = {x: 2};
  useEffect(() =&gt; {
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function App() {
  const foo = {x: 1};
  const bar = {x: 2};
  useEffect(() =&gt; {
    const baz = bar as typeof foo;
    console.log(baz);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    toppings: pizza?.toppings,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    toppings: pizza?.toppings,
  }), []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza.crust.density,
  }), []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    density: pizza?.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza.crust,
    density: pizza?.crust.density,
  }), []);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza?.crust.density,
  }), []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const pizza = {};

  useEffect(() =&gt; ({
    crust: pizza?.crust,
    density: pizza?.crust.density,
  }), []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props.upperViewHeight;
  }, []);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Example(props) {
  useEffect(() =&gt; {
    let topHeight = 0;
    topHeight = props?.upperViewHeight;
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber + state);
  }, [])
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useEffect(() =&gt; {
    const someNumber: typeof state = 2;
    setState(prevState =&gt; prevState + someNumber + state);
  }, [])
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useMemo(() =&gt; {
    const someNumber: typeof state = 2;
    console.log(someNumber);
  }, [state])
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const [state, setState] = React.useState&lt;number&gt;(0);

  useMemo(() =&gt; {
    const someNumber: typeof state = 2;
    console.log(someNumber);
  }, [state])
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = {} as any;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = {} as any;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.toString());
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.baz);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar?.baz);
  }, []);
}
" time="0.021">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCallback(() =&gt; {
    console.log(props.foo?.bar.toString());
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter(unstableProp) {
  let [count, setCount] = useState(0);
  setCount = unstableProp
  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  let local = 42;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = /foo/;
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const value = useMemo(() =&gt; { return 2*2; });
  const fn = useCallback(() =&gt; { alert(&apos;foo&apos;); });
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ fn1, fn2 }) {
  const value = useMemo(fn1);
  const fn = useCallback(fn2);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  useEffect()
  useLayoutEffect()
  useCallback()
  useMemo()
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    if (true) {
      console.log(local);
    }
  }, []);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    try {
      console.log(local);
    } finally {}
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    function inner() {
      console.log(local);
    }
    inner();
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = someFunc();
  {
    const local2 = someFunc();
    useEffect(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, []);
  }
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
  }, [local1]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = {};
  const local2 = {};
  useMemo(() =&gt; {
    console.log(local1);
  }, [local1, local2]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = someFunc();
  function MyNestedComponent() {
    const local2 = {};
    useCallback(() =&gt; {
      console.log(local1);
      console.log(local2);
    }, [local1]);
  }
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
    console.log(local);
  }, [local, local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  useCallback(() =&gt; {}, [window]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let local = props.foo;
  useCallback(() =&gt; {}, [local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return history.listen();
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history.foo.bar[2].dobedo.listen(),
      history.foo.bar().dobedo.listen[2]
    ];
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ history }) {
  useEffect(() =&gt; {
    return [
      history?.foo
    ];
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  useEffect(() =&gt; {}, [&apos;foo&apos;]);
}
" time="0.039">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [&apos;foo&apos;, &apos;bar&apos;]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ foo, bar, baz }) {
  useEffect(() =&gt; {
    console.log(foo, bar, baz);
  }, [42, false, null]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const dependencies = [];
  useEffect(() =&gt; {}, dependencies);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, dependencies);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const dependencies = [local];
  useEffect(() =&gt; {
    console.log(local);
  }, [...dependencies]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = someFunc();
  useEffect(() =&gt; {
    console.log(local);
  }, [local, ...dependencies]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [computeCacheKey(local)]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items[0]]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.items[0]);
  }, [props.items, props.items[0]]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items[0]]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ items }) {
  useEffect(() =&gt; {
    console.log(items[0]);
  }, [items, items[0]]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, [props, props.foo]);
}
" time="0.034">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const local = {};
  useCallback(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {id: 42};
  useEffect(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id]);
}
" time="0.033">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {id: 42};
  const fn = useCallback(() =&gt; {
    console.log(local);
  }, [local.id, local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let color = {}
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(color);
  }, [props.foo, props.foo.bar.baz]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
  }, [props.foo.bar.baz, props.foo]);
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar.baz);
    console.log(props.foo.fizz.bizz);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props.foo.bar);
  }, [props.foo.bar.baz]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const fn = useCallback(() =&gt; {
    console.log(props);
    console.log(props.hello);
  }, [props.foo.bar.baz]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [local, local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {
    const local1 = {};
    console.log(local1);
  }, [local1]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = {};
  useCallback(() =&gt; {}, [local1]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [c, a, g]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, [a, c, g]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let a, b, c, d, e, f, g;
  useEffect(() =&gt; {
    console.log(b, e, d, c, a, g, f);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const local = {};
  useEffect(() =&gt; {
    console.log(props.foo);
    console.log(props.bar);
    console.log(local);
  }, [props]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCallback(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useMemo(() =&gt; {
    console.log(props.foo);
  }, []);
  React.notReactiveHook(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.063">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useEffect(() =&gt; {
    console.log(props.foo);
  }, []);
  React.useCustomEffect(() =&gt; {
    console.log(props.foo);
  }, []);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a ? local : b]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, [a &amp;&amp; local]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props?.attribute.method()]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {}, [props.method()]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const ref = useRef();
  const [state, setState] = useState();
  useEffect(() =&gt; {
    ref.current = {};
    setState(state + 1);
  }, [ref]);
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.focus();
    console.log(ref2.current.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1.current, ref2.current, props.someOtherRefs, props.color]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1?.current?.focus();
    console.log(ref2?.current?.textContent);
    alert(props.someOtherRefs.current.innerHTML);
    fetch(props.color);
  }, [ref1?.current, ref2?.current, props.someOtherRefs, props.color]);
}
" time="0.031">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ activeTab }) {
  const ref1 = useRef();
  const ref2 = useRef();
  useEffect(() =&gt; {
    ref1.current.scrollTop = 0;
    ref2.current.scrollTop = 0;
  }, [ref1.current, ref2.current, activeTab]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({ activeTab, initY }) {
  const ref1 = useRef();
  const ref2 = useRef();
  const fn = useCallback(() =&gt; {
    ref1.current.scrollTop = initY;
    ref2.current.scrollTop = initY;
  }, [ref1.current, ref2.current, activeTab, initY]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const ref = useRef();
  useEffect(() =&gt; {
    console.log(ref.current);
  }, [ref.current, ref]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
const MyComponent = forwardRef((props, ref) =&gt; {
  useImperativeHandle(ref, () =&gt; ({
    focus() {
      alert(props.hello);
    }
  }), [])
});
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.onChange) {
      props.onChange();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props?.onChange) {
      props?.onChange();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    function play() {
      props.onPlay();
    }
    function pause() {
      props.onPause();
    }
  }, []);
}
" time="0.027">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    if (props.foo.onChange) {
      props.foo.onChange();
    }
  }, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, [skillsCount, props.isEditMode, props.toggleEditMode]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const [skillsCount] = useState();
  useEffect(() =&gt; {
    if (skillsCount === 0 &amp;&amp; !props.isEditMode) {
      props.toggleEditMode();
    }
  }, []);
}
" time="0.008">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    externalCall(props);
    props.onChange();
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  useEffect(() =&gt; {
    props.onChange();
    externalCall(props);
  }, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let value4;
  let asyncValue;
  useEffect(() =&gt; {
    if (value4) {
      value = {};
    }
    value2 = 100;
    value = 43;
    value4 = true;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, []);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let value;
  let value2;
  let value3;
  let asyncValue;
  useEffect(() =&gt; {
    value = {};
    value2 = 100;
    value = 43;
    console.log(value2);
    console.log(value3);
    setTimeout(() =&gt; {
      asyncValue = 100;
    });
  }, [value, value2, value3]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef?.current?.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef?.current?.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, []);
  return &lt;div ref={myRef} /&gt;;
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const myRef = useRef();
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  });
  return &lt;div ref={myRef} /&gt;;
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
    return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
  }, [myRef]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function useMyThing(myRef) {
  useEffect(() =&gt; {
    const handleMouse = () =&gt; {};
    myRef.current.addEventListener(&apos;mousemove&apos;, handleMouse);
    myRef.current.addEventListener(&apos;mousein&apos;, handleMouse);
    return function() {
      setTimeout(() =&gt; {
        myRef.current.removeEventListener(&apos;mousemove&apos;, handleMouse);
        myRef.current.removeEventListener(&apos;mousein&apos;, handleMouse);
      });
    }
  }, [myRef]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function useMyThing(myRef, active) {
  useEffect(() =&gt; {
    const handleMove = () =&gt; {};
    if (active) {
      myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
      return function() {
        setTimeout(() =&gt; {
          myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
        });
      }
    }
  }, [myRef, active]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
        function MyComponent() {
          const myRef = useRef();
          useLayoutEffect_SAFE_FOR_SSR(() =&gt; {
            const handleMove = () =&gt; {};
            myRef.current.addEventListener(&apos;mousemove&apos;, handleMove);
            return () =&gt; myRef.current.removeEventListener(&apos;mousemove&apos;, handleMove);
          });
          return &lt;div ref={myRef} /&gt;;
        }
      " time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local1 = 42;
  const local2 = &apos;42&apos;;
  const local3 = null;
  const local4 = {};
  useEffect(() =&gt; {
    console.log(local1);
    console.log(local2);
    console.log(local3);
    console.log(local4);
  }, [local1, local3]);
}
" time="0.02">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [window]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;

function MyComponent() {
  useEffect(() =&gt; {
    console.log(MutableStore.hello);
  }, [MutableStore.hello]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      console.log(MutableStore.hello.world, props.foo, x, y, z, global.stuff);
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    useEffect(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.017">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore.hello.world, props.foo, x, y, z, global.stuff]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
import MutableStore from &apos;store&apos;;
let z = {};

function MyComponent(props) {
  let x = props.foo;
  {
    let y = props.bar;
    const fn = useCallback(() =&gt; {
      // nothing
    }, [MutableStore?.hello?.world, props.foo, x, y, z, global?.stuff]);
  }
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    setTimeout(() =&gt; console.log(taint));
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.026">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  function handleChange() {}

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let [, dispatch] = React.useReducer();
  let taint = props.foo;

  // Shouldn&apos;t affect anything
  const handleChange = () =&gt; {};

  function handleNext1(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = (value) =&gt; {
    setState(taint(value));
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function(value) {
    console.log(taint);
    dispatch({ type: &apos;x&apos;, value });
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, []);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, []);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, []);
}
" time="0.028">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();

  function handleNext(value) {
    setState(value);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();

  const handleNext = (value) =&gt; {
    setState(value);
  };

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);

  return &lt;div onClick={handleNext} /&gt;;
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    return Store.subscribe(handleNext2);
  }, [handleNext2]);
  useMemo(() =&gt; {
    return Store.subscribe(handleNext3);
  }, [handleNext3]);
}
" time="0.006">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  function handleNext1() {
    console.log(&apos;hello&apos;);
  }
  const handleNext2 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  let handleNext3 = function() {
    console.log(&apos;hello&apos;);
  };
  useEffect(() =&gt; {
    handleNext1();
    return Store.subscribe(() =&gt; handleNext1());
  }, [handleNext1]);
  useLayoutEffect(() =&gt; {
    handleNext2();
    return Store.subscribe(() =&gt; handleNext2());
  }, [handleNext2]);
  useMemo(() =&gt; {
    handleNext3();
    return Store.subscribe(() =&gt; handleNext3());
  }, [handleNext3]);
  return (
    &lt;div
      onClick={() =&gt; {
        handleNext1();
        setTimeout(handleNext2);
        setTimeout(() =&gt; {
          handleNext3();
        });
      }}
    /&gt;
  );
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  const handleNext1 = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  function handleNext2() {
    console.log(&apos;hello&apos;);
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
  useEffect(() =&gt; {
    return Store.subscribe(handleNext1);
    return Store.subscribe(handleNext2);
  }, [handleNext1, handleNext2]);
}
" time="0.025">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let handleNext = () =&gt; {
    console.log(&apos;hello&apos;);
  };
  if (props.foo) {
    handleNext = () =&gt; {
      console.log(&apos;hello&apos;);
    };
  }
  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let [, setState] = useState();
  let taint = props.foo;

  function handleNext(value) {
    let value2 = value * taint;
    setState(value2);
    console.log(&apos;hello&apos;);
  }

  useEffect(() =&gt; {
    return Store.subscribe(handleNext);
  }, [handleNext]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let [increment, setIncrement] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  let [count, setCount] = useState(0);
  let increment = useCustomHook();

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.015">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter({ step }) {
  let [count, setCount] = useState(0);

  function increment(x) {
    return x + step;
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; increment(count));
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [increment]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter({ increment }) {
  let [count, setCount] = useState(0);

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      setCount(count =&gt; count + increment);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Counter() {
  const [count, setCount] = useState(0);

  function tick() {
    setCount(count + 1);
  }

  useEffect(() =&gt; {
    let id = setInterval(() =&gt; {
      tick();
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts() {
  useEffect(() =&gt; {
    alert(podcasts);
  }, []);
  let [podcasts, setPodcasts] = useState(null);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ api: { fetchPodcasts }, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.018">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ fetchPodcasts, fetchPodcasts2, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      console.log(id);
      fetchPodcasts(id).then(setPodcasts);
      fetchPodcasts2(id).then(setPodcasts);
    });
  }, [id]);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts(id).then(setPodcasts);
  }, [id]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Podcasts({ fetchPodcasts, id }) {
  let [podcasts, setPodcasts] = useState(null);
  useEffect(() =&gt; {
    console.log(fetchPodcasts);
    fetchPodcasts?.(id).then(setPodcasts);
  }, [id]);
}
" time="0.009">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Thing() {
  useEffect(() =&gt; {
    const fetchData = async () =&gt; {};
    fetchData();
  }, [fetchData]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Hello() {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    setState({});
  });
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Hello() {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData.then(setData);
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Hello({ country }) {
  const [data, setData] = useState(0);
  useEffect(() =&gt; {
    fetchData(country).then(setData);
  });
}
" time="0.011">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Hello({ prop1, prop2 }) {
  const [state, setState] = useState(0);
  useEffect(() =&gt; {
    if (prop1) {
      setState(prop2);
    }
  });
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Thing() {
  useEffect(async () =&gt; {}, []);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Thing() {
  useEffect(async () =&gt; {});
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Example() {
  const foo = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Example({ prop }) {
  const foo = useCallback(() =&gt; {
    prop.hello(foo);
  }, [foo]);
  const bar = useCallback(() =&gt; {
    foo();
  }, [foo]);
}
" time="0.014">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  function myEffect() {
    console.log(local);
  }
  useEffect(myEffect, []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.031">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = function() {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = () =&gt; {
    otherThing();
  };
  const otherThing = () =&gt; {
    console.log(local);
  };
  useEffect(myEffect, []);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, []);
}
" time="0.004">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  const myEffect = debounce(() =&gt; {
    console.log(local);
  }, delay);
  useEffect(myEffect, [local]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent({myEffect}) {
  useEffect(myEffect, []);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(debounce(() =&gt; {
    console.log(local);
  }, delay), []);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent() {
  const local = {};
  useEffect(() =&gt; {
    console.log(local);
  }, []);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function MyComponent(props) {
  let foo = {}
  useEffect(() =&gt; {
    foo.bar.baz = 43;
    props.foo.bar.baz = 1;
  }, []);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = [];
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = () =&gt; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = function bar(){};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.012">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = class {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = true ? {} : &quot;fine&quot;;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = bar || {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = bar ?? {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = bar &amp;&amp; {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.007">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = bar ? baz ? {} : null : null;
  useMemo(() =&gt; foo, [foo]);
}
" time="0.001">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  let foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  var foo = {};
  useMemo(() =&gt; foo, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useCallback(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.013">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Component() {
  const foo = {};
  useImperativeHandle(
    ref,
    () =&gt; {
       console.log(foo);
    },
    [foo]
  );
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo(section) {
  const foo = section.section_components?.edges ?? [];
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo(section) {
  const foo = {};
  console.log(foo);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.01">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = &lt;&gt;Hi!&lt;/&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = &lt;div&gt;Hi!&lt;/div&gt;;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = bar = {};
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.005">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = new String(&apos;foo&apos;); // Note &apos;foo&apos; will be boxed, and thus an object and thus compared by reference.
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.003">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = new Map([]);
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = /reg/;
  useMemo(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.002">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  class Bar {};
  useMemo(() =&gt; {
    console.log(new Bar());
  }, [Bar]);
}
" time="0.104">
    </testcase>
    <testcase classname="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" name="react-hooks parser: @typescript-eslint/parser@^5.0.0-0 invalid 
function Foo() {
  const foo = {};
  useLayoutEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
  useEffect(() =&gt; {
    console.log(foo);
  }, [foo]);
}
" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationTextarea-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:39" time="3.4" tests="35">
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with server string render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with server string render" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with server stream render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with server stream render" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with clean client render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with clean client render" time="0.03">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with client render on top of good server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with client render on top of good server markup" time="0.124">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with client render on top of bad server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and an onChange with client render on top of bad server markup" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with server string render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with server string render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with server stream render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with server stream render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with clean client render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with clean client render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with client render on top of good server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with client render on top of good server markup" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with client render on top of bad server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a value of undefined with client render on top of bad server markup" time="0.156">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with server string render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with server string render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with server stream render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with server stream render" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with clean client render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with clean client render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with client render on top of good server markup" time="0.128">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and readOnly with client render on top of bad server markup" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with server string render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with server string render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with server stream render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with server stream render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with clean client render" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with clean client render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with client render on top of good server markup" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a value and no onChange/readOnly with client render on top of bad server markup" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with server string render" name="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with server string render" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with server stream render" name="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with server stream render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with clean client render" name="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with clean client render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with client render on top of good server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with client render on top of good server markup" time="0.12">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with client render on top of bad server markup" name="ReactDOMServerIntegrationTextarea renders a textarea with a defaultValue with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with server string render" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with server string render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with server stream render" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with server stream render" time="0.095">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with clean client render" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with clean client render" time="0.079">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with client render on top of good server markup" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with client render on top of good server markup" time="0.137">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with client render on top of bad server markup" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue with client render on top of bad server markup" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with server string render" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with server stream render" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with server stream render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with clean client render" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with clean client render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with client render on top of good server markup" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with client render on top of good server markup" time="0.116">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with client render on top of bad server markup" name="ReactDOMServerIntegrationTextarea renders a textarea value overriding defaultValue no matter the prop order with client render on top of bad server markup" time="0.117">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationBasic-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:37" time="5.174" tests="50">
    <testcase classname="ReactDOMServerIntegration basic rendering renders a blank div with server string render" name="ReactDOMServerIntegration basic rendering renders a blank div with server string render" time="0.195">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a blank div with server stream render" name="ReactDOMServerIntegration basic rendering renders a blank div with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a blank div with clean client render" name="ReactDOMServerIntegration basic rendering renders a blank div with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a blank div with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders a blank div with client render on top of good server markup" time="0.138">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a blank div with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders a blank div with client render on top of bad server markup" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag with server string render" name="ReactDOMServerIntegration basic rendering renders a self-closing tag with server string render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag with server stream render" name="ReactDOMServerIntegration basic rendering renders a self-closing tag with server stream render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag with clean client render" name="ReactDOMServerIntegration basic rendering renders a self-closing tag with clean client render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders a self-closing tag with client render on top of good server markup" time="0.13">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders a self-closing tag with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with server string render" name="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with server string render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with server stream render" name="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with server stream render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with clean client render" name="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with clean client render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with client render on top of good server markup" time="0.097">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders a self-closing tag as a child with client render on top of bad server markup" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a string with server string render" name="ReactDOMServerIntegration basic rendering renders a string with server string render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a string with server stream render" name="ReactDOMServerIntegration basic rendering renders a string with server stream render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a string with clean client render" name="ReactDOMServerIntegration basic rendering renders a string with clean client render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a string with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders a string with client render on top of good server markup" time="0.112">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a string with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders a string with client render on top of bad server markup" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a number with server string render" name="ReactDOMServerIntegration basic rendering renders a number with server string render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a number with server stream render" name="ReactDOMServerIntegration basic rendering renders a number with server stream render" time="0.117">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a number with clean client render" name="ReactDOMServerIntegration basic rendering renders a number with clean client render" time="0.092">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a number with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders a number with client render on top of good server markup" time="0.13">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a number with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders a number with client render on top of bad server markup" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with one child with server string render" name="ReactDOMServerIntegration basic rendering renders an array with one child with server string render" time="0.092">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with one child with server stream render" name="ReactDOMServerIntegration basic rendering renders an array with one child with server stream render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with one child with clean client render" name="ReactDOMServerIntegration basic rendering renders an array with one child with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with one child with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders an array with one child with client render on top of good server markup" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with one child with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders an array with one child with client render on top of bad server markup" time="0.079">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with several children with server string render" name="ReactDOMServerIntegration basic rendering renders an array with several children with server string render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with several children with server stream render" name="ReactDOMServerIntegration basic rendering renders an array with several children with server stream render" time="0.092">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with several children with clean client render" name="ReactDOMServerIntegration basic rendering renders an array with several children with clean client render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with several children with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders an array with several children with client render on top of good server markup" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an array with several children with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders an array with several children with client render on top of bad server markup" time="0.11">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a nested array with server string render" name="ReactDOMServerIntegration basic rendering renders a nested array with server string render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a nested array with server stream render" name="ReactDOMServerIntegration basic rendering renders a nested array with server stream render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a nested array with clean client render" name="ReactDOMServerIntegration basic rendering renders a nested array with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a nested array with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders a nested array with client render on top of good server markup" time="0.163">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders a nested array with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders a nested array with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an iterable with server string render" name="ReactDOMServerIntegration basic rendering renders an iterable with server string render" time="0.114">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an iterable with server stream render" name="ReactDOMServerIntegration basic rendering renders an iterable with server stream render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an iterable with clean client render" name="ReactDOMServerIntegration basic rendering renders an iterable with clean client render" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an iterable with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders an iterable with client render on top of good server markup" time="0.152">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders an iterable with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders an iterable with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders emptyish values with server string render" name="ReactDOMServerIntegration basic rendering renders emptyish values with server string render" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders emptyish values with server stream render" name="ReactDOMServerIntegration basic rendering renders emptyish values with server stream render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders emptyish values with clean client render" name="ReactDOMServerIntegration basic rendering renders emptyish values with clean client render" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders emptyish values with client render on top of good server markup" name="ReactDOMServerIntegration basic rendering renders emptyish values with client render on top of good server markup" time="0.516">
    </testcase>
    <testcase classname="ReactDOMServerIntegration basic rendering renders emptyish values with client render on top of bad server markup" name="ReactDOMServerIntegration basic rendering renders emptyish values with client render on top of bad server markup" time="0.056">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMInput-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:34" time="9.186" tests="114">
    <testcase classname="ReactDOMInput should warn for controlled value of 0 with missing onChange" name="ReactDOMInput should warn for controlled value of 0 with missing onChange" time="0.114">
    </testcase>
    <testcase classname="ReactDOMInput should warn for controlled value of &quot;&quot; with missing onChange" name="ReactDOMInput should warn for controlled value of &quot;&quot; with missing onChange" time="0.035">
    </testcase>
    <testcase classname="ReactDOMInput should warn for controlled value of &quot;0&quot; with missing onChange" name="ReactDOMInput should warn for controlled value of &quot;0&quot; with missing onChange" time="0.063">
    </testcase>
    <testcase classname="ReactDOMInput should warn for controlled value of false with missing onChange" name="ReactDOMInput should warn for controlled value of false with missing onChange" time="0.061">
    </testcase>
    <testcase classname="ReactDOMInput should warn with checked and no onChange handler with readOnly specified" name="ReactDOMInput should warn with checked and no onChange handler with readOnly specified" time="0.057">
    </testcase>
    <testcase classname="ReactDOMInput should not warn about missing onChange in uncontrolled inputs" name="ReactDOMInput should not warn about missing onChange in uncontrolled inputs" time="0.078">
    </testcase>
    <testcase classname="ReactDOMInput should not warn with value and onInput handler" name="ReactDOMInput should not warn with value and onInput handler" time="0.043">
    </testcase>
    <testcase classname="ReactDOMInput should properly control a value even if no event listener exists" name="ReactDOMInput should properly control a value even if no event listener exists" time="0.065">
    </testcase>
    <testcase classname="ReactDOMInput should control a value in reentrant events" name="ReactDOMInput should control a value in reentrant events" time="0.068">
    </testcase>
    <testcase classname="ReactDOMInput should control values in reentrant events with different targets" name="ReactDOMInput should control values in reentrant events with different targets" time="0.123">
    </testcase>
    <testcase classname="ReactDOMInput switching text inputs between numeric and string numbers does change the number 2 to &quot;2.0&quot; with no change handler" name="ReactDOMInput switching text inputs between numeric and string numbers does change the number 2 to &quot;2.0&quot; with no change handler" time="0.057">
    </testcase>
    <testcase classname="ReactDOMInput switching text inputs between numeric and string numbers does change the string &quot;2&quot; to &quot;2.0&quot; with no change handler" name="ReactDOMInput switching text inputs between numeric and string numbers does change the string &quot;2&quot; to &quot;2.0&quot; with no change handler" time="0.064">
    </testcase>
    <testcase classname="ReactDOMInput switching text inputs between numeric and string numbers changes the number 2 to &quot;2.0&quot; using a change handler" name="ReactDOMInput switching text inputs between numeric and string numbers changes the number 2 to &quot;2.0&quot; using a change handler" time="0.067">
    </testcase>
    <testcase classname="ReactDOMInput does change the string &quot;.98&quot; to &quot;0.98&quot; with no change handler" name="ReactDOMInput does change the string &quot;.98&quot; to &quot;0.98&quot; with no change handler" time="0.058">
    </testcase>
    <testcase classname="ReactDOMInput performs a state change from &quot;&quot; to 0" name="ReactDOMInput performs a state change from &quot;&quot; to 0" time="0.037">
    </testcase>
    <testcase classname="ReactDOMInput updates the value on radio buttons from &quot;&quot; to 0" name="ReactDOMInput updates the value on radio buttons from &quot;&quot; to 0" time="0.07">
    </testcase>
    <testcase classname="ReactDOMInput updates the value on checkboxes from &quot;&quot; to 0" name="ReactDOMInput updates the value on checkboxes from &quot;&quot; to 0" time="0.051">
    </testcase>
    <testcase classname="ReactDOMInput distinguishes precision for extra zeroes in string number values" name="ReactDOMInput distinguishes precision for extra zeroes in string number values" time="0.075">
    </testcase>
    <testcase classname="ReactDOMInput should display `defaultValue` of number 0" name="ReactDOMInput should display `defaultValue` of number 0" time="0.053">
    </testcase>
    <testcase classname="ReactDOMInput only assigns defaultValue if it changes" name="ReactDOMInput only assigns defaultValue if it changes" time="0.052">
    </testcase>
    <testcase classname="ReactDOMInput should display &quot;true&quot; for `defaultValue` of `true`" name="ReactDOMInput should display &quot;true&quot; for `defaultValue` of `true`" time="0.057">
    </testcase>
    <testcase classname="ReactDOMInput should display &quot;false&quot; for `defaultValue` of `false`" name="ReactDOMInput should display &quot;false&quot; for `defaultValue` of `false`" time="0.072">
    </testcase>
    <testcase classname="ReactDOMInput should update `defaultValue` for uncontrolled input" name="ReactDOMInput should update `defaultValue` for uncontrolled input" time="0.043">
    </testcase>
    <testcase classname="ReactDOMInput should update `defaultValue` for uncontrolled date/time input" name="ReactDOMInput should update `defaultValue` for uncontrolled date/time input" time="0.061">
    </testcase>
    <testcase classname="ReactDOMInput should take `defaultValue` when changing to uncontrolled input" name="ReactDOMInput should take `defaultValue` when changing to uncontrolled input" time="0.064">
    </testcase>
    <testcase classname="ReactDOMInput should render defaultValue for SSR" name="ReactDOMInput should render defaultValue for SSR" time="0.061">
    </testcase>
    <testcase classname="ReactDOMInput should render value for SSR" name="ReactDOMInput should render value for SSR" time="0.056">
    </testcase>
    <testcase classname="ReactDOMInput should render name attribute if it is supplied" name="ReactDOMInput should render name attribute if it is supplied" time="0.065">
    </testcase>
    <testcase classname="ReactDOMInput should render name attribute if it is supplied for SSR" name="ReactDOMInput should render name attribute if it is supplied for SSR" time="0.046">
    </testcase>
    <testcase classname="ReactDOMInput should not render name attribute if it is not supplied" name="ReactDOMInput should not render name attribute if it is not supplied" time="0.035">
    </testcase>
    <testcase classname="ReactDOMInput should not render name attribute if it is not supplied for SSR" name="ReactDOMInput should not render name attribute if it is not supplied for SSR" time="0.066">
    </testcase>
    <testcase classname="ReactDOMInput should display &quot;foobar&quot; for `defaultValue` of `objToString`" name="ReactDOMInput should display &quot;foobar&quot; for `defaultValue` of `objToString`" time="0.064">
    </testcase>
    <testcase classname="ReactDOMInput should throw for date inputs if `defaultValue` is an object where valueOf() throws" name="ReactDOMInput should throw for date inputs if `defaultValue` is an object where valueOf() throws" time="0.058">
    </testcase>
    <testcase classname="ReactDOMInput should throw for text inputs if `defaultValue` is an object where valueOf() throws" name="ReactDOMInput should throw for text inputs if `defaultValue` is an object where valueOf() throws" time="0.047">
    </testcase>
    <testcase classname="ReactDOMInput should throw for date inputs if `value` is an object where valueOf() throws" name="ReactDOMInput should throw for date inputs if `value` is an object where valueOf() throws" time="0.052">
    </testcase>
    <testcase classname="ReactDOMInput should throw for text inputs if `value` is an object where valueOf() throws" name="ReactDOMInput should throw for text inputs if `value` is an object where valueOf() throws" time="0.049">
    </testcase>
    <testcase classname="ReactDOMInput should display `value` of number 0" name="ReactDOMInput should display `value` of number 0" time="0.077">
    </testcase>
    <testcase classname="ReactDOMInput should allow setting `value` to `true`" name="ReactDOMInput should allow setting `value` to `true`" time="0.053">
    </testcase>
    <testcase classname="ReactDOMInput should allow setting `value` to `false`" name="ReactDOMInput should allow setting `value` to `false`" time="0.072">
    </testcase>
    <testcase classname="ReactDOMInput should allow setting `value` to `objToString`" name="ReactDOMInput should allow setting `value` to `objToString`" time="0.109">
    </testcase>
    <testcase classname="ReactDOMInput should not incur unnecessary DOM mutations" name="ReactDOMInput should not incur unnecessary DOM mutations" time="0.062">
    </testcase>
    <testcase classname="ReactDOMInput should not incur unnecessary DOM mutations for numeric type conversion" name="ReactDOMInput should not incur unnecessary DOM mutations for numeric type conversion" time="0.056">
    </testcase>
    <testcase classname="ReactDOMInput should not incur unnecessary DOM mutations for the boolean type conversion" name="ReactDOMInput should not incur unnecessary DOM mutations for the boolean type conversion" time="0.045">
    </testcase>
    <testcase classname="ReactDOMInput should properly control a value of number `0`" name="ReactDOMInput should properly control a value of number `0`" time="0.059">
    </testcase>
    <testcase classname="ReactDOMInput should properly control 0.0 for a text input" name="ReactDOMInput should properly control 0.0 for a text input" time="0.044">
    </testcase>
    <testcase classname="ReactDOMInput should properly control 0.0 for a number input" name="ReactDOMInput should properly control 0.0 for a number input" time="0.051">
    </testcase>
    <testcase classname="ReactDOMInput should properly transition from an empty value to 0" name="ReactDOMInput should properly transition from an empty value to 0" time="0.093">
    </testcase>
    <testcase classname="ReactDOMInput should properly transition from 0 to an empty value" name="ReactDOMInput should properly transition from 0 to an empty value" time="0.046">
    </testcase>
    <testcase classname="ReactDOMInput should properly transition a text input from 0 to an empty 0.0" name="ReactDOMInput should properly transition a text input from 0 to an empty 0.0" time="0.049">
    </testcase>
    <testcase classname="ReactDOMInput should properly transition a number input from &quot;&quot; to 0" name="ReactDOMInput should properly transition a number input from &quot;&quot; to 0" time="0.05">
    </testcase>
    <testcase classname="ReactDOMInput should properly transition a number input from &quot;&quot; to &quot;0&quot;" name="ReactDOMInput should properly transition a number input from &quot;&quot; to &quot;0&quot;" time="0.064">
    </testcase>
    <testcase classname="ReactDOMInput should have the correct target value" name="ReactDOMInput should have the correct target value" time="0.071">
    </testcase>
    <testcase classname="ReactDOMInput should restore uncontrolled inputs to last defaultValue upon reset" name="ReactDOMInput should restore uncontrolled inputs to last defaultValue upon reset" time="0.077">
    </testcase>
    <testcase classname="ReactDOMInput should not set a value for submit buttons unnecessarily" name="ReactDOMInput should not set a value for submit buttons unnecessarily" time="0.043">
    </testcase>
    <testcase classname="ReactDOMInput should remove the value attribute on submit inputs when value is updated to undefined" name="ReactDOMInput should remove the value attribute on submit inputs when value is updated to undefined" time="0.057">
    </testcase>
    <testcase classname="ReactDOMInput should remove the value attribute on reset inputs when value is updated to undefined" name="ReactDOMInput should remove the value attribute on reset inputs when value is updated to undefined" time="0.079">
    </testcase>
    <testcase classname="ReactDOMInput should set a value on a submit input" name="ReactDOMInput should set a value on a submit input" time="0.072">
    </testcase>
    <testcase classname="ReactDOMInput should not set an undefined value on a submit input" name="ReactDOMInput should not set an undefined value on a submit input" time="0.068">
    </testcase>
    <testcase classname="ReactDOMInput should not set an undefined value on a reset input" name="ReactDOMInput should not set an undefined value on a reset input" time="0.048">
    </testcase>
    <testcase classname="ReactDOMInput should not set a null value on a submit input" name="ReactDOMInput should not set a null value on a submit input" time="0.068">
    </testcase>
    <testcase classname="ReactDOMInput should not set a null value on a reset input" name="ReactDOMInput should not set a null value on a reset input" time="0.042">
    </testcase>
    <testcase classname="ReactDOMInput should set a value on a reset input" name="ReactDOMInput should set a value on a reset input" time="0.05">
    </testcase>
    <testcase classname="ReactDOMInput should set an empty string value on a submit input" name="ReactDOMInput should set an empty string value on a submit input" time="0.047">
    </testcase>
    <testcase classname="ReactDOMInput should set an empty string value on a reset input" name="ReactDOMInput should set an empty string value on a reset input" time="0.057">
    </testcase>
    <testcase classname="ReactDOMInput should control radio buttons" name="ReactDOMInput should control radio buttons" time="0.094">
    </testcase>
    <testcase classname="ReactDOMInput should check the correct radio when the selected name moves" name="ReactDOMInput should check the correct radio when the selected name moves" time="0.067">
    </testcase>
    <testcase classname="ReactDOMInput should control radio buttons if the tree updates during render" name="ReactDOMInput should control radio buttons if the tree updates during render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMInput should warn with value and no onChange handler and readOnly specified" name="ReactDOMInput should warn with value and no onChange handler and readOnly specified" time="0.096">
    </testcase>
    <testcase classname="ReactDOMInput should have a this value of undefined if bind is not used" name="ReactDOMInput should have a this value of undefined if bind is not used" time="0.138">
    </testcase>
    <testcase classname="ReactDOMInput should update defaultValue to empty string" name="ReactDOMInput should update defaultValue to empty string" time="0.048">
    </testcase>
    <testcase classname="ReactDOMInput should warn if value is null" name="ReactDOMInput should warn if value is null" time="0.069">
    </testcase>
    <testcase classname="ReactDOMInput should warn if checked and defaultChecked props are specified" name="ReactDOMInput should warn if checked and defaultChecked props are specified" time="0.077">
    </testcase>
    <testcase classname="ReactDOMInput should warn if value and defaultValue props are specified" name="ReactDOMInput should warn if value and defaultValue props are specified" time="0.072">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled input switches to uncontrolled (value is undefined)" name="ReactDOMInput should warn if controlled input switches to uncontrolled (value is undefined)" time="0.086">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled input switches to uncontrolled (value is null)" name="ReactDOMInput should warn if controlled input switches to uncontrolled (value is null)" time="0.036">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled input switches to uncontrolled with defaultValue" name="ReactDOMInput should warn if controlled input switches to uncontrolled with defaultValue" time="0.077">
    </testcase>
    <testcase classname="ReactDOMInput should warn if uncontrolled input (value is undefined) switches to controlled" name="ReactDOMInput should warn if uncontrolled input (value is undefined) switches to controlled" time="0.103">
    </testcase>
    <testcase classname="ReactDOMInput should warn if uncontrolled input (value is null) switches to controlled" name="ReactDOMInput should warn if uncontrolled input (value is null) switches to controlled" time="0.042">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled checkbox switches to uncontrolled (checked is undefined)" name="ReactDOMInput should warn if controlled checkbox switches to uncontrolled (checked is undefined)" time="0.057">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled checkbox switches to uncontrolled (checked is null)" name="ReactDOMInput should warn if controlled checkbox switches to uncontrolled (checked is null)" time="0.055">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled checkbox switches to uncontrolled with defaultChecked" name="ReactDOMInput should warn if controlled checkbox switches to uncontrolled with defaultChecked" time="0.058">
    </testcase>
    <testcase classname="ReactDOMInput should warn if uncontrolled checkbox (checked is undefined) switches to controlled" name="ReactDOMInput should warn if uncontrolled checkbox (checked is undefined) switches to controlled" time="0.071">
    </testcase>
    <testcase classname="ReactDOMInput should warn if uncontrolled checkbox (checked is null) switches to controlled" name="ReactDOMInput should warn if uncontrolled checkbox (checked is null) switches to controlled" time="0.063">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled radio switches to uncontrolled (checked is undefined)" name="ReactDOMInput should warn if controlled radio switches to uncontrolled (checked is undefined)" time="0.085">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled radio switches to uncontrolled (checked is null)" name="ReactDOMInput should warn if controlled radio switches to uncontrolled (checked is null)" time="0.054">
    </testcase>
    <testcase classname="ReactDOMInput should warn if controlled radio switches to uncontrolled with defaultChecked" name="ReactDOMInput should warn if controlled radio switches to uncontrolled with defaultChecked" time="0.071">
    </testcase>
    <testcase classname="ReactDOMInput should warn if uncontrolled radio (checked is undefined) switches to controlled" name="ReactDOMInput should warn if uncontrolled radio (checked is undefined) switches to controlled" time="0.041">
    </testcase>
    <testcase classname="ReactDOMInput should warn if uncontrolled radio (checked is null) switches to controlled" name="ReactDOMInput should warn if uncontrolled radio (checked is null) switches to controlled" time="0.081">
    </testcase>
    <testcase classname="ReactDOMInput should not warn if radio value changes but never becomes controlled" name="ReactDOMInput should not warn if radio value changes but never becomes controlled" time="0.074">
    </testcase>
    <testcase classname="ReactDOMInput should not warn if radio value changes but never becomes uncontrolled" name="ReactDOMInput should not warn if radio value changes but never becomes uncontrolled" time="0.086">
    </testcase>
    <testcase classname="ReactDOMInput should warn if radio checked false changes to become uncontrolled" name="ReactDOMInput should warn if radio checked false changes to become uncontrolled" time="0.057">
    </testcase>
    <testcase classname="ReactDOMInput sets type, step, min, max before value always" name="ReactDOMInput sets type, step, min, max before value always" time="0.073">
    </testcase>
    <testcase classname="ReactDOMInput sets value properly with type coming later in props" name="ReactDOMInput sets value properly with type coming later in props" time="0.033">
    </testcase>
    <testcase classname="ReactDOMInput does not raise a validation warning when it switches types" name="ReactDOMInput does not raise a validation warning when it switches types" time="0.084">
    </testcase>
    <testcase classname="ReactDOMInput resets value of date/time input to fix bugs in iOS Safari" name="ReactDOMInput resets value of date/time input to fix bugs in iOS Safari" time="0.045">
    </testcase>
    <testcase classname="ReactDOMInput assigning the value attribute on controlled inputs always sets the attribute when values change on text inputs" name="ReactDOMInput assigning the value attribute on controlled inputs always sets the attribute when values change on text inputs" time="0.075">
    </testcase>
    <testcase classname="ReactDOMInput assigning the value attribute on controlled inputs does not set the value attribute on number inputs if focused" name="ReactDOMInput assigning the value attribute on controlled inputs does not set the value attribute on number inputs if focused" time="0.084">
    </testcase>
    <testcase classname="ReactDOMInput assigning the value attribute on controlled inputs sets the value attribute on number inputs on blur" name="ReactDOMInput assigning the value attribute on controlled inputs sets the value attribute on number inputs on blur" time="0.044">
    </testcase>
    <testcase classname="ReactDOMInput assigning the value attribute on controlled inputs an uncontrolled number input will not update the value attribute on blur" name="ReactDOMInput assigning the value attribute on controlled inputs an uncontrolled number input will not update the value attribute on blur" time="0.068">
    </testcase>
    <testcase classname="ReactDOMInput assigning the value attribute on controlled inputs an uncontrolled text input will not update the value attribute on blur" name="ReactDOMInput assigning the value attribute on controlled inputs an uncontrolled text input will not update the value attribute on blur" time="0.075">
    </testcase>
    <testcase classname="ReactDOMInput setting a controlled input to undefined reverts the value attribute to the initial value" name="ReactDOMInput setting a controlled input to undefined reverts the value attribute to the initial value" time="0.066">
    </testcase>
    <testcase classname="ReactDOMInput setting a controlled input to undefined preserves the value property" name="ReactDOMInput setting a controlled input to undefined preserves the value property" time="0.068">
    </testcase>
    <testcase classname="ReactDOMInput setting a controlled input to null reverts the value attribute to the initial value" name="ReactDOMInput setting a controlled input to null reverts the value attribute to the initial value" time="0.114">
    </testcase>
    <testcase classname="ReactDOMInput setting a controlled input to null preserves the value property" name="ReactDOMInput setting a controlled input to null preserves the value property" time="0.164">
    </testcase>
    <testcase classname="ReactDOMInput When given a Symbol value treats initial Symbol value as an empty string" name="ReactDOMInput When given a Symbol value treats initial Symbol value as an empty string" time="0.104">
    </testcase>
    <testcase classname="ReactDOMInput When given a Symbol value treats updated Symbol value as an empty string" name="ReactDOMInput When given a Symbol value treats updated Symbol value as an empty string" time="0.184">
    </testcase>
    <testcase classname="ReactDOMInput When given a Symbol value treats initial Symbol defaultValue as an empty string" name="ReactDOMInput When given a Symbol value treats initial Symbol defaultValue as an empty string" time="0.17">
    </testcase>
    <testcase classname="ReactDOMInput When given a Symbol value treats updated Symbol defaultValue as an empty string" name="ReactDOMInput When given a Symbol value treats updated Symbol defaultValue as an empty string" time="0.103">
    </testcase>
    <testcase classname="ReactDOMInput When given a function value treats initial function value as an empty string" name="ReactDOMInput When given a function value treats initial function value as an empty string" time="0.112">
    </testcase>
    <testcase classname="ReactDOMInput When given a function value treats updated function value as an empty string" name="ReactDOMInput When given a function value treats updated function value as an empty string" time="0.047">
    </testcase>
    <testcase classname="ReactDOMInput When given a function value treats initial function defaultValue as an empty string" name="ReactDOMInput When given a function value treats initial function defaultValue as an empty string" time="0.066">
    </testcase>
    <testcase classname="ReactDOMInput When given a function value treats updated function defaultValue as an empty string" name="ReactDOMInput When given a function value treats updated function defaultValue as an empty string" time="0.045">
    </testcase>
    <testcase classname="ReactDOMInput checked inputs without a value property does not add &quot;on&quot; in absence of value on a checkbox" name="ReactDOMInput checked inputs without a value property does not add &quot;on&quot; in absence of value on a checkbox" time="0.052">
    </testcase>
    <testcase classname="ReactDOMInput checked inputs without a value property does not add &quot;on&quot; in absence of value on a radio" name="ReactDOMInput checked inputs without a value property does not add &quot;on&quot; in absence of value on a radio" time="0.069">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationReconnecting-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:36" time="7.229" tests="54">
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect ES6 Class to ES6 Class" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect ES6 Class to ES6 Class" time="0.114">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Pure Component to ES6 Class" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Pure Component to ES6 Class" time="0.146">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Bare Element to ES6 Class" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Bare Element to ES6 Class" time="0.094">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect ES6 Class to Pure Component" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect ES6 Class to Pure Component" time="0.137">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Pure Component to Pure Component" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Pure Component to Pure Component" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Bare Element to Pure Component" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Bare Element to Pure Component" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect ES6 Class to Bare Element" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect ES6 Class to Bare Element" time="0.156">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Pure Component to Bare Element" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Pure Component to Bare Element" time="0.161">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Bare Element to Bare Element" name="ReactDOMServerIntegration reconnecting to server markup elements reconnecting different component implementations should reconnect Bare Element to Bare Element" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting different element types" name="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting different element types" time="0.135">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting fewer root children" name="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting fewer root children" time="0.11">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting missing attributes" name="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting missing attributes" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting added attributes" name="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting added attributes" time="0.124">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting different attribute values" name="ReactDOMServerIntegration reconnecting to server markup elements should error reconnecting different attribute values" time="0.1">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements can explicitly ignore errors reconnecting different element types of children" name="ReactDOMServerIntegration reconnecting to server markup elements can explicitly ignore errors reconnecting different element types of children" time="0.109">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements can explicitly ignore errors reconnecting missing attributes" name="ReactDOMServerIntegration reconnecting to server markup elements can explicitly ignore errors reconnecting missing attributes" time="0.14">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements can explicitly ignore errors reconnecting added attributes" name="ReactDOMServerIntegration reconnecting to server markup elements can explicitly ignore errors reconnecting added attributes" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements can explicitly ignore errors reconnecting different attribute values" name="ReactDOMServerIntegration reconnecting to server markup elements can explicitly ignore errors reconnecting different attribute values" time="0.12">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup elements can not deeply ignore errors reconnecting different attribute values" name="ReactDOMServerIntegration reconnecting to server markup elements can not deeply ignore errors reconnecting different attribute values" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting missing style attribute" name="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting missing style attribute" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting added style attribute" name="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting added style attribute" time="0.106">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting empty style attribute" name="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting empty style attribute" time="0.124">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting added style values" name="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting added style values" time="0.2">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting different style values" name="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting different style values" time="0.164">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles should reconnect number and string versions of a number" name="ReactDOMServerIntegration reconnecting to server markup inline styles should reconnect number and string versions of a number" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting reordered style values" name="ReactDOMServerIntegration reconnecting to server markup inline styles should error reconnecting reordered style values" time="0.132">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles can explicitly ignore errors reconnecting added style values" name="ReactDOMServerIntegration reconnecting to server markup inline styles can explicitly ignore errors reconnecting added style values" time="0.116">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup inline styles can explicitly ignore reconnecting different style values" name="ReactDOMServerIntegration reconnecting to server markup inline styles can explicitly ignore reconnecting different style values" time="0.135">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup text nodes should error reconnecting different text" name="ReactDOMServerIntegration reconnecting to server markup text nodes should error reconnecting different text" time="0.112">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup text nodes should reconnect a div with a number and string version of number" name="ReactDOMServerIntegration reconnecting to server markup text nodes should reconnect a div with a number and string version of number" time="0.109">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup text nodes should error reconnecting different numbers" name="ReactDOMServerIntegration reconnecting to server markup text nodes should error reconnecting different numbers" time="0.145">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup text nodes should error reconnecting different number from text" name="ReactDOMServerIntegration reconnecting to server markup text nodes should error reconnecting different number from text" time="0.129">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup text nodes should error reconnecting different text in two code blocks" name="ReactDOMServerIntegration reconnecting to server markup text nodes should error reconnecting different text in two code blocks" time="0.134">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup text nodes can explicitly ignore reconnecting different text" name="ReactDOMServerIntegration reconnecting to server markup text nodes can explicitly ignore reconnecting different text" time="0.154">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup text nodes can explicitly ignore reconnecting different text in two code blocks" name="ReactDOMServerIntegration reconnecting to server markup text nodes can explicitly ignore reconnecting different text in two code blocks" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting missing children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting missing children" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting added children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting added children" time="0.129">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting more children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting more children" time="0.162">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting fewer children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting fewer children" time="0.13">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting reordered children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting reordered children" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting a div with children separated by whitespace on the client" name="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting a div with children separated by whitespace on the client" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting a div with children separated by different whitespace on the server" name="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting a div with children separated by different whitespace on the server" time="0.15">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting a div with children separated by different whitespace" name="ReactDOMServerIntegration reconnecting to server markup element trees and children should error reconnecting a div with children separated by different whitespace" time="0.124">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children can distinguish an empty component from a dom node" name="ReactDOMServerIntegration reconnecting to server markup element trees and children can distinguish an empty component from a dom node" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children can distinguish an empty component from an empty text component" name="ReactDOMServerIntegration reconnecting to server markup element trees and children can distinguish an empty component from an empty text component" time="0.113">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children can explicitly ignore reconnecting more children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children can explicitly ignore reconnecting more children" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children can explicitly ignore reconnecting fewer children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children can explicitly ignore reconnecting fewer children" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children can explicitly ignore reconnecting reordered children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children can explicitly ignore reconnecting reordered children" time="0.127">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup element trees and children can not deeply ignore reconnecting reordered children" name="ReactDOMServerIntegration reconnecting to server markup element trees and children can not deeply ignore reconnecting reordered children" time="0.141">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup should error reconnecting a div with different dangerouslySetInnerHTML" name="ReactDOMServerIntegration reconnecting to server markup should error reconnecting a div with different dangerouslySetInnerHTML" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup should error reconnecting a div with different text dangerouslySetInnerHTML" name="ReactDOMServerIntegration reconnecting to server markup should error reconnecting a div with different text dangerouslySetInnerHTML" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup should error reconnecting a div with different number dangerouslySetInnerHTML" name="ReactDOMServerIntegration reconnecting to server markup should error reconnecting a div with different number dangerouslySetInnerHTML" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup should error reconnecting a div with different object dangerouslySetInnerHTML" name="ReactDOMServerIntegration reconnecting to server markup should error reconnecting a div with different object dangerouslySetInnerHTML" time="0.15">
    </testcase>
    <testcase classname="ReactDOMServerIntegration reconnecting to server markup can explicitly ignore reconnecting a div with different dangerouslySetInnerHTML" name="ReactDOMServerIntegration reconnecting to server markup can explicitly ignore reconnecting a div with different dangerouslySetInnerHTML" time="0.099">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-refresh/src/__tests__/ReactFreshIntegration-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:21" time="22.867" tests="65">
    <testcase classname="ReactFreshIntegration with compiled destructuring reloads function declarations" name="ReactFreshIntegration with compiled destructuring reloads function declarations" time="1.479">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring reloads arrow functions" name="ReactFreshIntegration with compiled destructuring reloads arrow functions" time="0.291">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring reloads a combination of memo and forwardRef" name="ReactFreshIntegration with compiled destructuring reloads a combination of memo and forwardRef" time="0.328">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring reloads default export with named memo" name="ReactFreshIntegration with compiled destructuring reloads default export with named memo" time="0.323">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring reloads HOCs if they return functions" name="ReactFreshIntegration with compiled destructuring reloads HOCs if they return functions" time="0.599">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring resets state when renaming a state variable" name="ReactFreshIntegration with compiled destructuring resets state when renaming a state variable" time="0.406">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring resets state when renaming a state variable in a HOC" name="ReactFreshIntegration with compiled destructuring resets state when renaming a state variable in a HOC" time="0.384">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring resets state when renaming a state variable in a HOC with indirection" name="ReactFreshIntegration with compiled destructuring resets state when renaming a state variable in a HOC with indirection" time="0.331">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring resets state when renaming a state variable inside a HOC with direct call" name="ReactFreshIntegration with compiled destructuring resets state when renaming a state variable inside a HOC with direct call" time="0.267">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not crash when changing Hook order inside a HOC with direct call" name="ReactFreshIntegration with compiled destructuring does not crash when changing Hook order inside a HOC with direct call" time="0.259">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not crash when changing Hook order inside a memo-ed HOC with direct call" name="ReactFreshIntegration with compiled destructuring does not crash when changing Hook order inside a memo-ed HOC with direct call" time="0.271">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not crash when changing Hook order inside a memo+forwardRef-ed HOC with direct call" name="ReactFreshIntegration with compiled destructuring does not crash when changing Hook order inside a memo+forwardRef-ed HOC with direct call" time="0.282">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not crash when changing Hook order inside a HOC returning an object" name="ReactFreshIntegration with compiled destructuring does not crash when changing Hook order inside a HOC returning an object" time="0.272">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring resets effects while preserving state" name="ReactFreshIntegration with compiled destructuring resets effects while preserving state" time="0.319">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not get confused when custom hooks are reordered" name="ReactFreshIntegration with compiled destructuring does not get confused when custom hooks are reordered" time="0.303">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not get confused when component is called early" name="ReactFreshIntegration with compiled destructuring does not get confused when component is called early" time="0.262">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not get confused by Hooks defined inline" name="ReactFreshIntegration with compiled destructuring does not get confused by Hooks defined inline" time="0.284">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring remounts component if custom hook it uses changes order" name="ReactFreshIntegration with compiled destructuring remounts component if custom hook it uses changes order" time="0.342">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not lose the inferred arrow names" name="ReactFreshIntegration with compiled destructuring does not lose the inferred arrow names" time="0.261">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring does not lose the inferred function names" name="ReactFreshIntegration with compiled destructuring does not lose the inferred function names" time="0.226">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring resets state on every edit with @refresh reset annotation" name="ReactFreshIntegration with compiled destructuring resets state on every edit with @refresh reset annotation" time="0.344">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring resets state when useState initial state is edited" name="ReactFreshIntegration with compiled destructuring resets state when useState initial state is edited" time="0.302">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring resets state when useReducer initial state is edited" name="ReactFreshIntegration with compiled destructuring resets state when useReducer initial state is edited" time="0.313">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring remounts when switching export from function to class" name="ReactFreshIntegration with compiled destructuring remounts when switching export from function to class" time="0.342">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring remounts when switching export from class to function" name="ReactFreshIntegration with compiled destructuring remounts when switching export from class to function" time="0.257">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring remounts when wrapping export in a HOC" name="ReactFreshIntegration with compiled destructuring remounts when wrapping export in a HOC" time="0.338">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring remounts when wrapping export in memo()" name="ReactFreshIntegration with compiled destructuring remounts when wrapping export in memo()" time="0.283">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring remounts when wrapping export in forwardRef()" name="ReactFreshIntegration with compiled destructuring remounts when wrapping export in forwardRef()" time="0.32">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring with inline requires remounts component if custom hook it uses changes order on first edit" name="ReactFreshIntegration with compiled destructuring with inline requires remounts component if custom hook it uses changes order on first edit" time="0.291">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring with inline requires remounts component if custom hook it uses changes order on second edit" name="ReactFreshIntegration with compiled destructuring with inline requires remounts component if custom hook it uses changes order on second edit" time="0.307">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring with inline requires recovers if evaluating Hook list throws" name="ReactFreshIntegration with compiled destructuring with inline requires recovers if evaluating Hook list throws" time="0.264">
    </testcase>
    <testcase classname="ReactFreshIntegration with compiled destructuring with inline requires remounts component if custom hook it uses changes order behind an indirection" name="ReactFreshIntegration with compiled destructuring with inline requires remounts component if custom hook it uses changes order behind an indirection" time="0.355">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring reloads function declarations" name="ReactFreshIntegration without compiled destructuring reloads function declarations" time="0.25">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring reloads arrow functions" name="ReactFreshIntegration without compiled destructuring reloads arrow functions" time="0.226">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring reloads a combination of memo and forwardRef" name="ReactFreshIntegration without compiled destructuring reloads a combination of memo and forwardRef" time="0.276">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring reloads default export with named memo" name="ReactFreshIntegration without compiled destructuring reloads default export with named memo" time="0.252">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring reloads HOCs if they return functions" name="ReactFreshIntegration without compiled destructuring reloads HOCs if they return functions" time="0.299">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring resets state when renaming a state variable" name="ReactFreshIntegration without compiled destructuring resets state when renaming a state variable" time="0.298">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring resets state when renaming a state variable in a HOC" name="ReactFreshIntegration without compiled destructuring resets state when renaming a state variable in a HOC" time="0.296">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring resets state when renaming a state variable in a HOC with indirection" name="ReactFreshIntegration without compiled destructuring resets state when renaming a state variable in a HOC with indirection" time="0.258">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring resets state when renaming a state variable inside a HOC with direct call" name="ReactFreshIntegration without compiled destructuring resets state when renaming a state variable inside a HOC with direct call" time="0.356">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not crash when changing Hook order inside a HOC with direct call" name="ReactFreshIntegration without compiled destructuring does not crash when changing Hook order inside a HOC with direct call" time="0.249">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not crash when changing Hook order inside a memo-ed HOC with direct call" name="ReactFreshIntegration without compiled destructuring does not crash when changing Hook order inside a memo-ed HOC with direct call" time="0.257">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not crash when changing Hook order inside a memo+forwardRef-ed HOC with direct call" name="ReactFreshIntegration without compiled destructuring does not crash when changing Hook order inside a memo+forwardRef-ed HOC with direct call" time="0.252">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not crash when changing Hook order inside a HOC returning an object" name="ReactFreshIntegration without compiled destructuring does not crash when changing Hook order inside a HOC returning an object" time="0.414">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring resets effects while preserving state" name="ReactFreshIntegration without compiled destructuring resets effects while preserving state" time="0.71">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not get confused when custom hooks are reordered" name="ReactFreshIntegration without compiled destructuring does not get confused when custom hooks are reordered" time="0.315">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not get confused when component is called early" name="ReactFreshIntegration without compiled destructuring does not get confused when component is called early" time="0.267">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not get confused by Hooks defined inline" name="ReactFreshIntegration without compiled destructuring does not get confused by Hooks defined inline" time="0.267">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring remounts component if custom hook it uses changes order" name="ReactFreshIntegration without compiled destructuring remounts component if custom hook it uses changes order" time="0.31">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not lose the inferred arrow names" name="ReactFreshIntegration without compiled destructuring does not lose the inferred arrow names" time="0.224">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring does not lose the inferred function names" name="ReactFreshIntegration without compiled destructuring does not lose the inferred function names" time="0.314">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring resets state on every edit with @refresh reset annotation" name="ReactFreshIntegration without compiled destructuring resets state on every edit with @refresh reset annotation" time="0.43">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring resets state when useState initial state is edited" name="ReactFreshIntegration without compiled destructuring resets state when useState initial state is edited" time="0.305">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring resets state when useReducer initial state is edited" name="ReactFreshIntegration without compiled destructuring resets state when useReducer initial state is edited" time="0.309">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring remounts when switching export from function to class" name="ReactFreshIntegration without compiled destructuring remounts when switching export from function to class" time="0.378">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring remounts when switching export from class to function" name="ReactFreshIntegration without compiled destructuring remounts when switching export from class to function" time="0.31">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring remounts when wrapping export in a HOC" name="ReactFreshIntegration without compiled destructuring remounts when wrapping export in a HOC" time="0.33">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring remounts when wrapping export in memo()" name="ReactFreshIntegration without compiled destructuring remounts when wrapping export in memo()" time="0.373">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring remounts when wrapping export in forwardRef()" name="ReactFreshIntegration without compiled destructuring remounts when wrapping export in forwardRef()" time="0.283">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring with inline requires remounts component if custom hook it uses changes order on first edit" name="ReactFreshIntegration without compiled destructuring with inline requires remounts component if custom hook it uses changes order on first edit" time="0.233">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring with inline requires remounts component if custom hook it uses changes order on second edit" name="ReactFreshIntegration without compiled destructuring with inline requires remounts component if custom hook it uses changes order on second edit" time="0.332">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring with inline requires recovers if evaluating Hook list throws" name="ReactFreshIntegration without compiled destructuring with inline requires recovers if evaluating Hook list throws" time="0.283">
    </testcase>
    <testcase classname="ReactFreshIntegration without compiled destructuring with inline requires remounts component if custom hook it uses changes order behind an indirection" name="ReactFreshIntegration without compiled destructuring with inline requires remounts component if custom hook it uses changes order behind an indirection" time="0.288">
    </testcase>
    <testcase classname="ReactFreshIntegration with typescript syntax reloads component exported in typescript namespace" name="ReactFreshIntegration with typescript syntax reloads component exported in typescript namespace" time="0.288">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactServerRendering-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:41" time="3.234" tests="49">
    <testcase classname="ReactDOMServer renderToString should generate simple markup" name="ReactDOMServer renderToString should generate simple markup" time="0.127">
    </testcase>
    <testcase classname="ReactDOMServer renderToString should generate simple markup for self-closing tags" name="ReactDOMServer renderToString should generate simple markup for self-closing tags" time="0.033">
    </testcase>
    <testcase classname="ReactDOMServer renderToString should generate comment markup for component returns null" name="ReactDOMServer renderToString should generate comment markup for component returns null" time="0.033">
    </testcase>
    <testcase classname="ReactDOMServer renderToString should render composite components" name="ReactDOMServer renderToString should render composite components" time="0.021">
    </testcase>
    <testcase classname="ReactDOMServer renderToString should only execute certain lifecycle methods" name="ReactDOMServer renderToString should only execute certain lifecycle methods" time="0.023">
    </testcase>
    <testcase classname="ReactDOMServer renderToString should throw with silly args" name="ReactDOMServer renderToString should throw with silly args" time="0.022">
    </testcase>
    <testcase classname="ReactDOMServer renderToString should throw prop mapping error for an &lt;iframe /&gt; with invalid props" name="ReactDOMServer renderToString should throw prop mapping error for an &lt;iframe /&gt; with invalid props" time="0.021">
    </testcase>
    <testcase classname="ReactDOMServer renderToString should not crash on poisoned hasOwnProperty" name="ReactDOMServer renderToString should not crash on poisoned hasOwnProperty" time="0.024">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup should not put checksum and React ID on components" name="ReactDOMServer renderToStaticMarkup should not put checksum and React ID on components" time="0.025">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup should not put checksum and React ID on text components" name="ReactDOMServer renderToStaticMarkup should not put checksum and React ID on text components" time="0.017">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup should not use comments for empty nodes" name="ReactDOMServer renderToStaticMarkup should not use comments for empty nodes" time="0.022">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup should only execute certain lifecycle methods" name="ReactDOMServer renderToStaticMarkup should only execute certain lifecycle methods" time="0.021">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup should throw with silly args" name="ReactDOMServer renderToStaticMarkup should throw with silly args" time="0.034">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup allows setState in componentWillMount without using DOM" name="ReactDOMServer renderToStaticMarkup allows setState in componentWillMount without using DOM" time="0.018">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup allows setState in componentWillMount with custom constructor" name="ReactDOMServer renderToStaticMarkup allows setState in componentWillMount with custom constructor" time="0.025">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup renders with props when using custom constructor" name="ReactDOMServer renderToStaticMarkup renders with props when using custom constructor" time="0.027">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup renders with context when using custom constructor" name="ReactDOMServer renderToStaticMarkup renders with context when using custom constructor" time="0.032">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup renders with new context API" name="ReactDOMServer renderToStaticMarkup renders with new context API" time="0.01">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup renders with dispatcher.readContext mechanism" name="ReactDOMServer renderToStaticMarkup renders with dispatcher.readContext mechanism" time="0.014">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup renders context API, reentrancy" name="ReactDOMServer renderToStaticMarkup renders context API, reentrancy" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup renders components with different batching strategies" name="ReactDOMServer renderToStaticMarkup renders components with different batching strategies" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup renders synchronously resolved lazy component" name="ReactDOMServer renderToStaticMarkup renders synchronously resolved lazy component" time="0.017">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticMarkup throws error from synchronously rejected lazy component" name="ReactDOMServer renderToStaticMarkup throws error from synchronously rejected lazy component" time="0.022">
    </testcase>
    <testcase classname="ReactDOMServer renderToNodeStream should generate simple markup" name="ReactDOMServer renderToNodeStream should generate simple markup" time="0.023">
    </testcase>
    <testcase classname="ReactDOMServer renderToNodeStream should handle errors correctly" name="ReactDOMServer renderToNodeStream should handle errors correctly" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticNodeStream should generate simple markup" name="ReactDOMServer renderToStaticNodeStream should generate simple markup" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServer renderToStaticNodeStream should handle errors correctly" name="ReactDOMServer renderToStaticNodeStream should handle errors correctly" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServer warns with a no-op when an async setState is triggered" name="ReactDOMServer warns with a no-op when an async setState is triggered" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServer warns with a no-op when an async forceUpdate is triggered" name="ReactDOMServer warns with a no-op when an async forceUpdate is triggered" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServer does not get confused by throwing null" name="ReactDOMServer does not get confused by throwing null" time="0.034">
    </testcase>
    <testcase classname="ReactDOMServer does not get confused by throwing undefined" name="ReactDOMServer does not get confused by throwing undefined" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServer does not get confused by throwing a primitive" name="ReactDOMServer does not get confused by throwing a primitive" time="0.022">
    </testcase>
    <testcase classname="ReactDOMServer should throw (in dev) when children are mutated during render" name="ReactDOMServer should throw (in dev) when children are mutated during render" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServer warns about lowercase html but not in svg tags" name="ReactDOMServer warns about lowercase html but not in svg tags" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServer should warn about contentEditable and children" name="ReactDOMServer should warn about contentEditable and children" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServer should warn when server rendering a class with a render method that does not extend React.Component" name="ReactDOMServer should warn when server rendering a class with a render method that does not extend React.Component" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServer can import react-dom in Node environment" name="ReactDOMServer can import react-dom in Node environment" time="0.183">
    </testcase>
    <testcase classname="ReactDOMServer includes a useful stack in warnings" name="ReactDOMServer includes a useful stack in warnings" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServer reports stacks with re-entrant renderToString() calls" name="ReactDOMServer reports stacks with re-entrant renderToString() calls" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServer should warn if an invalid contextType is defined" name="ReactDOMServer should warn if an invalid contextType is defined" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServer should not warn when class contextType is null" name="ReactDOMServer should not warn when class contextType is null" time="0.117">
    </testcase>
    <testcase classname="ReactDOMServer should warn when class contextType is undefined" name="ReactDOMServer should warn when class contextType is undefined" time="0.029">
    </testcase>
    <testcase classname="ReactDOMServer should warn when class contextType is an object" name="ReactDOMServer should warn when class contextType is an object" time="0.025">
    </testcase>
    <testcase classname="ReactDOMServer should warn when class contextType is a primitive" name="ReactDOMServer should warn when class contextType is a primitive" time="0.026">
    </testcase>
    <testcase classname="ReactDOMServer custom element server rendering String properties should be server rendered for custom elements" name="ReactDOMServer custom element server rendering String properties should be server rendered for custom elements" time="0.026">
    </testcase>
    <testcase classname="ReactDOMServer custom element server rendering Number properties should be server rendered for custom elements" name="ReactDOMServer custom element server rendering Number properties should be server rendered for custom elements" time="0.015">
    </testcase>
    <testcase classname="ReactDOMServer custom element server rendering Object properties should not be server rendered for custom elements" name="ReactDOMServer custom element server rendering Object properties should not be server rendered for custom elements" time="0.008">
    </testcase>
    <testcase classname="ReactDOMServer custom element server rendering Array properties should not be server rendered for custom elements" name="ReactDOMServer custom element server rendering Array properties should not be server rendered for custom elements" time="0.019">
    </testcase>
    <testcase classname="ReactDOMServer custom element server rendering Function properties should not be server rendered for custom elements" name="ReactDOMServer custom element server rendering Function properties should not be server rendered for custom elements" time="0.023">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMComponent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:32" time="12.458" tests="160">
    <testcase classname="ReactDOMComponent updateDOM should handle className" name="ReactDOMComponent updateDOM should handle className" time="0.12">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should gracefully handle various style value types" name="ReactDOMComponent updateDOM should gracefully handle various style value types" time="0.097">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not update styles when mutating a proxy style object" name="ReactDOMComponent updateDOM should not update styles when mutating a proxy style object" time="0.07">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should throw when mutating style objects" name="ReactDOMComponent updateDOM should throw when mutating style objects" time="0.06">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should warn for unknown prop" name="ReactDOMComponent updateDOM should warn for unknown prop" time="0.06">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should group multiple unknown prop warnings together" name="ReactDOMComponent updateDOM should group multiple unknown prop warnings together" time="0.065">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should warn for onDblClick prop" name="ReactDOMComponent updateDOM should warn for onDblClick prop" time="0.05">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should warn for unknown string event handlers" name="ReactDOMComponent updateDOM should warn for unknown string event handlers" time="0.086">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should warn for unknown function event handlers" name="ReactDOMComponent updateDOM should warn for unknown function event handlers" time="0.031">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should warn for badly cased React attributes" name="ReactDOMComponent updateDOM should warn for badly cased React attributes" time="0.031">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not warn for &quot;0&quot; as a unitless style value" name="ReactDOMComponent updateDOM should not warn for &quot;0&quot; as a unitless style value" time="0.062">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should warn nicely about NaN in style" name="ReactDOMComponent updateDOM should warn nicely about NaN in style" time="0.067">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM throws with Temporal-like objects as style values" name="ReactDOMComponent updateDOM throws with Temporal-like objects as style values" time="0.076">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should update styles if initially null" name="ReactDOMComponent updateDOM should update styles if initially null" time="0.056">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should update styles if updated to null multiple times" name="ReactDOMComponent updateDOM should update styles if updated to null multiple times" time="0.095">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should allow named slot projection on both web components and regular DOM elements" name="ReactDOMComponent updateDOM should allow named slot projection on both web components and regular DOM elements" time="0.042">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should skip reserved props on web components" name="ReactDOMComponent updateDOM should skip reserved props on web components" time="0.08">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should skip dangerouslySetInnerHTML on web components" name="ReactDOMComponent updateDOM should skip dangerouslySetInnerHTML on web components" time="0.066">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should render null and undefined as empty but print other falsy values" name="ReactDOMComponent updateDOM should render null and undefined as empty but print other falsy values" time="0.06">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should remove attributes" name="ReactDOMComponent updateDOM should remove attributes" time="0.088">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should remove properties" name="ReactDOMComponent updateDOM should remove properties" time="0.072">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not set null/undefined attributes" name="ReactDOMComponent updateDOM should not set null/undefined attributes" time="0.073">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not add an empty src attribute" name="ReactDOMComponent updateDOM should not add an empty src attribute" time="0.045">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not add an empty href attribute" name="ReactDOMComponent updateDOM should not add an empty href attribute" time="0.07">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not add an empty action attribute" name="ReactDOMComponent updateDOM should not add an empty action attribute" time="0.066">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not add an empty formAction attribute" name="ReactDOMComponent updateDOM should not add an empty formAction attribute" time="0.059">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not filter attributes for custom elements" name="ReactDOMComponent updateDOM should not filter attributes for custom elements" time="0.07">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should apply React-specific aliases to HTML elements" name="ReactDOMComponent updateDOM should apply React-specific aliases to HTML elements" time="0.034">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should apply React-specific aliases to SVG elements" name="ReactDOMComponent updateDOM should apply React-specific aliases to SVG elements" time="0.072">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should properly update custom attributes on custom elements" name="ReactDOMComponent updateDOM should properly update custom attributes on custom elements" time="0.056">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not apply React-specific aliases to custom elements" name="ReactDOMComponent updateDOM should not apply React-specific aliases to custom elements" time="0.049">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should clear a single style prop when changing `style`" name="ReactDOMComponent updateDOM should clear a single style prop when changing `style`" time="0.04">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should reject attribute key injection attack on markup for regular DOM (SSR)" name="ReactDOMComponent updateDOM should reject attribute key injection attack on markup for regular DOM (SSR)" time="0.081">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should reject attribute key injection attack on markup for custom elements (SSR)" name="ReactDOMComponent updateDOM should reject attribute key injection attack on markup for custom elements (SSR)" time="0.074">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should reject attribute key injection attack on mount for regular DOM" name="ReactDOMComponent updateDOM should reject attribute key injection attack on mount for regular DOM" time="0.062">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should reject attribute key injection attack on mount for custom elements" name="ReactDOMComponent updateDOM should reject attribute key injection attack on mount for custom elements" time="0.064">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should reject attribute key injection attack on update for regular DOM" name="ReactDOMComponent updateDOM should reject attribute key injection attack on update for regular DOM" time="0.083">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should reject attribute key injection attack on update for custom elements" name="ReactDOMComponent updateDOM should reject attribute key injection attack on update for custom elements" time="0.037">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should update arbitrary attributes for tags containing dashes" name="ReactDOMComponent updateDOM should update arbitrary attributes for tags containing dashes" time="0.122">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should clear all the styles when removing `style`" name="ReactDOMComponent updateDOM should clear all the styles when removing `style`" time="0.066">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should update styles when `style` changes from null to object" name="ReactDOMComponent updateDOM should update styles when `style` changes from null to object" time="0.053">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not reset innerHTML for when children is null" name="ReactDOMComponent updateDOM should not reset innerHTML for when children is null" time="0.039">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should reset innerHTML when switching from a direct text child to an empty child" name="ReactDOMComponent updateDOM should reset innerHTML when switching from a direct text child to an empty child" time="0.073">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should empty element when removing innerHTML" name="ReactDOMComponent updateDOM should empty element when removing innerHTML" time="0.052">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should transition from string content to innerHTML" name="ReactDOMComponent updateDOM should transition from string content to innerHTML" time="0.051">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should transition from innerHTML to string content" name="ReactDOMComponent updateDOM should transition from innerHTML to string content" time="0.067">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should transition from innerHTML to children in nested el" name="ReactDOMComponent updateDOM should transition from innerHTML to children in nested el" time="0.066">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should transition from children to innerHTML in nested el" name="ReactDOMComponent updateDOM should transition from children to innerHTML in nested el" time="0.056">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not incur unnecessary DOM mutations for attributes" name="ReactDOMComponent updateDOM should not incur unnecessary DOM mutations for attributes" time="0.037">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not incur unnecessary DOM mutations for string properties" name="ReactDOMComponent updateDOM should not incur unnecessary DOM mutations for string properties" time="0.07">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not incur unnecessary DOM mutations for boolean properties" name="ReactDOMComponent updateDOM should not incur unnecessary DOM mutations for boolean properties" time="0.076">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should ignore attribute list for elements with the &quot;is&quot; attribute" name="ReactDOMComponent updateDOM should ignore attribute list for elements with the &quot;is&quot; attribute" time="0.047">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should warn about non-string &quot;is&quot; attribute" name="ReactDOMComponent updateDOM should warn about non-string &quot;is&quot; attribute" time="0.055">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM should not update when switching between null/undefined" name="ReactDOMComponent updateDOM should not update when switching between null/undefined" time="0.045">
    </testcase>
    <testcase classname="ReactDOMComponent updateDOM handles multiple child updates without interference" name="ReactDOMComponent updateDOM handles multiple child updates without interference" time="0.078">
    </testcase>
    <testcase classname="ReactDOMComponent createOpenTagMarkup should generate the correct markup with className" name="ReactDOMComponent createOpenTagMarkup should generate the correct markup with className" time="0.063">
    </testcase>
    <testcase classname="ReactDOMComponent createOpenTagMarkup should escape style names and values" name="ReactDOMComponent createOpenTagMarkup should escape style names and values" time="0.048">
    </testcase>
    <testcase classname="ReactDOMComponent createContentMarkup should handle dangerouslySetInnerHTML" name="ReactDOMComponent createContentMarkup should handle dangerouslySetInnerHTML" time="0.062">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should work error event on &lt;source&gt; element" name="ReactDOMComponent mountComponent should work error event on &lt;source&gt; element" time="0.058">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should warn for uppercased selfclosing tags" name="ReactDOMComponent mountComponent should warn for uppercased selfclosing tags" time="0.072">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should warn on upper case HTML tags, not SVG nor custom tags" name="ReactDOMComponent mountComponent should warn on upper case HTML tags, not SVG nor custom tags" time="0.044">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should warn on props reserved for future use" name="ReactDOMComponent mountComponent should warn on props reserved for future use" time="0.039">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should warn if the tag is unrecognized" name="ReactDOMComponent mountComponent should warn if the tag is unrecognized" time="0.077">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should throw on children for void elements" name="ReactDOMComponent mountComponent should throw on children for void elements" time="0.088">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should throw on dangerouslySetInnerHTML for void elements" name="ReactDOMComponent mountComponent should throw on dangerouslySetInnerHTML for void elements" time="0.054">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should treat menuitem as a void element but still create the closing tag" name="ReactDOMComponent mountComponent should treat menuitem as a void element but still create the closing tag" time="0.078">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should validate against multiple children props" name="ReactDOMComponent mountComponent should validate against multiple children props" time="0.063">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should validate against use of innerHTML" name="ReactDOMComponent mountComponent should validate against use of innerHTML" time="0.055">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should validate against use of innerHTML without case sensitivity" name="ReactDOMComponent mountComponent should validate against use of innerHTML without case sensitivity" time="0.046">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should validate use of dangerouslySetInnerHTML" name="ReactDOMComponent mountComponent should validate use of dangerouslySetInnerHTML" time="0.106">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should validate use of dangerouslySetInnerHTML" name="ReactDOMComponent mountComponent should validate use of dangerouslySetInnerHTML" time="0.038">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should allow {__html: null}" name="ReactDOMComponent mountComponent should allow {__html: null}" time="0.036">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should warn about contentEditable and children" name="ReactDOMComponent mountComponent should warn about contentEditable and children" time="0.074">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should respect suppressContentEditableWarning" name="ReactDOMComponent mountComponent should respect suppressContentEditableWarning" time="0.096">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should validate against invalid styles" name="ReactDOMComponent mountComponent should validate against invalid styles" time="0.038">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should throw for children on void elements" name="ReactDOMComponent mountComponent should throw for children on void elements" time="0.075">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should support custom elements which extend native elements" name="ReactDOMComponent mountComponent should support custom elements which extend native elements" time="0.039">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should work load and error events on &lt;image&gt; element in SVG" name="ReactDOMComponent mountComponent should work load and error events on &lt;image&gt; element in SVG" time="0.068">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should receive a load event on &lt;link&gt; elements" name="ReactDOMComponent mountComponent should receive a load event on &lt;link&gt; elements" time="0.06">
    </testcase>
    <testcase classname="ReactDOMComponent mountComponent should receive an error event on &lt;link&gt; elements" name="ReactDOMComponent mountComponent should receive an error event on &lt;link&gt; elements" time="0.06">
    </testcase>
    <testcase classname="ReactDOMComponent updateComponent should warn against children for void elements" name="ReactDOMComponent updateComponent should warn against children for void elements" time="0.066">
    </testcase>
    <testcase classname="ReactDOMComponent updateComponent should warn against dangerouslySetInnerHTML for void elements" name="ReactDOMComponent updateComponent should warn against dangerouslySetInnerHTML for void elements" time="0.046">
    </testcase>
    <testcase classname="ReactDOMComponent updateComponent should validate against multiple children props" name="ReactDOMComponent updateComponent should validate against multiple children props" time="0.089">
    </testcase>
    <testcase classname="ReactDOMComponent updateComponent should warn about contentEditable and children" name="ReactDOMComponent updateComponent should warn about contentEditable and children" time="0.048">
    </testcase>
    <testcase classname="ReactDOMComponent updateComponent should validate against invalid styles" name="ReactDOMComponent updateComponent should validate against invalid styles" time="0.067">
    </testcase>
    <testcase classname="ReactDOMComponent updateComponent should report component containing invalid styles" name="ReactDOMComponent updateComponent should report component containing invalid styles" time="0.06">
    </testcase>
    <testcase classname="ReactDOMComponent updateComponent should properly escape text content and attributes values" name="ReactDOMComponent updateComponent should properly escape text content and attributes values" time="0.064">
    </testcase>
    <testcase classname="ReactDOMComponent unmountComponent unmounts children before unsetting DOM node info" name="ReactDOMComponent unmountComponent unmounts children before unsetting DOM node info" time="0.052">
    </testcase>
    <testcase classname="ReactDOMComponent tag sanitization should throw when an invalid tag name is used server-side" name="ReactDOMComponent tag sanitization should throw when an invalid tag name is used server-side" time="0.054">
    </testcase>
    <testcase classname="ReactDOMComponent tag sanitization should throw when an attack vector is used server-side" name="ReactDOMComponent tag sanitization should throw when an attack vector is used server-side" time="0.05">
    </testcase>
    <testcase classname="ReactDOMComponent tag sanitization should throw when an invalid tag name is used" name="ReactDOMComponent tag sanitization should throw when an invalid tag name is used" time="0.069">
    </testcase>
    <testcase classname="ReactDOMComponent tag sanitization should throw when an attack vector is used" name="ReactDOMComponent tag sanitization should throw when an attack vector is used" time="0.042">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation warns on invalid nesting" name="ReactDOMComponent nesting validation warns on invalid nesting" time="0.042">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation warns on invalid nesting at root" name="ReactDOMComponent nesting validation warns on invalid nesting at root" time="0.075">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation warns nicely for table rows" name="ReactDOMComponent nesting validation warns nicely for table rows" time="0.049">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives useful context in warnings" name="ReactDOMComponent nesting validation gives useful context in warnings" time="0.168">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives useful context in warnings 2" name="ReactDOMComponent nesting validation gives useful context in warnings 2" time="0.08">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives useful context in warnings 3" name="ReactDOMComponent nesting validation gives useful context in warnings 3" time="0.139">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives useful context in warnings 4" name="ReactDOMComponent nesting validation gives useful context in warnings 4" time="0.189">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives useful context in warnings 5" name="ReactDOMComponent nesting validation gives useful context in warnings 5" time="0.287">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about incorrect casing on properties (ssr)" name="ReactDOMComponent nesting validation should warn about incorrect casing on properties (ssr)" time="0.143">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about incorrect casing on event handlers (ssr)" name="ReactDOMComponent nesting validation should warn about incorrect casing on event handlers (ssr)" time="0.121">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about incorrect casing on properties" name="ReactDOMComponent nesting validation should warn about incorrect casing on properties" time="0.103">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about incorrect casing on event handlers" name="ReactDOMComponent nesting validation should warn about incorrect casing on event handlers" time="0.066">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about class" name="ReactDOMComponent nesting validation should warn about class" time="0.072">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about class (ssr)" name="ReactDOMComponent nesting validation should warn about class (ssr)" time="0.066">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about props that are no longer supported" name="ReactDOMComponent nesting validation should warn about props that are no longer supported" time="0.045">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about props that are no longer supported without case sensitivity" name="ReactDOMComponent nesting validation should warn about props that are no longer supported without case sensitivity" time="0.1">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about props that are no longer supported (ssr)" name="ReactDOMComponent nesting validation should warn about props that are no longer supported (ssr)" time="0.086">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should warn about props that are no longer supported without case sensitivity (ssr)" name="ReactDOMComponent nesting validation should warn about props that are no longer supported without case sensitivity (ssr)" time="0.05">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives source code refs for unknown prop warning" name="ReactDOMComponent nesting validation gives source code refs for unknown prop warning" time="0.071">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives source code refs for unknown prop warning (ssr)" name="ReactDOMComponent nesting validation gives source code refs for unknown prop warning (ssr)" time="0.024">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for update render" name="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for update render" time="0.108">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for exact elements" name="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for exact elements" time="0.051">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for exact elements (ssr)" name="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for exact elements (ssr)" time="0.101">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for exact elements in composition" name="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for exact elements in composition" time="0.085">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for exact elements in composition (ssr)" name="ReactDOMComponent nesting validation gives source code refs for unknown prop warning for exact elements in composition (ssr)" time="0.073">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should suggest property name if available" name="ReactDOMComponent nesting validation should suggest property name if available" time="0.066">
    </testcase>
    <testcase classname="ReactDOMComponent nesting validation should suggest property name if available (ssr)" name="ReactDOMComponent nesting validation should suggest property name if available (ssr)" time="0.038">
    </testcase>
    <testcase classname="ReactDOMComponent whitespace renders innerHTML and preserves whitespace" name="ReactDOMComponent whitespace renders innerHTML and preserves whitespace" time="0.05">
    </testcase>
    <testcase classname="ReactDOMComponent whitespace render and then updates innerHTML and preserves whitespace" name="ReactDOMComponent whitespace render and then updates innerHTML and preserves whitespace" time="0.112">
    </testcase>
    <testcase classname="ReactDOMComponent Attributes with aliases sets aliased attributes on HTML attributes" name="ReactDOMComponent Attributes with aliases sets aliased attributes on HTML attributes" time="0.029">
    </testcase>
    <testcase classname="ReactDOMComponent Attributes with aliases sets incorrectly cased aliased attributes on HTML attributes with a warning" name="ReactDOMComponent Attributes with aliases sets incorrectly cased aliased attributes on HTML attributes with a warning" time="0.063">
    </testcase>
    <testcase classname="ReactDOMComponent Attributes with aliases sets aliased attributes on SVG elements with a warning" name="ReactDOMComponent Attributes with aliases sets aliased attributes on SVG elements with a warning" time="0.102">
    </testcase>
    <testcase classname="ReactDOMComponent Attributes with aliases sets aliased attributes on custom elements" name="ReactDOMComponent Attributes with aliases sets aliased attributes on custom elements" time="0.051">
    </testcase>
    <testcase classname="ReactDOMComponent Attributes with aliases aliased attributes on custom elements with bad casing" name="ReactDOMComponent Attributes with aliases aliased attributes on custom elements with bad casing" time="0.038">
    </testcase>
    <testcase classname="ReactDOMComponent Attributes with aliases updates aliased attributes on custom elements" name="ReactDOMComponent Attributes with aliases updates aliased attributes on custom elements" time="0.059">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes allows assignment of custom attributes with string values" name="ReactDOMComponent Custom attributes allows assignment of custom attributes with string values" time="0.048">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes removes custom attributes" name="ReactDOMComponent Custom attributes removes custom attributes" time="0.06">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes does not assign a boolean custom attributes as a string" name="ReactDOMComponent Custom attributes does not assign a boolean custom attributes as a string" time="0.041">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes does not assign an implicit boolean custom attributes" name="ReactDOMComponent Custom attributes does not assign an implicit boolean custom attributes" time="0.055">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes assigns a numeric custom attributes as a string" name="ReactDOMComponent Custom attributes assigns a numeric custom attributes as a string" time="0.055">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes will not assign a function custom attributes" name="ReactDOMComponent Custom attributes will not assign a function custom attributes" time="0.055">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes will assign an object custom attributes" name="ReactDOMComponent Custom attributes will assign an object custom attributes" time="0.04">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes allows Temporal-like objects as HTML (they are not coerced to strings first)" name="ReactDOMComponent Custom attributes allows Temporal-like objects as HTML (they are not coerced to strings first)" time="0.053">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes allows cased data attributes" name="ReactDOMComponent Custom attributes allows cased data attributes" time="0.053">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes allows cased custom attributes" name="ReactDOMComponent Custom attributes allows cased custom attributes" time="0.097">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes warns on NaN attributes" name="ReactDOMComponent Custom attributes warns on NaN attributes" time="0.06">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes removes a property when it becomes invalid" name="ReactDOMComponent Custom attributes removes a property when it becomes invalid" time="0.044">
    </testcase>
    <testcase classname="ReactDOMComponent Custom attributes warns on bad casing of known HTML attributes" name="ReactDOMComponent Custom attributes warns on bad casing of known HTML attributes" time="0.082">
    </testcase>
    <testcase classname="ReactDOMComponent Object stringification allows objects on known properties" name="ReactDOMComponent Object stringification allows objects on known properties" time="0.025">
    </testcase>
    <testcase classname="ReactDOMComponent Object stringification should pass objects as attributes if they define toString" name="ReactDOMComponent Object stringification should pass objects as attributes if they define toString" time="0.058">
    </testcase>
    <testcase classname="ReactDOMComponent Object stringification passes objects on known SVG attributes if they do not define toString" name="ReactDOMComponent Object stringification passes objects on known SVG attributes if they do not define toString" time="0.065">
    </testcase>
    <testcase classname="ReactDOMComponent Object stringification passes objects on custom attributes if they do not define toString" name="ReactDOMComponent Object stringification passes objects on custom attributes if they do not define toString" time="0.093">
    </testcase>
    <testcase classname="ReactDOMComponent Object stringification allows objects that inherit a custom toString method" name="ReactDOMComponent Object stringification allows objects that inherit a custom toString method" time="0.043">
    </testcase>
    <testcase classname="ReactDOMComponent Object stringification assigns ajaxify (an important internal FB attribute)" name="ReactDOMComponent Object stringification assigns ajaxify (an important internal FB attribute)" time="0.021">
    </testcase>
    <testcase classname="ReactDOMComponent String boolean attributes does not assign string boolean attributes for custom attributes" name="ReactDOMComponent String boolean attributes does not assign string boolean attributes for custom attributes" time="0.073">
    </testcase>
    <testcase classname="ReactDOMComponent String boolean attributes stringifies the boolean true for allowed attributes" name="ReactDOMComponent String boolean attributes stringifies the boolean true for allowed attributes" time="0.069">
    </testcase>
    <testcase classname="ReactDOMComponent String boolean attributes stringifies the boolean false for allowed attributes" name="ReactDOMComponent String boolean attributes stringifies the boolean false for allowed attributes" time="0.046">
    </testcase>
    <testcase classname="ReactDOMComponent String boolean attributes stringifies implicit booleans for allowed attributes" name="ReactDOMComponent String boolean attributes stringifies implicit booleans for allowed attributes" time="0.035">
    </testcase>
    <testcase classname="ReactDOMComponent Boolean attributes warns on the ambiguous string value &quot;false&quot;" name="ReactDOMComponent Boolean attributes warns on the ambiguous string value &quot;false&quot;" time="0.065">
    </testcase>
    <testcase classname="ReactDOMComponent Boolean attributes warns on the potentially-ambiguous string value &quot;true&quot;" name="ReactDOMComponent Boolean attributes warns on the potentially-ambiguous string value &quot;true&quot;" time="0.041">
    </testcase>
    <testcase classname="ReactDOMComponent Hyphenated SVG elements the font-face element is not a custom element" name="ReactDOMComponent Hyphenated SVG elements the font-face element is not a custom element" time="0.034">
    </testcase>
    <testcase classname="ReactDOMComponent Hyphenated SVG elements the font-face element does not allow unknown boolean values" name="ReactDOMComponent Hyphenated SVG elements the font-face element does not allow unknown boolean values" time="0.073">
    </testcase>
    <testcase classname="ReactDOMComponent Custom elements does not strip unknown boolean attributes" name="ReactDOMComponent Custom elements does not strip unknown boolean attributes" time="0.046">
    </testcase>
    <testcase classname="ReactDOMComponent Custom elements does not strip the on* attributes" name="ReactDOMComponent Custom elements does not strip the on* attributes" time="0.041">
    </testcase>
    <testcase classname="ReactDOMComponent receives events in specific order" name="ReactDOMComponent receives events in specific order" time="0.109">
    </testcase>
    <testcase classname="ReactDOMComponent iOS Tap Highlight adds onclick handler to elements with onClick prop" name="ReactDOMComponent iOS Tap Highlight adds onclick handler to elements with onClick prop" time="0.057">
    </testcase>
    <testcase classname="ReactDOMComponent iOS Tap Highlight adds onclick handler to a portal root" name="ReactDOMComponent iOS Tap Highlight adds onclick handler to a portal root" time="0.041">
    </testcase>
    <testcase classname="ReactDOMComponent iOS Tap Highlight does not add onclick handler to the React root" name="ReactDOMComponent iOS Tap Highlight does not add onclick handler to the React root" time="0.066">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMRoot-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:43" time="2.768" tests="29">
    <testcase classname="ReactDOMRoot renders children" name="ReactDOMRoot renders children" time="0.056">
    </testcase>
    <testcase classname="ReactDOMRoot warns if you import createRoot from react-dom" name="ReactDOMRoot warns if you import createRoot from react-dom" time="0.045">
    </testcase>
    <testcase classname="ReactDOMRoot warns if you import hydrateRoot from react-dom" name="ReactDOMRoot warns if you import hydrateRoot from react-dom" time="0.061">
    </testcase>
    <testcase classname="ReactDOMRoot warns if a callback parameter is provided to render" name="ReactDOMRoot warns if a callback parameter is provided to render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMRoot warn if a container is passed to root.render(...)" name="ReactDOMRoot warn if a container is passed to root.render(...)" time="0.041">
    </testcase>
    <testcase classname="ReactDOMRoot warn if a container is passed to root.render(...)" name="ReactDOMRoot warn if a container is passed to root.render(...)" time="0.078">
    </testcase>
    <testcase classname="ReactDOMRoot warns if a callback parameter is provided to unmount" name="ReactDOMRoot warns if a callback parameter is provided to unmount" time="0.08">
    </testcase>
    <testcase classname="ReactDOMRoot unmounts children" name="ReactDOMRoot unmounts children" time="0.043">
    </testcase>
    <testcase classname="ReactDOMRoot supports hydration" name="ReactDOMRoot supports hydration" time="0.074">
    </testcase>
    <testcase classname="ReactDOMRoot clears existing children with legacy API" name="ReactDOMRoot clears existing children with legacy API" time="0.047">
    </testcase>
    <testcase classname="ReactDOMRoot clears existing children" name="ReactDOMRoot clears existing children" time="0.071">
    </testcase>
    <testcase classname="ReactDOMRoot throws a good message on invalid containers" name="ReactDOMRoot throws a good message on invalid containers" time="0.06">
    </testcase>
    <testcase classname="ReactDOMRoot warns when rendering with legacy API into createRoot() container" name="ReactDOMRoot warns when rendering with legacy API into createRoot() container" time="0.048">
    </testcase>
    <testcase classname="ReactDOMRoot warns when hydrating with legacy API into createRoot() container" name="ReactDOMRoot warns when hydrating with legacy API into createRoot() container" time="0.053">
    </testcase>
    <testcase classname="ReactDOMRoot callback passed to legacy hydrate() API" name="ReactDOMRoot callback passed to legacy hydrate() API" time="0.035">
    </testcase>
    <testcase classname="ReactDOMRoot warns when unmounting with legacy API (no previous content)" name="ReactDOMRoot warns when unmounting with legacy API (no previous content)" time="0.038">
    </testcase>
    <testcase classname="ReactDOMRoot warns when unmounting with legacy API (has previous content)" name="ReactDOMRoot warns when unmounting with legacy API (has previous content)" time="0.052">
    </testcase>
    <testcase classname="ReactDOMRoot warns when passing legacy container to createRoot()" name="ReactDOMRoot warns when passing legacy container to createRoot()" time="0.11">
    </testcase>
    <testcase classname="ReactDOMRoot warns when creating two roots managing the same container" name="ReactDOMRoot warns when creating two roots managing the same container" time="0.039">
    </testcase>
    <testcase classname="ReactDOMRoot does not warn when creating second root after first one is unmounted" name="ReactDOMRoot does not warn when creating second root after first one is unmounted" time="0.041">
    </testcase>
    <testcase classname="ReactDOMRoot warns if creating a root on the document.body" name="ReactDOMRoot warns if creating a root on the document.body" time="0.065">
    </testcase>
    <testcase classname="ReactDOMRoot warns if updating a root that has had its contents removed" name="ReactDOMRoot warns if updating a root that has had its contents removed" time="0.044">
    </testcase>
    <testcase classname="ReactDOMRoot opts-in to concurrent default updates" name="ReactDOMRoot opts-in to concurrent default updates" time="0.085">
    </testcase>
    <testcase classname="ReactDOMRoot unmount is synchronous" name="ReactDOMRoot unmount is synchronous" time="0.138">
    </testcase>
    <testcase classname="ReactDOMRoot throws if an unmounted root is updated" name="ReactDOMRoot throws if an unmounted root is updated" time="0.3">
    </testcase>
    <testcase classname="ReactDOMRoot warns if root is unmounted inside an effect" name="ReactDOMRoot warns if root is unmounted inside an effect" time="0.088">
    </testcase>
    <testcase classname="ReactDOMRoot [GATED, SHOULD FAIL] errors if container is a comment node" name="ReactDOMRoot [GATED, SHOULD FAIL] errors if container is a comment node" time="0.095">
    </testcase>
    <testcase classname="ReactDOMRoot warn if no children passed to hydrateRoot" name="ReactDOMRoot warn if no children passed to hydrateRoot" time="0.047">
    </testcase>
    <testcase classname="ReactDOMRoot warn if JSX passed to createRoot" name="ReactDOMRoot warn if JSX passed to createRoot" time="0.085">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/DOMPropertyOperations-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:43" time="3.659" tests="43">
    <testcase classname="DOMPropertyOperations setValueForProperty should set values as properties by default" name="DOMPropertyOperations setValueForProperty should set values as properties by default" time="0.095">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should set values as attributes if necessary" name="DOMPropertyOperations setValueForProperty should set values as attributes if necessary" time="0.049">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should set values as namespace attributes if necessary" name="DOMPropertyOperations setValueForProperty should set values as namespace attributes if necessary" time="0.064">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should set values as boolean properties" name="DOMPropertyOperations setValueForProperty should set values as boolean properties" time="0.028">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should convert attribute values to string first" name="DOMPropertyOperations setValueForProperty should convert attribute values to string first" time="0.073">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should not remove empty attributes for special input properties" name="DOMPropertyOperations setValueForProperty should not remove empty attributes for special input properties" time="0.042">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should not remove empty attributes for special option properties" name="DOMPropertyOperations setValueForProperty should not remove empty attributes for special option properties" time="0.068">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should remove for falsey boolean properties" name="DOMPropertyOperations setValueForProperty should remove for falsey boolean properties" time="0.053">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should remove when setting custom attr to null" name="DOMPropertyOperations setValueForProperty should remove when setting custom attr to null" time="0.089">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should set className to empty string instead of null" name="DOMPropertyOperations setValueForProperty should set className to empty string instead of null" time="0.038">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should remove property properly for boolean properties" name="DOMPropertyOperations setValueForProperty should remove property properly for boolean properties" time="0.057">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should always assign the value attribute for non-inputs" name="DOMPropertyOperations setValueForProperty should always assign the value attribute for non-inputs" time="0.054">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty should return the progress to intermediate state on null value" name="DOMPropertyOperations setValueForProperty should return the progress to intermediate state on null value" time="0.041">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element custom events lowercase" name="DOMPropertyOperations setValueForProperty custom element custom events lowercase" time="0.083">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element custom events uppercase" name="DOMPropertyOperations setValueForProperty custom element custom events uppercase" time="0.034">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element custom event with dash in name" name="DOMPropertyOperations setValueForProperty custom element custom event with dash in name" time="0.056">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element remove event handler" name="DOMPropertyOperations setValueForProperty custom element remove event handler" time="0.038">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom elements shouldnt have non-functions for on* attributes treated as event listeners" name="DOMPropertyOperations setValueForProperty custom elements shouldnt have non-functions for on* attributes treated as event listeners" time="0.061">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom elements should still have onClick treated like regular elements" name="DOMPropertyOperations setValueForProperty custom elements should still have onClick treated like regular elements" time="0.054">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom elements should have working onChange event listeners" name="DOMPropertyOperations setValueForProperty custom elements should have working onChange event listeners" time="0.068">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom elements should have working onInput event listeners" name="DOMPropertyOperations setValueForProperty custom elements should have working onInput event listeners" time="0.061">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom elements should have separate onInput and onChange handling" name="DOMPropertyOperations setValueForProperty custom elements should have separate onInput and onChange handling" time="0.05">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom elements should be able to remove and re-add custom event listeners" name="DOMPropertyOperations setValueForProperty custom elements should be able to remove and re-add custom event listeners" time="0.069">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty &lt;input is=...&gt; should have the same onChange/onInput/onClick behavior as &lt;input&gt;" name="DOMPropertyOperations setValueForProperty &lt;input is=...&gt; should have the same onChange/onInput/onClick behavior as &lt;input&gt;" time="0.063">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty &lt;input type=radio is=...&gt; should have the same onChange/onInput/onClick behavior as &lt;input type=radio&gt;" name="DOMPropertyOperations setValueForProperty &lt;input type=radio is=...&gt; should have the same onChange/onInput/onClick behavior as &lt;input type=radio&gt;" time="0.092">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty &lt;select is=...&gt; should have the same onChange/onInput/onClick behavior as &lt;select&gt;" name="DOMPropertyOperations setValueForProperty &lt;select is=...&gt; should have the same onChange/onInput/onClick behavior as &lt;select&gt;" time="0.061">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty onChange/onInput/onClick on div with various types of children" name="DOMPropertyOperations setValueForProperty onChange/onInput/onClick on div with various types of children" time="0.102">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element onChange/onInput/onClick with event target input child" name="DOMPropertyOperations setValueForProperty custom element onChange/onInput/onClick with event target input child" time="0.085">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element onChange/onInput/onClick with event target div child" name="DOMPropertyOperations setValueForProperty custom element onChange/onInput/onClick with event target div child" time="0.043">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty div onChange/onInput/onClick with event target div child" name="DOMPropertyOperations setValueForProperty div onChange/onInput/onClick with event target div child" time="0.041">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element onChange/onInput/onClick with event target custom element child" name="DOMPropertyOperations setValueForProperty custom element onChange/onInput/onClick with event target custom element child" time="0.087">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom elements should allow custom events with capture event listeners" name="DOMPropertyOperations setValueForProperty custom elements should allow custom events with capture event listeners" time="0.042">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty innerHTML should not work on custom elements" name="DOMPropertyOperations setValueForProperty innerHTML should not work on custom elements" time="0.057">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty innerText should not work on custom elements" name="DOMPropertyOperations setValueForProperty innerText should not work on custom elements" time="0.08">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty textContent should not work on custom elements" name="DOMPropertyOperations setValueForProperty textContent should not work on custom elements" time="0.052">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty values should not be converted to booleans when assigning into custom elements" name="DOMPropertyOperations setValueForProperty values should not be converted to booleans when assigning into custom elements" time="0.063">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element custom event handlers assign multiple types" name="DOMPropertyOperations setValueForProperty custom element custom event handlers assign multiple types" time="0.077">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element custom event handlers assign multiple types with setter" name="DOMPropertyOperations setValueForProperty custom element custom event handlers assign multiple types with setter" time="0.041">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty assigning to a custom element property should not remove attributes" name="DOMPropertyOperations setValueForProperty assigning to a custom element property should not remove attributes" time="0.038">
    </testcase>
    <testcase classname="DOMPropertyOperations setValueForProperty custom element properties should accept functions" name="DOMPropertyOperations setValueForProperty custom element properties should accept functions" time="0.083">
    </testcase>
    <testcase classname="DOMPropertyOperations deleteValueForProperty should remove attributes for normal properties" name="DOMPropertyOperations deleteValueForProperty should remove attributes for normal properties" time="0.057">
    </testcase>
    <testcase classname="DOMPropertyOperations deleteValueForProperty should not remove attributes for special properties" name="DOMPropertyOperations deleteValueForProperty should not remove attributes for special properties" time="0.057">
    </testcase>
    <testcase classname="DOMPropertyOperations deleteValueForProperty should not remove attributes for custom component tag" name="DOMPropertyOperations deleteValueForProperty should not remove attributes for custom component tag" time="0.037">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMFiber-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:44" time="2.725" tests="43">
    <testcase classname="ReactDOMFiber should render strings as children" name="ReactDOMFiber should render strings as children" time="0.026">
    </testcase>
    <testcase classname="ReactDOMFiber should render numbers as children" name="ReactDOMFiber should render numbers as children" time="0.004">
    </testcase>
    <testcase classname="ReactDOMFiber should be called a callback argument" name="ReactDOMFiber should be called a callback argument" time="0.004">
    </testcase>
    <testcase classname="ReactDOMFiber should call a callback argument when the same element is re-rendered" name="ReactDOMFiber should call a callback argument when the same element is re-rendered" time="0.018">
    </testcase>
    <testcase classname="ReactDOMFiber should render a component returning strings directly from render" name="ReactDOMFiber should render a component returning strings directly from render" time="0.003">
    </testcase>
    <testcase classname="ReactDOMFiber should render a component returning numbers directly from render" name="ReactDOMFiber should render a component returning numbers directly from render" time="0.003">
    </testcase>
    <testcase classname="ReactDOMFiber finds the DOM Text node of a string child" name="ReactDOMFiber finds the DOM Text node of a string child" time="0.015">
    </testcase>
    <testcase classname="ReactDOMFiber finds the first child when a component returns a fragment" name="ReactDOMFiber finds the first child when a component returns a fragment" time="0.006">
    </testcase>
    <testcase classname="ReactDOMFiber finds the first child even when fragment is nested" name="ReactDOMFiber finds the first child even when fragment is nested" time="0.021">
    </testcase>
    <testcase classname="ReactDOMFiber finds the first child even when first child renders null" name="ReactDOMFiber finds the first child even when first child renders null" time="0.005">
    </testcase>
    <testcase classname="ReactDOMFiber renders an empty fragment" name="ReactDOMFiber renders an empty fragment" time="0.028">
    </testcase>
    <testcase classname="ReactDOMFiber should render one portal" name="ReactDOMFiber should render one portal" time="0.01">
    </testcase>
    <testcase classname="ReactDOMFiber should render many portals" name="ReactDOMFiber should render many portals" time="0.068">
    </testcase>
    <testcase classname="ReactDOMFiber should render nested portals" name="ReactDOMFiber should render nested portals" time="0.03">
    </testcase>
    <testcase classname="ReactDOMFiber should reconcile portal children" name="ReactDOMFiber should reconcile portal children" time="0.035">
    </testcase>
    <testcase classname="ReactDOMFiber should unmount empty portal component wherever it appears" name="ReactDOMFiber should unmount empty portal component wherever it appears" time="0.005">
    </testcase>
    <testcase classname="ReactDOMFiber should keep track of namespace across portals (simple)" name="ReactDOMFiber should keep track of namespace across portals (simple)" time="0.044">
    </testcase>
    <testcase classname="ReactDOMFiber should keep track of namespace across portals (medium)" name="ReactDOMFiber should keep track of namespace across portals (medium)" time="0.138">
    </testcase>
    <testcase classname="ReactDOMFiber should keep track of namespace across portals (complex)" name="ReactDOMFiber should keep track of namespace across portals (complex)" time="0.027">
    </testcase>
    <testcase classname="ReactDOMFiber should unwind namespaces on uncaught errors" name="ReactDOMFiber should unwind namespaces on uncaught errors" time="0.015">
    </testcase>
    <testcase classname="ReactDOMFiber should unwind namespaces on caught errors" name="ReactDOMFiber should unwind namespaces on caught errors" time="0.059">
    </testcase>
    <testcase classname="ReactDOMFiber should unwind namespaces on caught errors in a portal" name="ReactDOMFiber should unwind namespaces on caught errors in a portal" time="0.009">
    </testcase>
    <testcase classname="ReactDOMFiber should pass portal context when rendering subtree elsewhere" name="ReactDOMFiber should pass portal context when rendering subtree elsewhere" time="0.003">
    </testcase>
    <testcase classname="ReactDOMFiber should update portal context if it changes due to setState" name="ReactDOMFiber should update portal context if it changes due to setState" time="0.004">
    </testcase>
    <testcase classname="ReactDOMFiber should update portal context if it changes due to re-render" name="ReactDOMFiber should update portal context if it changes due to re-render" time="0.019">
    </testcase>
    <testcase classname="ReactDOMFiber findDOMNode should find dom element after expanding a fragment" name="ReactDOMFiber findDOMNode should find dom element after expanding a fragment" time="0.003">
    </testcase>
    <testcase classname="ReactDOMFiber should bubble events from the portal to the parent" name="ReactDOMFiber should bubble events from the portal to the parent" time="0.003">
    </testcase>
    <testcase classname="ReactDOMFiber should not onMouseLeave when staying in the portal" name="ReactDOMFiber should not onMouseLeave when staying in the portal" time="0.031">
    </testcase>
    <testcase classname="ReactDOMFiber does not fire mouseEnter twice when relatedTarget is the root node" name="ReactDOMFiber does not fire mouseEnter twice when relatedTarget is the root node" time="0.006">
    </testcase>
    <testcase classname="ReactDOMFiber listens to events that do not exist in the Portal subtree" name="ReactDOMFiber listens to events that do not exist in the Portal subtree" time="0.002">
    </testcase>
    <testcase classname="ReactDOMFiber should throw on bad createPortal argument" name="ReactDOMFiber should throw on bad createPortal argument" time="0.001">
    </testcase>
    <testcase classname="ReactDOMFiber should warn for non-functional event listeners" name="ReactDOMFiber should warn for non-functional event listeners" time="0.018">
    </testcase>
    <testcase classname="ReactDOMFiber should warn with a special message for `false` event listeners" name="ReactDOMFiber should warn with a special message for `false` event listeners" time="0.003">
    </testcase>
    <testcase classname="ReactDOMFiber should not update event handlers until commit" name="ReactDOMFiber should not update event handlers until commit" time="0.024">
    </testcase>
    <testcase classname="ReactDOMFiber should not crash encountering low-priority tree" name="ReactDOMFiber should not crash encountering low-priority tree" time="0.002">
    </testcase>
    <testcase classname="ReactDOMFiber should not warn when rendering into an empty container" name="ReactDOMFiber should not warn when rendering into an empty container" time="0.003">
    </testcase>
    <testcase classname="ReactDOMFiber should warn when replacing a container which was manually updated outside of React" name="ReactDOMFiber should warn when replacing a container which was manually updated outside of React" time="0.023">
    </testcase>
    <testcase classname="ReactDOMFiber should warn when doing an update to a container manually updated outside of React" name="ReactDOMFiber should warn when doing an update to a container manually updated outside of React" time="0.008">
    </testcase>
    <testcase classname="ReactDOMFiber should warn when doing an update to a container manually cleared outside of React" name="ReactDOMFiber should warn when doing an update to a container manually cleared outside of React" time="0.003">
    </testcase>
    <testcase classname="ReactDOMFiber should render a text component with a text DOM node on the same document as the container" name="ReactDOMFiber should render a text component with a text DOM node on the same document as the container" time="0.051">
    </testcase>
    <testcase classname="ReactDOMFiber should mount into a document fragment" name="ReactDOMFiber should mount into a document fragment" time="0.002">
    </testcase>
    <testcase classname="ReactDOMFiber should not diff memoized host components" name="ReactDOMFiber should not diff memoized host components" time="0.019">
    </testcase>
    <testcase classname="ReactDOMFiber unmounted legacy roots should never clear newer root content from a container" name="ReactDOMFiber unmounted legacy roots should never clear newer root content from a container" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMSelect-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:45" time="4.528" tests="53">
    <testcase classname="ReactDOMSelect should allow setting `defaultValue`" name="ReactDOMSelect should allow setting `defaultValue`" time="0.092">
    </testcase>
    <testcase classname="ReactDOMSelect should not throw with `defaultValue` and without children" name="ReactDOMSelect should not throw with `defaultValue` and without children" time="0.09">
    </testcase>
    <testcase classname="ReactDOMSelect should not control when using `defaultValue`" name="ReactDOMSelect should not control when using `defaultValue`" time="0.045">
    </testcase>
    <testcase classname="ReactDOMSelect should allow setting `defaultValue` with multiple" name="ReactDOMSelect should allow setting `defaultValue` with multiple" time="0.066">
    </testcase>
    <testcase classname="ReactDOMSelect should allow setting `value`" name="ReactDOMSelect should allow setting `value`" time="0.05">
    </testcase>
    <testcase classname="ReactDOMSelect should default to the first non-disabled option" name="ReactDOMSelect should default to the first non-disabled option" time="0.077">
    </testcase>
    <testcase classname="ReactDOMSelect should allow setting `value` to __proto__" name="ReactDOMSelect should allow setting `value` to __proto__" time="0.047">
    </testcase>
    <testcase classname="ReactDOMSelect should not throw with `value` and without children" name="ReactDOMSelect should not throw with `value` and without children" time="0.044">
    </testcase>
    <testcase classname="ReactDOMSelect should allow setting `value` with multiple" name="ReactDOMSelect should allow setting `value` with multiple" time="0.055">
    </testcase>
    <testcase classname="ReactDOMSelect should allow setting `value` to __proto__ with multiple" name="ReactDOMSelect should allow setting `value` to __proto__ with multiple" time="0.086">
    </testcase>
    <testcase classname="ReactDOMSelect should not select other options automatically" name="ReactDOMSelect should not select other options automatically" time="0.056">
    </testcase>
    <testcase classname="ReactDOMSelect should reset child options selected when they are changed and `value` is set" name="ReactDOMSelect should reset child options selected when they are changed and `value` is set" time="0.093">
    </testcase>
    <testcase classname="ReactDOMSelect should allow setting `value` with `objectToString`" name="ReactDOMSelect should allow setting `value` with `objectToString`" time="0.083">
    </testcase>
    <testcase classname="ReactDOMSelect should allow switching to multiple" name="ReactDOMSelect should allow switching to multiple" time="0.066">
    </testcase>
    <testcase classname="ReactDOMSelect should allow switching from multiple" name="ReactDOMSelect should allow switching from multiple" time="0.068">
    </testcase>
    <testcase classname="ReactDOMSelect does not select an item when size is initially set to greater than 1" name="ReactDOMSelect does not select an item when size is initially set to greater than 1" time="0.035">
    </testcase>
    <testcase classname="ReactDOMSelect should remember value when switching to uncontrolled" name="ReactDOMSelect should remember value when switching to uncontrolled" time="0.091">
    </testcase>
    <testcase classname="ReactDOMSelect should remember updated value when switching to uncontrolled" name="ReactDOMSelect should remember updated value when switching to uncontrolled" time="0.052">
    </testcase>
    <testcase classname="ReactDOMSelect should support server-side rendering" name="ReactDOMSelect should support server-side rendering" time="0.098">
    </testcase>
    <testcase classname="ReactDOMSelect should support server-side rendering with defaultValue" name="ReactDOMSelect should support server-side rendering with defaultValue" time="0.067">
    </testcase>
    <testcase classname="ReactDOMSelect should support server-side rendering with dangerouslySetInnerHTML" name="ReactDOMSelect should support server-side rendering with dangerouslySetInnerHTML" time="0.05">
    </testcase>
    <testcase classname="ReactDOMSelect should support server-side rendering with multiple" name="ReactDOMSelect should support server-side rendering with multiple" time="0.039">
    </testcase>
    <testcase classname="ReactDOMSelect should not control defaultValue if re-adding options" name="ReactDOMSelect should not control defaultValue if re-adding options" time="0.08">
    </testcase>
    <testcase classname="ReactDOMSelect should support options with dynamic children" name="ReactDOMSelect should support options with dynamic children" time="0.068">
    </testcase>
    <testcase classname="ReactDOMSelect should warn if value is null" name="ReactDOMSelect should warn if value is null" time="0.091">
    </testcase>
    <testcase classname="ReactDOMSelect should warn if selected is set on &lt;option&gt;" name="ReactDOMSelect should warn if selected is set on &lt;option&gt;" time="0.059">
    </testcase>
    <testcase classname="ReactDOMSelect should warn if value is null and multiple is true" name="ReactDOMSelect should warn if value is null and multiple is true" time="0.056">
    </testcase>
    <testcase classname="ReactDOMSelect should refresh state on change" name="ReactDOMSelect should refresh state on change" time="0.074">
    </testcase>
    <testcase classname="ReactDOMSelect should warn if value and defaultValue props are specified" name="ReactDOMSelect should warn if value and defaultValue props are specified" time="0.07">
    </testcase>
    <testcase classname="ReactDOMSelect should not warn about missing onChange in uncontrolled textareas" name="ReactDOMSelect should not warn about missing onChange in uncontrolled textareas" time="0.066">
    </testcase>
    <testcase classname="ReactDOMSelect should be able to safely remove select onChange" name="ReactDOMSelect should be able to safely remove select onChange" time="0.05">
    </testcase>
    <testcase classname="ReactDOMSelect should select grandchild options nested inside an optgroup" name="ReactDOMSelect should select grandchild options nested inside an optgroup" time="0.062">
    </testcase>
    <testcase classname="ReactDOMSelect should allow controlling `value` in a nested render" name="ReactDOMSelect should allow controlling `value` in a nested render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMSelect should not select first option by default when multiple is set and no defaultValue is set" name="ReactDOMSelect should not select first option by default when multiple is set and no defaultValue is set" time="0.063">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Symbol value treats initial Symbol value as an empty string" name="ReactDOMSelect When given a Symbol value treats initial Symbol value as an empty string" time="0.064">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Symbol value treats updated Symbol value as an empty string" name="ReactDOMSelect When given a Symbol value treats updated Symbol value as an empty string" time="0.098">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Symbol value treats initial Symbol defaultValue as an empty string" name="ReactDOMSelect When given a Symbol value treats initial Symbol defaultValue as an empty string" time="0.037">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Symbol value treats updated Symbol defaultValue as an empty string" name="ReactDOMSelect When given a Symbol value treats updated Symbol defaultValue as an empty string" time="0.089">
    </testcase>
    <testcase classname="ReactDOMSelect When given a function value treats initial function value as an empty string" name="ReactDOMSelect When given a function value treats initial function value as an empty string" time="0.064">
    </testcase>
    <testcase classname="ReactDOMSelect When given a function value treats initial function defaultValue as an empty string" name="ReactDOMSelect When given a function value treats initial function defaultValue as an empty string" time="0.053">
    </testcase>
    <testcase classname="ReactDOMSelect When given a function value treats updated function value as an empty string" name="ReactDOMSelect When given a function value treats updated function value as an empty string" time="0.056">
    </testcase>
    <testcase classname="ReactDOMSelect When given a function value treats updated function defaultValue as an empty string" name="ReactDOMSelect When given a function value treats updated function defaultValue as an empty string" time="0.058">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like value (select)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like value (select)" time="0.046">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like value (option)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like value (option)" time="0.068">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like value (both)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like value (both)" time="0.061">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like value (select)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like value (select)" time="0.079">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like value (option)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like value (option)" time="0.035">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like value (both)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like value (both)" time="0.057">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like defaultValue (select)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like defaultValue (select)" time="0.053">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like defaultValue (option)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like defaultValue (option)" time="0.064">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like value (both)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws when given a Temporal.PlainDate-like value (both)" time="0.048">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like defaultValue (select)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like defaultValue (select)" time="0.08">
    </testcase>
    <testcase classname="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like defaultValue (both)" name="ReactDOMSelect When given a Temporal.PlainDate-like value throws with updated Temporal.PlainDate-like defaultValue (both)" time="0.054">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactMultiChildReconcile-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:47" time="2.517" tests="29">
    <testcase classname="ReactMultiChildReconcile should reset internal state if removed then readded in an array" name="ReactMultiChildReconcile should reset internal state if removed then readded in an array" time="0.006">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should reset internal state if removed then readded in a legacy iterable" name="ReactMultiChildReconcile should reset internal state if removed then readded in a legacy iterable" time="0.007">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should reset internal state if removed then readded in a modern iterable" name="ReactMultiChildReconcile should reset internal state if removed then readded in a modern iterable" time="0.007">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should create unique identity" name="ReactMultiChildReconcile should create unique identity" time="0.062">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should preserve order if children order has not changed" name="ReactMultiChildReconcile should preserve order if children order has not changed" time="0.056">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should transition from zero to one children correctly" name="ReactMultiChildReconcile should transition from zero to one children correctly" time="0.053">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should transition from one to zero children correctly" name="ReactMultiChildReconcile should transition from one to zero children correctly" time="0.084">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should transition from one child to null children" name="ReactMultiChildReconcile should transition from one child to null children" time="0.086">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should transition from null children to one child" name="ReactMultiChildReconcile should transition from null children to one child" time="0.043">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should transition from zero children to null children" name="ReactMultiChildReconcile should transition from zero children to null children" time="0.028">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should transition from null children to zero children" name="ReactMultiChildReconcile should transition from null children to zero children" time="0.034">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should remove nulled out children at the beginning" name="ReactMultiChildReconcile should remove nulled out children at the beginning" time="0.089">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should remove nulled out children at the end" name="ReactMultiChildReconcile should remove nulled out children at the end" time="0.031">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should reverse the order of two children" name="ReactMultiChildReconcile should reverse the order of two children" time="0.023">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should reverse the order of more than two children" name="ReactMultiChildReconcile should reverse the order of more than two children" time="0.051">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should cycle order correctly" name="ReactMultiChildReconcile should cycle order correctly" time="0.07">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should cycle order correctly in the other direction" name="ReactMultiChildReconcile should cycle order correctly in the other direction" time="0.085">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should remove nulled out children and ignore new null children" name="ReactMultiChildReconcile should remove nulled out children and ignore new null children" time="0.022">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should remove nulled out children and reorder remaining" name="ReactMultiChildReconcile should remove nulled out children and reorder remaining" time="0.015">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should append children to the end" name="ReactMultiChildReconcile should append children to the end" time="0.044">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should append multiple children to the end" name="ReactMultiChildReconcile should append multiple children to the end" time="0.04">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should prepend children to the beginning" name="ReactMultiChildReconcile should prepend children to the beginning" time="0.014">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should prepend multiple children to the beginning" name="ReactMultiChildReconcile should prepend multiple children to the beginning" time="0.046">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should not prepend an empty child to the beginning" name="ReactMultiChildReconcile should not prepend an empty child to the beginning" time="0.022">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should not append an empty child to the end" name="ReactMultiChildReconcile should not append an empty child to the end" time="0.022">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should not insert empty children in the middle" name="ReactMultiChildReconcile should not insert empty children in the middle" time="0.054">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should insert one new child in the middle" name="ReactMultiChildReconcile should insert one new child in the middle" time="0.019">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should insert multiple new truthy children in the middle" name="ReactMultiChildReconcile should insert multiple new truthy children in the middle" time="0.041">
    </testcase>
    <testcase classname="ReactMultiChildReconcile should insert non-empty children in middle where nulls were" name="ReactMultiChildReconcile should insert non-empty children in middle where nulls were" time="0.026">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationUserInteraction-test.js" errors="0" failures="0" skipped="2" timestamp="2022-08-05T04:11:46" time="3.146" tests="22">
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled text input with clean client render" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled text input with clean client render" time="0.162">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled text input with client render on top of good server markup" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled text input with client render on top of good server markup" time="0.216">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled text input with client render on top of bad server markup" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled text input with client render on top of bad server markup" time="0.194">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled textarea with clean client render" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled textarea with clean client render" time="0.164">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled textarea with client render on top of good server markup" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled textarea with client render on top of good server markup" time="0.164">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled textarea with client render on top of bad server markup" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled textarea with client render on top of bad server markup" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled checkbox with clean client render" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled checkbox with clean client render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled checkbox with client render on top of good server markup" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled checkbox with client render on top of good server markup" time="0.12">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled checkbox with client render on top of bad server markup" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled checkbox with client render on top of bad server markup" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled select with clean client render" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled select with clean client render" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled select with client render on top of good server markup" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled select with client render on top of good server markup" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled select with client render on top of bad server markup" name="ReactDOMServerIntegrationUserInteraction user interaction with controlled inputs renders a controlled select with client render on top of bad server markup" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to an uncontrolled input" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to an uncontrolled input" time="0.152">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to a controlled input" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to a controlled input" time="0.112">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-interaction on successful reconnect to an uncontrolled range input" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-interaction on successful reconnect to an uncontrolled range input" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-interaction on successful reconnect to a controlled range input" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-interaction on successful reconnect to a controlled range input" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to an uncontrolled checkbox" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to an uncontrolled checkbox" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to a controlled checkbox" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to a controlled checkbox" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to an uncontrolled textarea" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to an uncontrolled textarea" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to a controlled textarea" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-entered text on successful reconnect to a controlled textarea" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-selected value on successful reconnect to an uncontrolled select" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-selected value on successful reconnect to an uncontrolled select" time="0.135">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-selected value on successful reconnect to an controlled select" name="ReactDOMServerIntegrationUserInteraction user interaction with inputs before client render should not blow away user-selected value on successful reconnect to an controlled select" time="0.091">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test-1.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:44" time="6.28" tests="80">
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with server string render" name="ReactDOMServerIntegration elements and children text children renders a div with text with server string render" time="0.097">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with server stream render" name="ReactDOMServerIntegration elements and children text children renders a div with text with server stream render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with clean client render" name="ReactDOMServerIntegration elements and children text children renders a div with text with clean client render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a div with text with client render on top of good server markup" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a div with text with client render on top of bad server markup" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with server string render" name="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with server string render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with server stream render" name="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with server stream render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with clean client render" name="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with client render on top of good server markup" time="0.129">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a div with text with flanking whitespace with client render on top of bad server markup" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with server string render" name="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with server string render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with server stream render" name="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with server stream render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with clean client render" name="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with client render on top of good server markup" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a div with an empty text child with client render on top of bad server markup" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with server string render" name="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with server string render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with server stream render" name="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with server stream render" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with clean client render" name="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with client render on top of good server markup" time="0.123">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a div with multiple empty text children with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with server string render" name="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with server string render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with server stream render" name="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with clean client render" name="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with clean client render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with client render on top of good server markup" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a div with multiple whitespace children with client render on top of bad server markup" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with server string render" name="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with server string render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with server stream render" name="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with server stream render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with clean client render" name="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with clean client render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with client render on top of good server markup" time="0.153">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a div with text sibling to a node with client render on top of bad server markup" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with server string render" name="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with server string render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with server stream render" name="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with server stream render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with clean client render" name="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with clean client render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with client render on top of good server markup" time="0.112">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a non-standard element with text with client render on top of bad server markup" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a custom element with text with server string render" name="ReactDOMServerIntegration elements and children text children renders a custom element with text with server string render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a custom element with text with server stream render" name="ReactDOMServerIntegration elements and children text children renders a custom element with text with server stream render" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a custom element with text with clean client render" name="ReactDOMServerIntegration elements and children text children renders a custom element with text with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a custom element with text with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a custom element with text with client render on top of good server markup" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a custom element with text with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a custom element with text with client render on top of bad server markup" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with server string render" name="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with server string render" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with server stream render" name="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with server stream render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with clean client render" name="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with clean client render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with client render on top of good server markup" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a leading blank child with a text sibling with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with server string render" name="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with server string render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with server stream render" name="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with server stream render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with clean client render" name="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with clean client render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with client render on top of good server markup" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a trailing blank child with a text sibling with client render on top of bad server markup" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders an element with two text children with server string render" name="ReactDOMServerIntegration elements and children text children renders an element with two text children with server string render" time="0.03">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders an element with two text children with server stream render" name="ReactDOMServerIntegration elements and children text children renders an element with two text children with server stream render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders an element with two text children with clean client render" name="ReactDOMServerIntegration elements and children text children renders an element with two text children with clean client render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders an element with two text children with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders an element with two text children with client render on top of good server markup" time="0.148">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders an element with two text children with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders an element with two text children with client render on top of bad server markup" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with server string render" name="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with server string render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with server stream render" name="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with server stream render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with clean client render" name="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with clean client render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with client render on top of good server markup" time="0.1">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a component returning text node between two text nodes with client render on top of bad server markup" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with server string render" name="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with server string render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with server stream render" name="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with clean client render" name="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with client render on top of good server markup" name="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with client render on top of good server markup" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children text children renders a tree with sibling host and text nodes with client render on top of bad server markup" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders a number as single child with server string render" name="ReactDOMServerIntegration elements and children number children renders a number as single child with server string render" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders a number as single child with server stream render" name="ReactDOMServerIntegration elements and children number children renders a number as single child with server stream render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders a number as single child with clean client render" name="ReactDOMServerIntegration elements and children number children renders a number as single child with clean client render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders a number as single child with client render on top of good server markup" name="ReactDOMServerIntegration elements and children number children renders a number as single child with client render on top of good server markup" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders a number as single child with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children number children renders a number as single child with client render on top of bad server markup" time="0.029">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders zero as single child with server string render" name="ReactDOMServerIntegration elements and children number children renders zero as single child with server string render" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders zero as single child with server stream render" name="ReactDOMServerIntegration elements and children number children renders zero as single child with server stream render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders zero as single child with clean client render" name="ReactDOMServerIntegration elements and children number children renders zero as single child with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders zero as single child with client render on top of good server markup" name="ReactDOMServerIntegration elements and children number children renders zero as single child with client render on top of good server markup" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders zero as single child with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children number children renders zero as single child with client render on top of bad server markup" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders an element with number and text children with server string render" name="ReactDOMServerIntegration elements and children number children renders an element with number and text children with server string render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders an element with number and text children with server stream render" name="ReactDOMServerIntegration elements and children number children renders an element with number and text children with server stream render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders an element with number and text children with clean client render" name="ReactDOMServerIntegration elements and children number children renders an element with number and text children with clean client render" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders an element with number and text children with client render on top of good server markup" name="ReactDOMServerIntegration elements and children number children renders an element with number and text children with client render on top of good server markup" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children number children renders an element with number and text children with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children number children renders an element with number and text children with client render on top of bad server markup" time="0.066">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactLegacyContextDisabled-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:50" time="0.596" tests="2">
    <testcase classname="ReactLegacyContextDisabled warns for legacy context" name="ReactLegacyContextDisabled warns for legacy context" time="0.108">
    </testcase>
    <testcase classname="ReactLegacyContextDisabled renders a tree with modern context" name="ReactLegacyContextDisabled renders a tree with modern context" time="0.068">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/InvalidEventListeners-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:50" time="0.867" tests="2">
    <testcase classname="InvalidEventListeners should prevent non-function listeners, at dispatch" name="InvalidEventListeners should prevent non-function listeners, at dispatch" time="0.116">
    </testcase>
    <testcase classname="InvalidEventListeners should not prevent null listeners, at dispatch" name="InvalidEventListeners should not prevent null listeners, at dispatch" time="0.07">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactWrongReturnPointer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:51" time="0.446" tests="1">
    <testcase classname=" regression (#20932): return pointer is correct before entering deleted tree" name=" regression (#20932): return pointer is correct before entering deleted tree" time="0.145">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationNewContext-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:45" time="6.895" tests="68">
    <testcase classname="ReactDOMServerIntegration context renders class child with context with server string render" name="ReactDOMServerIntegration context renders class child with context with server string render" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with context with server stream render" name="ReactDOMServerIntegration context renders class child with context with server stream render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with context with clean client render" name="ReactDOMServerIntegration context renders class child with context with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with context with client render on top of good server markup" name="ReactDOMServerIntegration context renders class child with context with client render on top of good server markup" time="0.142">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with context with client render on top of bad server markup" name="ReactDOMServerIntegration context renders class child with context with client render on top of bad server markup" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with context with server string render" name="ReactDOMServerIntegration context renders stateless child with context with server string render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with context with server stream render" name="ReactDOMServerIntegration context renders stateless child with context with server stream render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with context with clean client render" name="ReactDOMServerIntegration context renders stateless child with context with clean client render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with context with client render on top of good server markup" name="ReactDOMServerIntegration context renders stateless child with context with client render on top of good server markup" time="0.116">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with context with client render on top of bad server markup" name="ReactDOMServerIntegration context renders stateless child with context with client render on top of bad server markup" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with default context with server string render" name="ReactDOMServerIntegration context renders class child with default context with server string render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with default context with server stream render" name="ReactDOMServerIntegration context renders class child with default context with server stream render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with default context with clean client render" name="ReactDOMServerIntegration context renders class child with default context with clean client render" time="0.141">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with default context with client render on top of good server markup" name="ReactDOMServerIntegration context renders class child with default context with client render on top of good server markup" time="0.364">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders class child with default context with client render on top of bad server markup" name="ReactDOMServerIntegration context renders class child with default context with client render on top of bad server markup" time="0.152">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with wrong context with server string render" name="ReactDOMServerIntegration context renders stateless child with wrong context with server string render" time="0.201">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with wrong context with server stream render" name="ReactDOMServerIntegration context renders stateless child with wrong context with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with wrong context with clean client render" name="ReactDOMServerIntegration context renders stateless child with wrong context with clean client render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with wrong context with client render on top of good server markup" name="ReactDOMServerIntegration context renders stateless child with wrong context with client render on top of good server markup" time="0.161">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders stateless child with wrong context with client render on top of bad server markup" name="ReactDOMServerIntegration context renders stateless child with wrong context with client render on top of bad server markup" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders with context passed through to a grandchild with server string render" name="ReactDOMServerIntegration context renders with context passed through to a grandchild with server string render" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders with context passed through to a grandchild with server stream render" name="ReactDOMServerIntegration context renders with context passed through to a grandchild with server stream render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders with context passed through to a grandchild with clean client render" name="ReactDOMServerIntegration context renders with context passed through to a grandchild with clean client render" time="0.15">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders with context passed through to a grandchild with client render on top of good server markup" name="ReactDOMServerIntegration context renders with context passed through to a grandchild with client render on top of good server markup" time="0.245">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders with context passed through to a grandchild with client render on top of bad server markup" name="ReactDOMServerIntegration context renders with context passed through to a grandchild with client render on top of bad server markup" time="0.166">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders a child context overriding a parent context with server string render" name="ReactDOMServerIntegration context renders a child context overriding a parent context with server string render" time="0.143">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders a child context overriding a parent context with server stream render" name="ReactDOMServerIntegration context renders a child context overriding a parent context with server stream render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders a child context overriding a parent context with clean client render" name="ReactDOMServerIntegration context renders a child context overriding a parent context with clean client render" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders a child context overriding a parent context with client render on top of good server markup" name="ReactDOMServerIntegration context renders a child context overriding a parent context with client render on top of good server markup" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders a child context overriding a parent context with client render on top of bad server markup" name="ReactDOMServerIntegration context renders a child context overriding a parent context with client render on top of bad server markup" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders readContext() in different components with server string render" name="ReactDOMServerIntegration context renders readContext() in different components with server string render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders readContext() in different components with server stream render" name="ReactDOMServerIntegration context renders readContext() in different components with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders readContext() in different components with clean client render" name="ReactDOMServerIntegration context renders readContext() in different components with clean client render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders readContext() in different components with client render on top of good server markup" name="ReactDOMServerIntegration context renders readContext() in different components with client render on top of good server markup" time="0.109">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders readContext() in different components with client render on top of bad server markup" name="ReactDOMServerIntegration context renders readContext() in different components with client render on top of bad server markup" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders multiple contexts with server string render" name="ReactDOMServerIntegration context renders multiple contexts with server string render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders multiple contexts with server stream render" name="ReactDOMServerIntegration context renders multiple contexts with server stream render" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders multiple contexts with clean client render" name="ReactDOMServerIntegration context renders multiple contexts with clean client render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders multiple contexts with client render on top of good server markup" name="ReactDOMServerIntegration context renders multiple contexts with client render on top of good server markup" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders multiple contexts with client render on top of bad server markup" name="ReactDOMServerIntegration context renders multiple contexts with client render on top of bad server markup" time="0.094">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders nested context unwinding with server string render" name="ReactDOMServerIntegration context renders nested context unwinding with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders nested context unwinding with server stream render" name="ReactDOMServerIntegration context renders nested context unwinding with server stream render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders nested context unwinding with clean client render" name="ReactDOMServerIntegration context renders nested context unwinding with clean client render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders nested context unwinding with client render on top of good server markup" name="ReactDOMServerIntegration context renders nested context unwinding with client render on top of good server markup" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders nested context unwinding with client render on top of bad server markup" name="ReactDOMServerIntegration context renders nested context unwinding with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with server string render" name="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with server string render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with server stream render" name="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with server stream render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with clean client render" name="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with clean client render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with client render on top of good server markup" name="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with client render on top of good server markup" time="0.124">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with client render on top of bad server markup" name="ReactDOMServerIntegration context renders should warn with an error message when using Context as consumer in DEV with client render on top of bad server markup" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with server string render" name="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with server string render" time="0.087">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with server stream render" name="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with server stream render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with clean client render" name="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with client render on top of good server markup" name="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with client render on top of good server markup" time="0.134">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with client render on top of bad server markup" name="ReactDOMServerIntegration context renders should not warn when using Consumer from React &lt; 16.6 with newer renderer with client render on top of bad server markup" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with server string render" name="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with server string render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with server stream render" name="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with server stream render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with clean client render" name="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with client render on top of good server markup" name="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with client render on top of good server markup" time="0.123">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with client render on top of bad server markup" name="ReactDOMServerIntegration context renders should warn with an error message when using nested context consumers in DEV with client render on top of bad server markup" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with server string render" name="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with server string render" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with server stream render" name="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with server stream render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with clean client render" name="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with clean client render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with client render on top of good server markup" name="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with client render on top of good server markup" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with client render on top of bad server markup" name="ReactDOMServerIntegration context renders should warn with an error message when using Context.Consumer.Provider DEV with client render on top of bad server markup" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context does not pollute parallel node streams" name="ReactDOMServerIntegration context does not pollute parallel node streams" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context does not pollute parallel node streams when many are used" name="ReactDOMServerIntegration context does not pollute parallel node streams when many are used" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegration context does not pollute sync renders after an error" name="ReactDOMServerIntegration context does not pollute sync renders after an error" time="0.058">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/refs-destruction-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:51" time="0.59" tests="4">
    <testcase classname="refs-destruction should remove refs when destroying the parent" name="refs-destruction should remove refs when destroying the parent" time="0.091">
    </testcase>
    <testcase classname="refs-destruction should remove refs when destroying the child" name="refs-destruction should remove refs when destroying the child" time="0.045">
    </testcase>
    <testcase classname="refs-destruction should remove refs when removing the child ref attribute" name="refs-destruction should remove refs when removing the child ref attribute" time="0.062">
    </testcase>
    <testcase classname="refs-destruction should not error when destroying child with ref asynchronously" name="refs-destruction should not error when destroying child with ref asynchronously" time="0.056">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactLegacyRootWarnings-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:51" time="0.956" tests="2">
    <testcase classname="ReactDOMRoot deprecation warning for ReactDOM.render" name="ReactDOMRoot deprecation warning for ReactDOM.render" time="0.083">
    </testcase>
    <testcase classname="ReactDOMRoot deprecation warning for ReactDOM.hydrate" name="ReactDOMRoot deprecation warning for ReactDOM.hydrate" time="0.101">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactErrorBoundariesHooks-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:53" time="0.418" tests="1">
    <testcase classname="ReactErrorBoundariesHooks should preserve hook order if errors are caught" name="ReactErrorBoundariesHooks should preserve hook order if errors are caught" time="0.131">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMAttribute-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:52" time="1.596" tests="11">
    <testcase classname="ReactDOM unknown attribute unknown attributes removes values null and undefined" name="ReactDOM unknown attribute unknown attributes removes values null and undefined" time="0.124">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes changes values true, false to null, and also warns once" name="ReactDOM unknown attribute unknown attributes changes values true, false to null, and also warns once" time="0.099">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes removes unknown attributes that were rendered but are now missing" name="ReactDOM unknown attribute unknown attributes removes unknown attributes that were rendered but are now missing" time="0.065">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes passes through strings" name="ReactDOM unknown attribute unknown attributes passes through strings" time="0.055">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes coerces numbers to strings" name="ReactDOM unknown attribute unknown attributes coerces numbers to strings" time="0.104">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes coerces NaN to strings and warns" name="ReactDOM unknown attribute unknown attributes coerces NaN to strings and warns" time="0.069">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes coerces objects to strings and warns" name="ReactDOM unknown attribute unknown attributes coerces objects to strings and warns" time="0.074">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes throws with Temporal-like objects" name="ReactDOM unknown attribute unknown attributes throws with Temporal-like objects" time="0.071">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes removes symbols and warns" name="ReactDOM unknown attribute unknown attributes removes symbols and warns" time="0.068">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes removes functions and warns" name="ReactDOM unknown attribute unknown attributes removes functions and warns" time="0.059">
    </testcase>
    <testcase classname="ReactDOM unknown attribute unknown attributes allows camelCase unknown attributes and warns" name="ReactDOM unknown attribute unknown attributes allows camelCase unknown attributes and warns" time="0.109">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/escapeTextForBrowser-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:53" time="0.551" tests="8">
    <testcase classname="escapeTextForBrowser ampersand is escaped when passed as text content" name="escapeTextForBrowser ampersand is escaped when passed as text content" time="0.077">
    </testcase>
    <testcase classname="escapeTextForBrowser double quote is escaped when passed as text content" name="escapeTextForBrowser double quote is escaped when passed as text content" time="0.015">
    </testcase>
    <testcase classname="escapeTextForBrowser single quote is escaped when passed as text content" name="escapeTextForBrowser single quote is escaped when passed as text content" time="0.026">
    </testcase>
    <testcase classname="escapeTextForBrowser greater than entity is escaped when passed as text content" name="escapeTextForBrowser greater than entity is escaped when passed as text content" time="0.019">
    </testcase>
    <testcase classname="escapeTextForBrowser lower than entity is escaped when passed as text content" name="escapeTextForBrowser lower than entity is escaped when passed as text content" time="0.028">
    </testcase>
    <testcase classname="escapeTextForBrowser number is correctly passed as text content" name="escapeTextForBrowser number is correctly passed as text content" time="0.017">
    </testcase>
    <testcase classname="escapeTextForBrowser number is escaped to string when passed as text content" name="escapeTextForBrowser number is escaped to string when passed as text content" time="0.019">
    </testcase>
    <testcase classname="escapeTextForBrowser escape text content representing a script tag" name="escapeTextForBrowser escape text content representing a script tag" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactTestUtilsActUnmockedScheduler-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:54" time="0.701" tests="5">
    <testcase classname=" can use act to flush effects" name=" can use act to flush effects" time="0.042">
    </testcase>
    <testcase classname=" flushes effects on every call" name=" flushes effects on every call" time="0.103">
    </testcase>
    <testcase classname=" should keep flushing effects until they&apos;re done" name=" should keep flushing effects until they&apos;re done" time="0.068">
    </testcase>
    <testcase classname=" should flush effects only on exiting the outermost act" name=" should flush effects only on exiting the outermost act" time="0.057">
    </testcase>
    <testcase classname=" can handle cascading promises" name=" can handle cascading promises" time="0.088">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/validateDOMNesting-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:54" time="0.736" tests="2">
    <testcase classname="validateDOMNesting allows valid nestings" name="validateDOMNesting allows valid nestings" time="0.056">
    </testcase>
    <testcase classname="validateDOMNesting prevents problematic nestings" name="validateDOMNesting prevents problematic nestings" time="0.043">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactFunctionComponent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:54" time="1.87" tests="19">
    <testcase classname="ReactFunctionComponent should render stateless component" name="ReactFunctionComponent should render stateless component" time="0.104">
    </testcase>
    <testcase classname="ReactFunctionComponent should update stateless component" name="ReactFunctionComponent should update stateless component" time="0.05">
    </testcase>
    <testcase classname="ReactFunctionComponent should unmount stateless component" name="ReactFunctionComponent should unmount stateless component" time="0.062">
    </testcase>
    <testcase classname="ReactFunctionComponent should pass context thru stateless component" name="ReactFunctionComponent should pass context thru stateless component" time="0.092">
    </testcase>
    <testcase classname="ReactFunctionComponent should warn for getDerivedStateFromProps on a function component" name="ReactFunctionComponent should warn for getDerivedStateFromProps on a function component" time="0.056">
    </testcase>
    <testcase classname="ReactFunctionComponent should warn for childContextTypes on a function component" name="ReactFunctionComponent should warn for childContextTypes on a function component" time="0.09">
    </testcase>
    <testcase classname="ReactFunctionComponent should not throw when stateless component returns undefined" name="ReactFunctionComponent should not throw when stateless component returns undefined" time="0.047">
    </testcase>
    <testcase classname="ReactFunctionComponent should throw on string refs in pure functions" name="ReactFunctionComponent should throw on string refs in pure functions" time="0.082">
    </testcase>
    <testcase classname="ReactFunctionComponent should warn when given a string ref" name="ReactFunctionComponent should warn when given a string ref" time="0.093">
    </testcase>
    <testcase classname="ReactFunctionComponent should warn when given a function ref" name="ReactFunctionComponent should warn when given a function ref" time="0.058">
    </testcase>
    <testcase classname="ReactFunctionComponent deduplicates ref warnings based on element or owner" name="ReactFunctionComponent deduplicates ref warnings based on element or owner" time="0.088">
    </testcase>
    <testcase classname="ReactFunctionComponent should warn when giving a function ref with context" name="ReactFunctionComponent should warn when giving a function ref with context" time="0.048">
    </testcase>
    <testcase classname="ReactFunctionComponent should provide a null ref" name="ReactFunctionComponent should provide a null ref" time="0.062">
    </testcase>
    <testcase classname="ReactFunctionComponent should use correct name in key warning" name="ReactFunctionComponent should use correct name in key warning" time="0.055">
    </testcase>
    <testcase classname="ReactFunctionComponent should support default props and prop types" name="ReactFunctionComponent should support default props and prop types" time="0.069">
    </testcase>
    <testcase classname="ReactFunctionComponent should receive context" name="ReactFunctionComponent should receive context" time="0.059">
    </testcase>
    <testcase classname="ReactFunctionComponent should work with arrow functions" name="ReactFunctionComponent should work with arrow functions" time="0.081">
    </testcase>
    <testcase classname="ReactFunctionComponent should allow simple functions to return null" name="ReactFunctionComponent should allow simple functions to return null" time="0.051">
    </testcase>
    <testcase classname="ReactFunctionComponent should allow simple functions to return false" name="ReactFunctionComponent should allow simple functions to return false" time="0.063">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerSuspense-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:55" time="1.312" tests="13">
    <testcase classname="ReactDOMServerSuspense should render the children when no promise is thrown" name="ReactDOMServerSuspense should render the children when no promise is thrown" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerSuspense should render the fallback when a promise thrown" name="ReactDOMServerSuspense should render the fallback when a promise thrown" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerSuspense should work with nested suspense components" name="ReactDOMServerSuspense should work with nested suspense components" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerSuspense server renders a SuspenseList component and its children" name="ReactDOMServerSuspense server renders a SuspenseList component and its children" time="0.095">
    </testcase>
    <testcase classname="ReactDOMServerSuspense throws when rendering a suspending component outside a Suspense node with server string render" name="ReactDOMServerSuspense throws when rendering a suspending component outside a Suspense node with server string render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerSuspense throws when rendering a suspending component outside a Suspense node with clean client render" name="ReactDOMServerSuspense throws when rendering a suspending component outside a Suspense node with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerSuspense throws when rendering a suspending component outside a Suspense node with client render on top of bad server markup" name="ReactDOMServerSuspense throws when rendering a suspending component outside a Suspense node with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerSuspense throws when rendering a suspending component without a Suspense above with server string render" name="ReactDOMServerSuspense throws when rendering a suspending component without a Suspense above with server string render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerSuspense throws when rendering a suspending component without a Suspense above with clean client render" name="ReactDOMServerSuspense throws when rendering a suspending component without a Suspense above with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerSuspense throws when rendering a suspending component without a Suspense above with client render on top of bad server markup" name="ReactDOMServerSuspense throws when rendering a suspending component without a Suspense above with client render on top of bad server markup" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerSuspense does not get confused by throwing null" name="ReactDOMServerSuspense does not get confused by throwing null" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerSuspense does not get confused by throwing undefined" name="ReactDOMServerSuspense does not get confused by throwing undefined" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerSuspense does not get confused by throwing a primitive" name="ReactDOMServerSuspense does not get confused by throwing a primitive" time="0.07">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationAttributes2-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:45" time="13.504" tests="155">
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with server string render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with server string render" time="0.13">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with server stream render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with server stream render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with clean client render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with clean client render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with client render on top of good server markup" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders simple styles with client render on top of bad server markup" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with server string render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with server string render" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with server stream render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with server stream render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with clean client render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with clean client render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with client render on top of good server markup" time="0.123">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders relevant styles with px with client render on top of bad server markup" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with server string render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with server string render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with server stream render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with server stream render" time="0.097">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with clean client render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with clean client render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with client render on top of good server markup" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders custom properties with client render on top of bad server markup" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with server string render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with server string render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with server stream render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with server stream render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with clean client render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with clean client render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with client render on top of good server markup" time="0.119">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders camel cased custom properties with client render on top of bad server markup" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with server string render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with server string render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with server stream render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with clean client render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with client render on top of good server markup" time="0.145">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no undefined styles with client render on top of bad server markup" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with server string render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with server string render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with server stream render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with server stream render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with clean client render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with client render on top of good server markup" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no null styles with client render on top of bad server markup" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with server string render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with server string render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with server stream render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with server stream render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with clean client render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with clean client render" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with client render on top of good server markup" time="0.119">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders no empty styles with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with server string render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with server string render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with server stream render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with server stream render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with clean client render" name="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with clean client render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with client render on top of good server markup" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping inline styles renders unitless-number rules with prefixes with client render on top of bad server markup" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with server string render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with server string render" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with server stream render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with server stream render" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with clean client render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with clean client render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with client render on top of good server markup" time="0.11">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders simple strings with client render on top of bad server markup" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with server string render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with server string render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with server stream render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with server stream render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with clean client render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with client render on top of good server markup" time="0.12">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders aria string prop with false value with client render on top of bad server markup" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with server string render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with server string render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with server stream render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with server stream render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with clean client render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with client render on top of good server markup" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders no aria prop with null value with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with server string render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with server string render" time="0.029">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with server stream render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with clean client render" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with client render on top of good server markup" time="0.112">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping aria attributes renders &quot;aria&quot; attribute with a warning with client render on top of bad server markup" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with server string render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with server string render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with server stream render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with server stream render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with clean client render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with client render on top of good server markup" time="0.136">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased aliased HTML attribute with a warning with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with server string render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with server string render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with server stream render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with server stream render" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with clean client render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with client render on top of good server markup" time="0.132">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders badly cased SVG attribute with a warning with client render on top of bad server markup" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with server string render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with server string render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with server stream render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with server stream render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with clean client render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with clean client render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with client render on top of good server markup" time="0.136">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased aliased SVG attribute alias with client render on top of bad server markup" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with server string render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with server string render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with server stream render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with clean client render" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with clean client render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with client render on top of good server markup" time="0.133">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping cased attributes renders no badly cased original SVG attribute that is aliased with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with server stream render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with clean client render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with client render on top of good server markup" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown attributes with client render on top of bad server markup" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with server string render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with server stream render" time="0.141">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with clean client render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with client render on top of good server markup" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with client render on top of bad server markup" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with server string render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with server stream render" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with clean client render" time="0.22">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with client render on top of good server markup" time="0.292">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders badly cased reserved attributes with client render on top of bad server markup" time="0.16">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with server string render" time="0.157">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with server stream render" time="0.128">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with clean client render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with client render on top of good server markup" time="0.13">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders &quot;data&quot; attribute with client render on top of bad server markup" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with server string render" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with server stream render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with clean client render" time="0.148">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with client render on top of good server markup" time="0.213">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with null value with client render on top of bad server markup" time="0.219">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with server string render" time="0.194">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with server stream render" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with clean client render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with client render on top of good server markup" time="0.111">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with casing with client render on top of bad server markup" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with server string render" time="0.099">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with server stream render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with clean client render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with client render on top of good server markup" time="0.123">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean true with client render on top of bad server markup" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with server string render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with server stream render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with clean client render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with client render on top of good server markup" time="0.111">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders unknown data- attributes with boolean false with client render on top of bad server markup" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with server string render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with server stream render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with clean client render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with client render on top of good server markup" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders no unknown data- attributes with casing and null value with client render on top of bad server markup" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with server string render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with server stream render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with client render on top of good server markup" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders custom attributes for non-standard elements with client render on top of bad server markup" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with server string render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with server stream render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with client render on top of good server markup" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders SVG tags with dashes in them with client render on top of bad server markup" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with server string render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with server string render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with server stream render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with server stream render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with clean client render" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with clean client render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with client render on top of good server markup" time="0.144">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping unknown attributes renders cased custom attributes with client render on top of bad server markup" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no HTML events with server string render" name="ReactDOMServerIntegration property to attribute mapping renders no HTML events with server string render" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no HTML events with server stream render" name="ReactDOMServerIntegration property to attribute mapping renders no HTML events with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no HTML events with clean client render" name="ReactDOMServerIntegration property to attribute mapping renders no HTML events with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no HTML events with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping renders no HTML events with client render on top of good server markup" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no HTML events with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping renders no HTML events with client render on top of bad server markup" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no unknown events with server string render" name="ReactDOMServerIntegration property to attribute mapping renders no unknown events with server string render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no unknown events with server stream render" name="ReactDOMServerIntegration property to attribute mapping renders no unknown events with server stream render" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no unknown events with clean client render" name="ReactDOMServerIntegration property to attribute mapping renders no unknown events with clean client render" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no unknown events with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping renders no unknown events with client render on top of good server markup" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders no unknown events with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping renders no unknown events with client render on top of bad server markup" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with server string render" name="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with server string render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with server stream render" name="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with server stream render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with clean client render" name="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with clean client render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with client render on top of good server markup" time="0.141">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping renders custom attribute named `on` with client render on top of bad server markup" time="0.044">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactComponentLifeCycle-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:57" time="2.972" tests="32">
    <testcase classname="ReactComponentLifeCycle should not reuse an instance when it has been unmounted" name="ReactComponentLifeCycle should not reuse an instance when it has been unmounted" time="0.071">
    </testcase>
    <testcase classname="ReactComponentLifeCycle it should fire onDOMReady when already in onDOMReady" name="ReactComponentLifeCycle it should fire onDOMReady when already in onDOMReady" time="0.076">
    </testcase>
    <testcase classname="ReactComponentLifeCycle throws when accessing state in componentWillMount" name="ReactComponentLifeCycle throws when accessing state in componentWillMount" time="0.071">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should allow update state inside of componentWillMount" name="ReactComponentLifeCycle should allow update state inside of componentWillMount" time="0.05">
    </testcase>
    <testcase classname="ReactComponentLifeCycle warns if setting &apos;this.state = props&apos;" name="ReactComponentLifeCycle warns if setting &apos;this.state = props&apos;" time="0.046">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should not allow update state inside of getInitialState" name="ReactComponentLifeCycle should not allow update state inside of getInitialState" time="0.06">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should correctly determine if a component is mounted" name="ReactComponentLifeCycle should correctly determine if a component is mounted" time="0.048">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should correctly determine if a null component is mounted" name="ReactComponentLifeCycle should correctly determine if a null component is mounted" time="0.058">
    </testcase>
    <testcase classname="ReactComponentLifeCycle isMounted should return false when unmounted" name="ReactComponentLifeCycle isMounted should return false when unmounted" time="0.069">
    </testcase>
    <testcase classname="ReactComponentLifeCycle warns if findDOMNode is used inside render" name="ReactComponentLifeCycle warns if findDOMNode is used inside render" time="0.05">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should carry through each of the phases of setup" name="ReactComponentLifeCycle should carry through each of the phases of setup" time="0.064">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should not throw when updating an auxiliary component" name="ReactComponentLifeCycle should not throw when updating an auxiliary component" time="0.054">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should allow state updates in componentDidMount" name="ReactComponentLifeCycle should allow state updates in componentDidMount" time="0.069">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should call nested legacy lifecycle methods in the right order" name="ReactComponentLifeCycle should call nested legacy lifecycle methods in the right order" time="0.049">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should call nested new lifecycle methods in the right order" name="ReactComponentLifeCycle should call nested new lifecycle methods in the right order" time="0.073">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" name="ReactComponentLifeCycle should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" time="0.045">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" name="ReactComponentLifeCycle should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" time="0.049">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should not invoke new unsafe lifecycles (cWM/cWRP/cWU) if static gDSFP is present" name="ReactComponentLifeCycle should not invoke new unsafe lifecycles (cWM/cWRP/cWU) if static gDSFP is present" time="0.044">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should warn about deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" name="ReactComponentLifeCycle should warn about deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" time="0.085">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should warn about deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" name="ReactComponentLifeCycle should warn about deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" time="0.103">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should warn if getDerivedStateFromProps returns undefined" name="ReactComponentLifeCycle should warn if getDerivedStateFromProps returns undefined" time="0.023">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should warn if state is not initialized before getDerivedStateFromProps" name="ReactComponentLifeCycle should warn if state is not initialized before getDerivedStateFromProps" time="0.078">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should invoke both deprecated and new lifecycles if both are present" name="ReactComponentLifeCycle should invoke both deprecated and new lifecycles if both are present" time="0.063">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should not override state with stale values if prevState is spread within getDerivedStateFromProps" name="ReactComponentLifeCycle should not override state with stale values if prevState is spread within getDerivedStateFromProps" time="0.064">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should pass the return value from getSnapshotBeforeUpdate to componentDidUpdate" name="ReactComponentLifeCycle should pass the return value from getSnapshotBeforeUpdate to componentDidUpdate" time="0.068">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should pass previous state to shouldComponentUpdate even with getDerivedStateFromProps" name="ReactComponentLifeCycle should pass previous state to shouldComponentUpdate even with getDerivedStateFromProps" time="0.058">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should call getSnapshotBeforeUpdate before mutations are committed" name="ReactComponentLifeCycle should call getSnapshotBeforeUpdate before mutations are committed" time="0.045">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should warn if getSnapshotBeforeUpdate returns undefined" name="ReactComponentLifeCycle should warn if getSnapshotBeforeUpdate returns undefined" time="0.044">
    </testcase>
    <testcase classname="ReactComponentLifeCycle should warn if getSnapshotBeforeUpdate is defined with no componentDidUpdate" name="ReactComponentLifeCycle should warn if getSnapshotBeforeUpdate is defined with no componentDidUpdate" time="0.09">
    </testcase>
    <testcase classname="ReactComponentLifeCycle warns about deprecated unsafe lifecycles" name="ReactComponentLifeCycle warns about deprecated unsafe lifecycles" time="0.038">
    </testcase>
    <testcase classname="ReactComponentLifeCycle react-lifecycles-compat should not warn for components with polyfilled getDerivedStateFromProps" name="ReactComponentLifeCycle react-lifecycles-compat should not warn for components with polyfilled getDerivedStateFromProps" time="0.067">
    </testcase>
    <testcase classname="ReactComponentLifeCycle react-lifecycles-compat should not warn for components with polyfilled getSnapshotBeforeUpdate" name="ReactComponentLifeCycle react-lifecycles-compat should not warn for components with polyfilled getSnapshotBeforeUpdate" time="0.049">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:48" time="13.588" tests="143">
    <testcase classname="ReactDOMServerHooks useState renders basic render with server string render" name="ReactDOMServerHooks useState renders basic render with server string render" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders basic render with server stream render" name="ReactDOMServerHooks useState renders basic render with server stream render" time="0.141">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders basic render with clean client render" name="ReactDOMServerHooks useState renders basic render with clean client render" time="0.107">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders basic render with client render on top of good server markup" name="ReactDOMServerHooks useState renders basic render with client render on top of good server markup" time="0.295">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders basic render with client render on top of bad server markup" name="ReactDOMServerHooks useState renders basic render with client render on top of bad server markup" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders lazy state initialization with server string render" name="ReactDOMServerHooks useState renders lazy state initialization with server string render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders lazy state initialization with server stream render" name="ReactDOMServerHooks useState renders lazy state initialization with server stream render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders lazy state initialization with clean client render" name="ReactDOMServerHooks useState renders lazy state initialization with clean client render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders lazy state initialization with client render on top of good server markup" name="ReactDOMServerHooks useState renders lazy state initialization with client render on top of good server markup" time="0.117">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders lazy state initialization with client render on top of bad server markup" name="ReactDOMServerHooks useState renders lazy state initialization with client render on top of bad server markup" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState does not trigger a re-renders when updater is invoked outside current render function" name="ReactDOMServerHooks useState does not trigger a re-renders when updater is invoked outside current render function" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState throws when rendering if used inside a class component with server string render" name="ReactDOMServerHooks useState throws when rendering if used inside a class component with server string render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState throws when rendering if used inside a class component with clean client render" name="ReactDOMServerHooks useState throws when rendering if used inside a class component with clean client render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState throws when rendering if used inside a class component with client render on top of bad server markup" name="ReactDOMServerHooks useState throws when rendering if used inside a class component with client render on top of bad server markup" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders multiple times when an updater is called with server string render" name="ReactDOMServerHooks useState renders multiple times when an updater is called with server string render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders multiple times when an updater is called with server stream render" name="ReactDOMServerHooks useState renders multiple times when an updater is called with server stream render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders multiple times when an updater is called with clean client render" name="ReactDOMServerHooks useState renders multiple times when an updater is called with clean client render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders multiple times when an updater is called with client render on top of good server markup" name="ReactDOMServerHooks useState renders multiple times when an updater is called with client render on top of good server markup" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders multiple times when an updater is called with client render on top of bad server markup" name="ReactDOMServerHooks useState renders multiple times when an updater is called with client render on top of bad server markup" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders until there are no more new updates with server string render" name="ReactDOMServerHooks useState renders until there are no more new updates with server string render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders until there are no more new updates with server stream render" name="ReactDOMServerHooks useState renders until there are no more new updates with server stream render" time="0.083">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders until there are no more new updates with clean client render" name="ReactDOMServerHooks useState renders until there are no more new updates with clean client render" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders until there are no more new updates with client render on top of good server markup" name="ReactDOMServerHooks useState renders until there are no more new updates with client render on top of good server markup" time="0.219">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState renders until there are no more new updates with client render on top of bad server markup" name="ReactDOMServerHooks useState renders until there are no more new updates with client render on top of bad server markup" time="0.165">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState throws when rendering after too many iterations with server string render" name="ReactDOMServerHooks useState throws when rendering after too many iterations with server string render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState throws when rendering after too many iterations with clean client render" name="ReactDOMServerHooks useState throws when rendering after too many iterations with clean client render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerHooks useState throws when rendering after too many iterations with client render on top of bad server markup" name="ReactDOMServerHooks useState throws when rendering after too many iterations with client render on top of bad server markup" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders with initial state with server string render" name="ReactDOMServerHooks useReducer renders with initial state with server string render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders with initial state with server stream render" name="ReactDOMServerHooks useReducer renders with initial state with server stream render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders with initial state with clean client render" name="ReactDOMServerHooks useReducer renders with initial state with clean client render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders with initial state with client render on top of good server markup" name="ReactDOMServerHooks useReducer renders with initial state with client render on top of good server markup" time="0.092">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders with initial state with client render on top of bad server markup" name="ReactDOMServerHooks useReducer renders with initial state with client render on top of bad server markup" time="0.083">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders lazy initialization with server string render" name="ReactDOMServerHooks useReducer renders lazy initialization with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders lazy initialization with server stream render" name="ReactDOMServerHooks useReducer renders lazy initialization with server stream render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders lazy initialization with clean client render" name="ReactDOMServerHooks useReducer renders lazy initialization with clean client render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders lazy initialization with client render on top of good server markup" name="ReactDOMServerHooks useReducer renders lazy initialization with client render on top of good server markup" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders lazy initialization with client render on top of bad server markup" name="ReactDOMServerHooks useReducer renders lazy initialization with client render on top of bad server markup" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with server string render" name="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with server stream render" name="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with server stream render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with clean client render" name="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with client render on top of good server markup" name="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with client render on top of good server markup" time="0.196">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with client render on top of bad server markup" name="ReactDOMServerHooks useReducer renders multiple times when updates happen during the render phase with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with server string render" name="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with server string render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with server stream render" name="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with server stream render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with clean client render" name="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with clean client render" time="0.132">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with client render on top of good server markup" name="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with client render on top of good server markup" time="0.269">
    </testcase>
    <testcase classname="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with client render on top of bad server markup" name="ReactDOMServerHooks useReducer renders using reducer passed at time of render, not time of dispatch with client render on top of bad server markup" time="0.2">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders basic render with server string render" name="ReactDOMServerHooks useMemo renders basic render with server string render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders basic render with server stream render" name="ReactDOMServerHooks useMemo renders basic render with server stream render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders basic render with clean client render" name="ReactDOMServerHooks useMemo renders basic render with clean client render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders basic render with client render on top of good server markup" name="ReactDOMServerHooks useMemo renders basic render with client render on top of good server markup" time="0.111">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders basic render with client render on top of bad server markup" name="ReactDOMServerHooks useMemo renders basic render with client render on top of bad server markup" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders if no inputs are provided with server string render" name="ReactDOMServerHooks useMemo renders if no inputs are provided with server string render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders if no inputs are provided with server stream render" name="ReactDOMServerHooks useMemo renders if no inputs are provided with server stream render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders if no inputs are provided with clean client render" name="ReactDOMServerHooks useMemo renders if no inputs are provided with clean client render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders if no inputs are provided with client render on top of good server markup" name="ReactDOMServerHooks useMemo renders if no inputs are provided with client render on top of good server markup" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders if no inputs are provided with client render on top of bad server markup" name="ReactDOMServerHooks useMemo renders if no inputs are provided with client render on top of bad server markup" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with server string render" name="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with server string render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with server stream render" name="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with server stream render" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with clean client render" name="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with clean client render" time="0.03">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with client render on top of good server markup" name="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with client render on top of good server markup" time="0.107">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with client render on top of bad server markup" name="ReactDOMServerHooks useMemo renders multiple times when updates happen during the render phase with client render on top of bad server markup" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with server string render" name="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with server string render" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with server stream render" name="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with server stream render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with clean client render" name="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with clean client render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with client render on top of good server markup" name="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with client render on top of good server markup" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with client render on top of bad server markup" name="ReactDOMServerHooks useMemo renders should only invoke the memoized function when the inputs change with client render on top of bad server markup" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with server string render" name="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with server string render" time="0.026">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with server stream render" name="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with server stream render" time="0.034">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with clean client render" name="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with clean client render" time="0.191">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with client render on top of good server markup" name="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with client render on top of good server markup" time="0.343">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with client render on top of bad server markup" name="ReactDOMServerHooks useMemo renders with a warning for useState inside useMemo with client render on top of bad server markup" time="0.123">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo throws when rendering with a warning for useRef inside useReducer with server string render" name="ReactDOMServerHooks useMemo throws when rendering with a warning for useRef inside useReducer with server string render" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo throws when rendering with a warning for useRef inside useReducer with clean client render" name="ReactDOMServerHooks useMemo throws when rendering with a warning for useRef inside useReducer with clean client render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo throws when rendering with a warning for useRef inside useReducer with client render on top of bad server markup" name="ReactDOMServerHooks useMemo throws when rendering with a warning for useRef inside useReducer with client render on top of bad server markup" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with server string render" name="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with server string render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with server stream render" name="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with server stream render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with clean client render" name="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with client render on top of good server markup" name="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with client render on top of good server markup" time="0.092">
    </testcase>
    <testcase classname="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with client render on top of bad server markup" name="ReactDOMServerHooks useMemo renders with a warning for useRef inside useState with client render on top of bad server markup" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders basic render with server string render" name="ReactDOMServerHooks useRef renders basic render with server string render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders basic render with server stream render" name="ReactDOMServerHooks useRef renders basic render with server stream render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders basic render with clean client render" name="ReactDOMServerHooks useRef renders basic render with clean client render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders basic render with client render on top of good server markup" name="ReactDOMServerHooks useRef renders basic render with client render on top of good server markup" time="0.106">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders basic render with client render on top of bad server markup" name="ReactDOMServerHooks useRef renders basic render with client render on top of bad server markup" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with server string render" name="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with server string render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with server stream render" name="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with server stream render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with clean client render" name="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with clean client render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with client render on top of good server markup" name="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with client render on top of good server markup" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with client render on top of bad server markup" name="ReactDOMServerHooks useRef renders multiple times when updates happen during the render phase with client render on top of bad server markup" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with server string render" name="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with server string render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with server stream render" name="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with server stream render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with clean client render" name="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with clean client render" time="0.143">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with client render on top of good server markup" name="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with client render on top of good server markup" time="0.289">
    </testcase>
    <testcase classname="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with client render on top of bad server markup" name="ReactDOMServerHooks useRef renders always return the same reference through multiple renders with client render on top of bad server markup" time="0.174">
    </testcase>
    <testcase classname="ReactDOMServerHooks useEffect renders should ignore effects on the server with server string render" name="ReactDOMServerHooks useEffect renders should ignore effects on the server with server string render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerHooks useEffect renders should ignore effects on the server with server stream render" name="ReactDOMServerHooks useEffect renders should ignore effects on the server with server stream render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerHooks useEffect renders should ignore effects on the server with clean client render" name="ReactDOMServerHooks useEffect renders should ignore effects on the server with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerHooks useEffect renders should ignore effects on the server with client render on top of good server markup" name="ReactDOMServerHooks useEffect renders should ignore effects on the server with client render on top of good server markup" time="0.099">
    </testcase>
    <testcase classname="ReactDOMServerHooks useEffect renders should ignore effects on the server with client render on top of bad server markup" name="ReactDOMServerHooks useEffect renders should ignore effects on the server with client render on top of bad server markup" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerHooks useEffect verifies yields in order" name="ReactDOMServerHooks useEffect verifies yields in order" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with server string render" name="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with server string render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with server stream render" name="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with server stream render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with clean client render" name="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with clean client render" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with client render on top of good server markup" name="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with client render on top of good server markup" time="0.208">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with client render on top of bad server markup" name="ReactDOMServerHooks useCallback renders should not invoke the passed callbacks with client render on top of bad server markup" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should support render time callbacks with server string render" name="ReactDOMServerHooks useCallback renders should support render time callbacks with server string render" time="0.032">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should support render time callbacks with server stream render" name="ReactDOMServerHooks useCallback renders should support render time callbacks with server stream render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should support render time callbacks with clean client render" name="ReactDOMServerHooks useCallback renders should support render time callbacks with clean client render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should support render time callbacks with client render on top of good server markup" name="ReactDOMServerHooks useCallback renders should support render time callbacks with client render on top of good server markup" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should support render time callbacks with client render on top of bad server markup" name="ReactDOMServerHooks useCallback renders should support render time callbacks with client render on top of bad server markup" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with server string render" name="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with server string render" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with server stream render" name="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with server stream render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with clean client render" name="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with clean client render" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with client render on top of good server markup" name="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with client render on top of good server markup" time="0.311">
    </testcase>
    <testcase classname="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with client render on top of bad server markup" name="ReactDOMServerHooks useCallback renders should only change the returned reference when the inputs change with client render on top of bad server markup" time="0.141">
    </testcase>
    <testcase classname="ReactDOMServerHooks useImperativeHandle should not be invoked on the server" name="ReactDOMServerHooks useImperativeHandle should not be invoked on the server" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerHooks useInsertionEffect should warn when invoked during render" name="ReactDOMServerHooks useInsertionEffect should warn when invoked during render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerHooks useLayoutEffect should warn when invoked during render" name="ReactDOMServerHooks useLayoutEffect should warn when invoked during render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerHooks useContext throws when rendering if used inside a class component with server string render" name="ReactDOMServerHooks useContext throws when rendering if used inside a class component with server string render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerHooks useContext throws when rendering if used inside a class component with clean client render" name="ReactDOMServerHooks useContext throws when rendering if used inside a class component with clean client render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerHooks useContext throws when rendering if used inside a class component with client render on top of bad server markup" name="ReactDOMServerHooks useContext throws when rendering if used inside a class component with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerHooks renders can use the same context multiple times in the same function with server string render" name="ReactDOMServerHooks renders can use the same context multiple times in the same function with server string render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerHooks renders can use the same context multiple times in the same function with server stream render" name="ReactDOMServerHooks renders can use the same context multiple times in the same function with server stream render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerHooks renders can use the same context multiple times in the same function with clean client render" name="ReactDOMServerHooks renders can use the same context multiple times in the same function with clean client render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerHooks renders can use the same context multiple times in the same function with client render on top of good server markup" name="ReactDOMServerHooks renders can use the same context multiple times in the same function with client render on top of good server markup" time="0.134">
    </testcase>
    <testcase classname="ReactDOMServerHooks renders can use the same context multiple times in the same function with client render on top of bad server markup" name="ReactDOMServerHooks renders can use the same context multiple times in the same function with client render on top of bad server markup" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerHooks useDebugValue renders is a noop with server string render" name="ReactDOMServerHooks useDebugValue renders is a noop with server string render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerHooks useDebugValue renders is a noop with server stream render" name="ReactDOMServerHooks useDebugValue renders is a noop with server stream render" time="0.032">
    </testcase>
    <testcase classname="ReactDOMServerHooks useDebugValue renders is a noop with clean client render" name="ReactDOMServerHooks useDebugValue renders is a noop with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerHooks useDebugValue renders is a noop with client render on top of good server markup" name="ReactDOMServerHooks useDebugValue renders is a noop with client render on top of good server markup" time="0.111">
    </testcase>
    <testcase classname="ReactDOMServerHooks useDebugValue renders is a noop with client render on top of bad server markup" name="ReactDOMServerHooks useDebugValue renders is a noop with client render on top of bad server markup" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with server string render" name="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with server string render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with server stream render" name="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with server stream render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with clean client render" name="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with clean client render" time="0.113">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with client render on top of good server markup" name="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with client render on top of good server markup" time="0.336">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with client render on top of bad server markup" name="ReactDOMServerHooks readContext renders can read the same context multiple times in the same function with client render on top of bad server markup" time="0.165">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with server string render" name="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with server string render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with server stream render" name="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with server stream render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with clean client render" name="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with clean client render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with client render on top of good server markup" name="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with client render on top of good server markup" time="0.151">
    </testcase>
    <testcase classname="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with client render on top of bad server markup" name="ReactDOMServerHooks readContext renders with a warning inside useMemo and useReducer with client render on top of bad server markup" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerHooks renders successfully after a component using hooks throws an error" name="ReactDOMServerHooks renders successfully after a component using hooks throws an error" time="0.057">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/renderSubtreeIntoContainer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:01" time="0.525" tests="8">
    <testcase classname="renderSubtreeIntoContainer should pass context when rendering subtree elsewhere" name="renderSubtreeIntoContainer should pass context when rendering subtree elsewhere" time="0.007">
    </testcase>
    <testcase classname="renderSubtreeIntoContainer should throw if parentComponent is invalid" name="renderSubtreeIntoContainer should throw if parentComponent is invalid" time="0">
    </testcase>
    <testcase classname="renderSubtreeIntoContainer should update context if it changes due to setState" name="renderSubtreeIntoContainer should update context if it changes due to setState" time="0.016">
    </testcase>
    <testcase classname="renderSubtreeIntoContainer should update context if it changes due to re-render" name="renderSubtreeIntoContainer should update context if it changes due to re-render" time="0.027">
    </testcase>
    <testcase classname="renderSubtreeIntoContainer should render portal with non-context-provider parent" name="renderSubtreeIntoContainer should render portal with non-context-provider parent" time="0.004">
    </testcase>
    <testcase classname="renderSubtreeIntoContainer should get context through non-context-provider parent" name="renderSubtreeIntoContainer should get context through non-context-provider parent" time="0.01">
    </testcase>
    <testcase classname="renderSubtreeIntoContainer should get context through middle non-context-provider layer" name="renderSubtreeIntoContainer should get context through middle non-context-provider layer" time="0.045">
    </testcase>
    <testcase classname="renderSubtreeIntoContainer fails gracefully when mixing React 15 and 16" name="renderSubtreeIntoContainer fails gracefully when mixing React 15 and 16" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMFizzSuppressHydrationWarning-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:52" time="9.304" tests="12">
    <testcase classname="ReactDOMFizzServerHydrationWarning suppresses and fixes text mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning suppresses and fixes text mismatches with suppressHydrationWarning" time="2.31">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning suppresses and fixes multiple text node mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning suppresses and fixes multiple text node mismatches with suppressHydrationWarning" time="0.35">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning errors on text-to-element mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning errors on text-to-element mismatches with suppressHydrationWarning" time="0.389">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning suppresses and fixes client-only single text node mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning suppresses and fixes client-only single text node mismatches with suppressHydrationWarning" time="0.373">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning errors on server-only single text node mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning errors on server-only single text node mismatches with suppressHydrationWarning" time="0.9">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning errors on client-only extra text node mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning errors on client-only extra text node mismatches with suppressHydrationWarning" time="0.555">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning errors on server-only extra text node mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning errors on server-only extra text node mismatches with suppressHydrationWarning" time="1.016">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning errors on element-to-text mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning errors on element-to-text mismatches with suppressHydrationWarning" time="0.441">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning suppresses and does not fix attribute mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning suppresses and does not fix attribute mismatches with suppressHydrationWarning" time="0.83">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning suppresses and does not fix html mismatches with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning suppresses and does not fix html mismatches with suppressHydrationWarning" time="0.346">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning errors on insertions with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning errors on insertions with suppressHydrationWarning" time="0.317">
    </testcase>
    <testcase classname="ReactDOMFizzServerHydrationWarning errors on deletions with suppressHydrationWarning" name="ReactDOMFizzServerHydrationWarning errors on deletions with suppressHydrationWarning" time="0.373">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactCompositeComponentNestedState-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:02" time="0.388" tests="1">
    <testcase classname="ReactCompositeComponentNestedState-state should provide up to date values for props" name="ReactCompositeComponentNestedState-state should provide up to date values for props" time="0.119">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMSelection-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:02" time="1.915" tests="2">
    <testcase classname="ReactDOMSelection returns correctly for base case" name="ReactDOMSelection returns correctly for base case" time="0.085">
    </testcase>
    <testcase classname="ReactDOMSelection returns correctly for fuzz test" name="ReactDOMSelection returns correctly for fuzz test" time="1.116">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMSafariMicrotaskBug-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:04" time="0.77" tests="2">
    <testcase classname="ReactDOMSafariMicrotaskBug-test should deal with premature microtask in commit phase" name="ReactDOMSafariMicrotaskBug-test should deal with premature microtask in commit phase" time="0.099">
    </testcase>
    <testcase classname="ReactDOMSafariMicrotaskBug-test should deal with premature microtask in event handler" name="ReactDOMSafariMicrotaskBug-test should deal with premature microtask in event handler" time="0.054">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactUpdates-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:59" time="6.786" tests="43">
    <testcase classname="ReactUpdates should batch state when updating state twice" name="ReactUpdates should batch state when updating state twice" time="0.157">
    </testcase>
    <testcase classname="ReactUpdates should batch state when updating two different state keys" name="ReactUpdates should batch state when updating two different state keys" time="0.043">
    </testcase>
    <testcase classname="ReactUpdates should batch state and props together" name="ReactUpdates should batch state and props together" time="0.059">
    </testcase>
    <testcase classname="ReactUpdates should batch parent/child state updates together" name="ReactUpdates should batch parent/child state updates together" time="0.053">
    </testcase>
    <testcase classname="ReactUpdates should batch child/parent state updates together" name="ReactUpdates should batch child/parent state updates together" time="0.082">
    </testcase>
    <testcase classname="ReactUpdates should support chained state updates" name="ReactUpdates should support chained state updates" time="0.041">
    </testcase>
    <testcase classname="ReactUpdates should batch forceUpdate together" name="ReactUpdates should batch forceUpdate together" time="0.083">
    </testcase>
    <testcase classname="ReactUpdates should update children even if parent blocks updates" name="ReactUpdates should update children even if parent blocks updates" time="0.041">
    </testcase>
    <testcase classname="ReactUpdates should not reconcile children passed via props" name="ReactUpdates should not reconcile children passed via props" time="0.059">
    </testcase>
    <testcase classname="ReactUpdates should flow updates correctly" name="ReactUpdates should flow updates correctly" time="0.059">
    </testcase>
    <testcase classname="ReactUpdates should queue mount-ready handlers across different roots" name="ReactUpdates should queue mount-ready handlers across different roots" time="0.052">
    </testcase>
    <testcase classname="ReactUpdates should flush updates in the correct order" name="ReactUpdates should flush updates in the correct order" time="0.054">
    </testcase>
    <testcase classname="ReactUpdates should flush updates in the correct order across roots" name="ReactUpdates should flush updates in the correct order across roots" time="0.066">
    </testcase>
    <testcase classname="ReactUpdates should queue nested updates" name="ReactUpdates should queue nested updates" time="0.05">
    </testcase>
    <testcase classname="ReactUpdates should queue updates from during mount" name="ReactUpdates should queue updates from during mount" time="0.053">
    </testcase>
    <testcase classname="ReactUpdates calls componentWillReceiveProps setState callback properly" name="ReactUpdates calls componentWillReceiveProps setState callback properly" time="0.095">
    </testcase>
    <testcase classname="ReactUpdates does not call render after a component as been deleted" name="ReactUpdates does not call render after a component as been deleted" time="0.036">
    </testcase>
    <testcase classname="ReactUpdates throws in setState if the update callback is not a function" name="ReactUpdates throws in setState if the update callback is not a function" time="0.115">
    </testcase>
    <testcase classname="ReactUpdates throws in forceUpdate if the update callback is not a function" name="ReactUpdates throws in forceUpdate if the update callback is not a function" time="0.089">
    </testcase>
    <testcase classname="ReactUpdates does not update one component twice in a batch (#2410)" name="ReactUpdates does not update one component twice in a batch (#2410)" time="0.044">
    </testcase>
    <testcase classname="ReactUpdates does not update one component twice in a batch (#6371)" name="ReactUpdates does not update one component twice in a batch (#6371)" time="0.059">
    </testcase>
    <testcase classname="ReactUpdates unstable_batchedUpdates should return value from a callback" name="ReactUpdates unstable_batchedUpdates should return value from a callback" time="0.049">
    </testcase>
    <testcase classname="ReactUpdates unmounts and remounts a root in the same batch" name="ReactUpdates unmounts and remounts a root in the same batch" time="0.048">
    </testcase>
    <testcase classname="ReactUpdates handles reentrant mounting in synchronous mode" name="ReactUpdates handles reentrant mounting in synchronous mode" time="0.053">
    </testcase>
    <testcase classname="ReactUpdates mounts and unmounts are sync even in a batch" name="ReactUpdates mounts and unmounts are sync even in a batch" time="0.079">
    </testcase>
    <testcase classname="ReactUpdates in legacy mode, updates in componentWillUpdate and componentDidUpdate should both flush in the immediately subsequent commit" name="ReactUpdates in legacy mode, updates in componentWillUpdate and componentDidUpdate should both flush in the immediately subsequent commit" time="0.04">
    </testcase>
    <testcase classname="ReactUpdates in legacy mode, updates in componentWillUpdate and componentDidUpdate (on a sibling) should both flush in the immediately subsequent commit" name="ReactUpdates in legacy mode, updates in componentWillUpdate and componentDidUpdate (on a sibling) should both flush in the immediately subsequent commit" time="0.048">
    </testcase>
    <testcase classname="ReactUpdates uses correct base state for setState inside render phase" name="ReactUpdates uses correct base state for setState inside render phase" time="0.063">
    </testcase>
    <testcase classname="ReactUpdates does not re-render if state update is null" name="ReactUpdates does not re-render if state update is null" time="0.044">
    </testcase>
    <testcase classname="ReactUpdates synchronously renders hidden subtrees" name="ReactUpdates synchronously renders hidden subtrees" time="0.075">
    </testcase>
    <testcase classname="ReactUpdates delays sync updates inside hidden subtrees in Concurrent Mode" name="ReactUpdates delays sync updates inside hidden subtrees in Concurrent Mode" time="0.067">
    </testcase>
    <testcase classname="ReactUpdates can render ridiculously large number of roots without triggering infinite update loop error" name="ReactUpdates can render ridiculously large number of roots without triggering infinite update loop error" time="1.873">
    </testcase>
    <testcase classname="ReactUpdates resets the update counter for unrelated updates" name="ReactUpdates resets the update counter for unrelated updates" time="0.191">
    </testcase>
    <testcase classname="ReactUpdates does not fall into an infinite update loop" name="ReactUpdates does not fall into an infinite update loop" time="0.09">
    </testcase>
    <testcase classname="ReactUpdates does not fall into an infinite update loop with useLayoutEffect" name="ReactUpdates does not fall into an infinite update loop with useLayoutEffect" time="0.1">
    </testcase>
    <testcase classname="ReactUpdates can recover after falling into an infinite update loop" name="ReactUpdates can recover after falling into an infinite update loop" time="0.143">
    </testcase>
    <testcase classname="ReactUpdates does not fall into mutually recursive infinite update loop with same container" name="ReactUpdates does not fall into mutually recursive infinite update loop with same container" time="0.097">
    </testcase>
    <testcase classname="ReactUpdates does not fall into an infinite error loop" name="ReactUpdates does not fall into an infinite error loop" time="0.305">
    </testcase>
    <testcase classname="ReactUpdates can schedule ridiculously many updates within the same batch without triggering a maximum update error" name="ReactUpdates can schedule ridiculously many updates within the same batch without triggering a maximum update error" time="0.245">
    </testcase>
    <testcase classname="ReactUpdates warns about a deferred infinite update loop with useEffect" name="ReactUpdates warns about a deferred infinite update loop with useEffect" time="0.099">
    </testcase>
    <testcase classname="ReactUpdates can have nested updates if they do not cross the limit" name="ReactUpdates can have nested updates if they do not cross the limit" time="0.08">
    </testcase>
    <testcase classname="ReactUpdates can have many updates inside useEffect without triggering a warning" name="ReactUpdates can have many updates inside useEffect without triggering a warning" time="0.095">
    </testcase>
    <testcase classname="ReactUpdates prevents infinite update loop triggered by synchronous updates in useEffect" name="ReactUpdates prevents infinite update loop triggered by synchronous updates in useEffect" time="0.073">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactMockedComponent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:06" time="0.406" tests="3">
    <testcase classname="ReactMockedComponent should allow a mocked component to be rendered" name="ReactMockedComponent should allow a mocked component to be rendered" time="0.08">
    </testcase>
    <testcase classname="ReactMockedComponent should allow a mocked component to be updated in dev" name="ReactMockedComponent should allow a mocked component to be updated in dev" time="0.002">
    </testcase>
    <testcase classname="ReactMockedComponent should allow a mocked component to be rendered in dev (SSR)" name="ReactMockedComponent should allow a mocked component to be rendered in dev (SSR)" time="0.013">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationInput-test.js" errors="0" failures="0" skipped="30" timestamp="2022-08-05T04:12:06" time="0.916" tests="30">
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and an onChange with server string render" name="ReactDOMServerIntegrationInput renders an input with a value and an onChange with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and an onChange with server stream render" name="ReactDOMServerIntegrationInput renders an input with a value and an onChange with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and an onChange with clean client render" name="ReactDOMServerIntegrationInput renders an input with a value and an onChange with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and an onChange with client render on top of good server markup" name="ReactDOMServerIntegrationInput renders an input with a value and an onChange with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and an onChange with client render on top of bad server markup" name="ReactDOMServerIntegrationInput renders an input with a value and an onChange with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and readOnly with server string render" name="ReactDOMServerIntegrationInput renders an input with a value and readOnly with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and readOnly with server stream render" name="ReactDOMServerIntegrationInput renders an input with a value and readOnly with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and readOnly with clean client render" name="ReactDOMServerIntegrationInput renders an input with a value and readOnly with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationInput renders an input with a value and readOnly with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationInput renders an input with a value and readOnly with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with server string render" name="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with server stream render" name="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with clean client render" name="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationInput renders an input with a value and no onChange/readOnly with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a defaultValue with server string render" name="ReactDOMServerIntegrationInput renders an input with a defaultValue with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a defaultValue with server stream render" name="ReactDOMServerIntegrationInput renders an input with a defaultValue with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a defaultValue with clean client render" name="ReactDOMServerIntegrationInput renders an input with a defaultValue with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a defaultValue with client render on top of good server markup" name="ReactDOMServerIntegrationInput renders an input with a defaultValue with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input with a defaultValue with client render on top of bad server markup" name="ReactDOMServerIntegrationInput renders an input with a defaultValue with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with server string render" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with server stream render" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with clean client render" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with client render on top of good server markup" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with client render on top of bad server markup" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with server string render" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with server stream render" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with clean client render" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with client render on top of good server markup" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with client render on top of bad server markup" name="ReactDOMServerIntegrationInput renders an input value overriding defaultValue no matter the prop order with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMEventPropagation-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:50" time="18.496" tests="81">
    <testcase classname="ReactDOMEventListener bubbling events onAnimationEnd" name="ReactDOMEventListener bubbling events onAnimationEnd" time="0.301">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onAnimationIteration" name="ReactDOMEventListener bubbling events onAnimationIteration" time="0.221">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onAnimationStart" name="ReactDOMEventListener bubbling events onAnimationStart" time="0.293">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onAuxClick" name="ReactDOMEventListener bubbling events onAuxClick" time="0.269">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onBlur" name="ReactDOMEventListener bubbling events onBlur" time="0.226">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events [GATED, SHOULD FAIL] onClick" name="ReactDOMEventListener bubbling events [GATED, SHOULD FAIL] onClick" time="0.184">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onContextMenu" name="ReactDOMEventListener bubbling events onContextMenu" time="0.243">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onCopy" name="ReactDOMEventListener bubbling events onCopy" time="0.237">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onCut" name="ReactDOMEventListener bubbling events onCut" time="0.206">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDoubleClick" name="ReactDOMEventListener bubbling events onDoubleClick" time="0.241">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDrag" name="ReactDOMEventListener bubbling events onDrag" time="0.229">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDragEnd" name="ReactDOMEventListener bubbling events onDragEnd" time="0.234">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDragEnter" name="ReactDOMEventListener bubbling events onDragEnter" time="0.238">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDragExit" name="ReactDOMEventListener bubbling events onDragExit" time="0.259">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDragLeave" name="ReactDOMEventListener bubbling events onDragLeave" time="0.246">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDragOver" name="ReactDOMEventListener bubbling events onDragOver" time="0.231">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDragStart" name="ReactDOMEventListener bubbling events onDragStart" time="0.218">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onDrop" name="ReactDOMEventListener bubbling events onDrop" time="0.226">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onFocus" name="ReactDOMEventListener bubbling events onFocus" time="0.19">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onGotPointerCapture" name="ReactDOMEventListener bubbling events onGotPointerCapture" time="0.239">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onKeyDown" name="ReactDOMEventListener bubbling events onKeyDown" time="0.196">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onKeyPress" name="ReactDOMEventListener bubbling events onKeyPress" time="0.215">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onKeyUp" name="ReactDOMEventListener bubbling events onKeyUp" time="0.165">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onLostPointerCapture" name="ReactDOMEventListener bubbling events onLostPointerCapture" time="0.24">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onMouseDown" name="ReactDOMEventListener bubbling events onMouseDown" time="0.197">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onMouseOut" name="ReactDOMEventListener bubbling events onMouseOut" time="0.21">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onMouseOver" name="ReactDOMEventListener bubbling events onMouseOver" time="0.188">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onMouseUp" name="ReactDOMEventListener bubbling events onMouseUp" time="0.384">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onPaste" name="ReactDOMEventListener bubbling events onPaste" time="0.188">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onPointerCancel" name="ReactDOMEventListener bubbling events onPointerCancel" time="0.248">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onPointerDown" name="ReactDOMEventListener bubbling events onPointerDown" time="0.194">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onPointerMove" name="ReactDOMEventListener bubbling events onPointerMove" time="0.185">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onPointerOut" name="ReactDOMEventListener bubbling events onPointerOut" time="0.223">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onPointerOver" name="ReactDOMEventListener bubbling events onPointerOver" time="0.184">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onPointerUp" name="ReactDOMEventListener bubbling events onPointerUp" time="0.213">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onReset" name="ReactDOMEventListener bubbling events onReset" time="0.228">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onSubmit" name="ReactDOMEventListener bubbling events onSubmit" time="0.226">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onTouchCancel" name="ReactDOMEventListener bubbling events onTouchCancel" time="0.181">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onTouchEnd" name="ReactDOMEventListener bubbling events onTouchEnd" time="0.237">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onTouchMove" name="ReactDOMEventListener bubbling events onTouchMove" time="0.183">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onTouchStart" name="ReactDOMEventListener bubbling events onTouchStart" time="0.212">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onTransitionEnd" name="ReactDOMEventListener bubbling events onTransitionEnd" time="0.222">
    </testcase>
    <testcase classname="ReactDOMEventListener bubbling events onWheel" name="ReactDOMEventListener bubbling events onWheel" time="0.158">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onAbort" name="ReactDOMEventListener non-bubbling events that bubble in React onAbort" time="0.185">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onCancel" name="ReactDOMEventListener non-bubbling events that bubble in React onCancel" time="0.16">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onCanPlay" name="ReactDOMEventListener non-bubbling events that bubble in React onCanPlay" time="0.208">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onCanPlayThrough" name="ReactDOMEventListener non-bubbling events that bubble in React onCanPlayThrough" time="0.16">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onClose" name="ReactDOMEventListener non-bubbling events that bubble in React onClose" time="0.167">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onDurationChange" name="ReactDOMEventListener non-bubbling events that bubble in React onDurationChange" time="0.176">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onEmptied" name="ReactDOMEventListener non-bubbling events that bubble in React onEmptied" time="0.201">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onEncrypted" name="ReactDOMEventListener non-bubbling events that bubble in React onEncrypted" time="0.175">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onEnded" name="ReactDOMEventListener non-bubbling events that bubble in React onEnded" time="0.196">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onError" name="ReactDOMEventListener non-bubbling events that bubble in React onError" time="0.192">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onInvalid" name="ReactDOMEventListener non-bubbling events that bubble in React onInvalid" time="0.209">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onLoad" name="ReactDOMEventListener non-bubbling events that bubble in React onLoad" time="0.199">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onLoadedData" name="ReactDOMEventListener non-bubbling events that bubble in React onLoadedData" time="0.263">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onLoadedMetadata" name="ReactDOMEventListener non-bubbling events that bubble in React onLoadedMetadata" time="0.22">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onLoadStart" name="ReactDOMEventListener non-bubbling events that bubble in React onLoadStart" time="0.2">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onPause" name="ReactDOMEventListener non-bubbling events that bubble in React onPause" time="0.194">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onPlay" name="ReactDOMEventListener non-bubbling events that bubble in React onPlay" time="0.214">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onPlaying" name="ReactDOMEventListener non-bubbling events that bubble in React onPlaying" time="0.193">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onProgress" name="ReactDOMEventListener non-bubbling events that bubble in React onProgress" time="0.208">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onRateChange" name="ReactDOMEventListener non-bubbling events that bubble in React onRateChange" time="0.166">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onResize" name="ReactDOMEventListener non-bubbling events that bubble in React onResize" time="0.19">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onSeeked" name="ReactDOMEventListener non-bubbling events that bubble in React onSeeked" time="0.348">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onSeeking" name="ReactDOMEventListener non-bubbling events that bubble in React onSeeking" time="0.592">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onStalled" name="ReactDOMEventListener non-bubbling events that bubble in React onStalled" time="0.352">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onSuspend" name="ReactDOMEventListener non-bubbling events that bubble in React onSuspend" time="0.213">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onTimeUpdate" name="ReactDOMEventListener non-bubbling events that bubble in React onTimeUpdate" time="0.18">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onToggle" name="ReactDOMEventListener non-bubbling events that bubble in React onToggle" time="0.167">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onVolumeChange" name="ReactDOMEventListener non-bubbling events that bubble in React onVolumeChange" time="0.235">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that bubble in React onWaiting" name="ReactDOMEventListener non-bubbling events that bubble in React onWaiting" time="0.208">
    </testcase>
    <testcase classname="ReactDOMEventListener non-bubbling events that do not bubble in React onScroll" name="ReactDOMEventListener non-bubbling events that do not bubble in React onScroll" time="0.135">
    </testcase>
    <testcase classname="ReactDOMEventListener enter/leave events onMouseEnter and onMouseLeave" name="ReactDOMEventListener enter/leave events onMouseEnter and onMouseLeave" time="0.115">
    </testcase>
    <testcase classname="ReactDOMEventListener enter/leave events onPointerEnter and onPointerLeave" name="ReactDOMEventListener enter/leave events onPointerEnter and onPointerLeave" time="0.108">
    </testcase>
    <testcase classname="ReactDOMEventListener polyfilled events onBeforeInput" name="ReactDOMEventListener polyfilled events onBeforeInput" time="0.089">
    </testcase>
    <testcase classname="ReactDOMEventListener polyfilled events onChange" name="ReactDOMEventListener polyfilled events onChange" time="0.128">
    </testcase>
    <testcase classname="ReactDOMEventListener polyfilled events onCompositionStart" name="ReactDOMEventListener polyfilled events onCompositionStart" time="0.116">
    </testcase>
    <testcase classname="ReactDOMEventListener polyfilled events onCompositionEnd" name="ReactDOMEventListener polyfilled events onCompositionEnd" time="0.139">
    </testcase>
    <testcase classname="ReactDOMEventListener polyfilled events onCompositionUpdate" name="ReactDOMEventListener polyfilled events onCompositionUpdate" time="0.134">
    </testcase>
    <testcase classname="ReactDOMEventListener polyfilled events onSelect" name="ReactDOMEventListener polyfilled events onSelect" time="0.133">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMserverIntegrationProgress-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:09" time="0.885" tests="5">
    <testcase classname="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with server string render" name="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with server string render" time="0.157">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with server stream render" name="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with server stream render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with clean client render" name="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with clean client render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with client render on top of good server markup" name="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with client render on top of good server markup" time="0.204">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with client render on top of bad server markup" name="ReactDOMServerIntegrationProgress renders a progress in an indeterminate state with client render on top of bad server markup" time="0.046">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerPartialHydration-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:02" time="8.311" tests="51">
    <testcase classname="ReactDOMServerPartialHydration hydrates a parent even if a child Suspense boundary is blocked" name="ReactDOMServerPartialHydration hydrates a parent even if a child Suspense boundary is blocked" time="0.347">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration can hydrate siblings of a suspended component without errors" name="ReactDOMServerPartialHydration can hydrate siblings of a suspended component without errors" time="0.145">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration falls back to client rendering boundary on mismatch" name="ReactDOMServerPartialHydration falls back to client rendering boundary on mismatch" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration calls the hydration callbacks after hydration or deletion" name="ReactDOMServerPartialHydration calls the hydration callbacks after hydration or deletion" time="0.113">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration hydrates an empty suspense boundary" name="ReactDOMServerPartialHydration hydrates an empty suspense boundary" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration recovers with client render when server rendered additional nodes at suspense root" name="ReactDOMServerPartialHydration recovers with client render when server rendered additional nodes at suspense root" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration recovers with client render when server rendered additional nodes at suspense root after unsuspending" name="ReactDOMServerPartialHydration recovers with client render when server rendered additional nodes at suspense root after unsuspending" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration recovers with client render when server rendered additional nodes deep inside suspense root" name="ReactDOMServerPartialHydration recovers with client render when server rendered additional nodes deep inside suspense root" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration calls the onDeleted hydration callback if the parent gets deleted" name="ReactDOMServerPartialHydration calls the onDeleted hydration callback if the parent gets deleted" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration warns and replaces the boundary content in legacy mode" name="ReactDOMServerPartialHydration warns and replaces the boundary content in legacy mode" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration can insert siblings before the dehydrated boundary" name="ReactDOMServerPartialHydration can insert siblings before the dehydrated boundary" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration can delete the dehydrated boundary before it is hydrated" name="ReactDOMServerPartialHydration can delete the dehydrated boundary before it is hydrated" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration blocks updates to hydrate the content first if props have changed" name="ReactDOMServerPartialHydration blocks updates to hydrate the content first if props have changed" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration blocks updates to hydrate the content first if props changed at idle priority" name="ReactDOMServerPartialHydration blocks updates to hydrate the content first if props changed at idle priority" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration shows the fallback if props have changed before hydration completes and is still suspended" name="ReactDOMServerPartialHydration shows the fallback if props have changed before hydration completes and is still suspended" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration treats missing fallback the same as if it was defined" name="ReactDOMServerPartialHydration treats missing fallback the same as if it was defined" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration clears nested suspense boundaries if they did not hydrate yet" name="ReactDOMServerPartialHydration clears nested suspense boundaries if they did not hydrate yet" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration hydrates first if props changed but we are able to resolve within a timeout" name="ReactDOMServerPartialHydration hydrates first if props changed but we are able to resolve within a timeout" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration warns but works if setState is called before commit in a dehydrated component" name="ReactDOMServerPartialHydration warns but works if setState is called before commit in a dehydrated component" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration blocks the update to hydrate first if context has changed" name="ReactDOMServerPartialHydration blocks the update to hydrate first if context has changed" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration shows the fallback if context has changed before hydration completes and is still suspended" name="ReactDOMServerPartialHydration shows the fallback if context has changed before hydration completes and is still suspended" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration replaces the fallback with client content if it is not rendered by the server" name="ReactDOMServerPartialHydration replaces the fallback with client content if it is not rendered by the server" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration replaces the fallback within the suspended time if there is a nested suspense" name="ReactDOMServerPartialHydration replaces the fallback within the suspended time if there is a nested suspense" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration replaces the fallback within the suspended time if there is a nested suspense in a nested suspense" name="ReactDOMServerPartialHydration replaces the fallback within the suspended time if there is a nested suspense in a nested suspense" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration shows inserted items in a SuspenseList before content is hydrated" name="ReactDOMServerPartialHydration shows inserted items in a SuspenseList before content is hydrated" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration shows is able to hydrate boundaries even if others in a list are pending" name="ReactDOMServerPartialHydration shows is able to hydrate boundaries even if others in a list are pending" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration clears server boundaries when SuspenseList runs out of time hydrating" name="ReactDOMServerPartialHydration clears server boundaries when SuspenseList runs out of time hydrating" time="0.087">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration clears server boundaries when SuspenseList suspends last row hydrating" name="ReactDOMServerPartialHydration clears server boundaries when SuspenseList suspends last row hydrating" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration can client render nested boundaries" name="ReactDOMServerPartialHydration can client render nested boundaries" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration can hydrate TWO suspense boundaries" name="ReactDOMServerPartialHydration can hydrate TWO suspense boundaries" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration regenerates if it cannot hydrate before changes to props/context expire" name="ReactDOMServerPartialHydration regenerates if it cannot hydrate before changes to props/context expire" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration does not invoke an event on a hydrated node until it commits" name="ReactDOMServerPartialHydration does not invoke an event on a hydrated node until it commits" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration does not invoke an event on a hydrated event handle until it commits" name="ReactDOMServerPartialHydration does not invoke an event on a hydrated event handle until it commits" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration invokes discrete events on nested suspense boundaries in a root (legacy system)" name="ReactDOMServerPartialHydration invokes discrete events on nested suspense boundaries in a root (legacy system)" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration invokes discrete events on nested suspense boundaries in a root (createEventHandle)" name="ReactDOMServerPartialHydration invokes discrete events on nested suspense boundaries in a root (createEventHandle)" time="0.199">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration does not invoke the parent of dehydrated boundary event" name="ReactDOMServerPartialHydration does not invoke the parent of dehydrated boundary event" time="0.577">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration does not invoke an event on a parent tree when a subtree is dehydrated" name="ReactDOMServerPartialHydration does not invoke an event on a parent tree when a subtree is dehydrated" time="0.299">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration blocks only on the last continuous event (legacy system)" name="ReactDOMServerPartialHydration blocks only on the last continuous event (legacy system)" time="0.083">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration finishes normal pri work before continuing to hydrate a retry" name="ReactDOMServerPartialHydration finishes normal pri work before continuing to hydrate a retry" time="0.095">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration regression test: does not overfire non-bubbling browser events" name="ReactDOMServerPartialHydration regression test: does not overfire non-bubbling browser events" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration [GATED, SHOULD FAIL] hydrates a hidden subtree outside of a Suspense boundary" name="ReactDOMServerPartialHydration [GATED, SHOULD FAIL] hydrates a hidden subtree outside of a Suspense boundary" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration renders a hidden LegacyHidden component inside a Suspense boundary" name="ReactDOMServerPartialHydration renders a hidden LegacyHidden component inside a Suspense boundary" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration renders a visible LegacyHidden component" name="ReactDOMServerPartialHydration renders a visible LegacyHidden component" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration hydrates without mismatch an empty string with neighbors" name="ReactDOMServerPartialHydration hydrates without mismatch an empty string with neighbors" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration hydrates without mismatch an empty string" name="ReactDOMServerPartialHydration hydrates without mismatch an empty string" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration hydrates without mismatch an empty string simple in fragment" name="ReactDOMServerPartialHydration hydrates without mismatch an empty string simple in fragment" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration hydrates without mismatch an empty string simple in suspense" name="ReactDOMServerPartialHydration hydrates without mismatch an empty string simple in suspense" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration hydrates without mismatch an empty string in class component" name="ReactDOMServerPartialHydration hydrates without mismatch an empty string in class component" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration fallback to client render on hydration mismatch at root" name="ReactDOMServerPartialHydration fallback to client render on hydration mismatch at root" time="0.133">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration falls back to client rendering when there&apos;s a text mismatch (direct text child)" name="ReactDOMServerPartialHydration falls back to client rendering when there&apos;s a text mismatch (direct text child)" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerPartialHydration falls back to client rendering when there&apos;s a text mismatch (text child with siblings)" name="ReactDOMServerPartialHydration falls back to client rendering when there&apos;s a text mismatch (text child with siblings)" time="0.093">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationModes-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:07" time="3.723" tests="30">
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with server string render" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with server string render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with server stream render" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with server stream render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with clean client render" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with clean client render" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with client render on top of good server markup" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with client render on top of good server markup" time="0.249">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with client render on top of bad server markup" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders with one child with client render on top of bad server markup" time="0.194">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with server string render" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with server string render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with server stream render" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with server stream render" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with clean client render" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with client render on top of good server markup" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with client render on top of good server markup" time="0.16">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with client render on top of bad server markup" name="ReactDOMServerIntegration React.unstable_DebugTracingMode renders mode with several children with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with server string render" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with server string render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with server stream render" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with server stream render" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with clean client render" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with clean client render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with client render on top of good server markup" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with client render on top of good server markup" time="0.181">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with client render on top of bad server markup" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with one child with client render on top of bad server markup" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with server string render" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with server string render" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with server stream render" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with server stream render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with clean client render" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with clean client render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with client render on top of good server markup" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with client render on top of good server markup" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with client render on top of bad server markup" name="ReactDOMServerIntegration React.StrictMode renders a strict mode with several children with client render on top of bad server markup" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with server string render" name="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with server string render" time="0.029">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with server stream render" name="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with server stream render" time="0.099">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with clean client render" name="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with clean client render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with client render on top of good server markup" name="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with client render on top of good server markup" time="0.167">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with client render on top of bad server markup" name="ReactDOMServerIntegration React.StrictMode renders a nested strict mode with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with server string render" name="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with server string render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with server stream render" name="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with server stream render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with clean client render" name="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with clean client render" time="0.152">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with client render on top of good server markup" name="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with client render on top of good server markup" time="0.305">
    </testcase>
    <testcase classname="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with client render on top of bad server markup" name="ReactDOMServerIntegration React.StrictMode renders an empty strict mode with client render on top of bad server markup" time="0.183">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactMultiChildText-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:57" time="14.784" tests="3">
    <testcase classname="ReactMultiChildText should correctly handle all possible children for render and update" name="ReactMultiChildText should correctly handle all possible children for render and update" time="14.219">
    </testcase>
    <testcase classname="ReactMultiChildText should throw if rendering both HTML and children" name="ReactMultiChildText should throw if rendering both HTML and children" time="0.004">
    </testcase>
    <testcase classname="ReactMultiChildText should render between nested components and inline children" name="ReactMultiChildText should render between nested components and inline children" time="0.014">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactErrorLoggingRecovery-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:08" time="3.689" tests="1">
    <testcase classname="ReactErrorLoggingRecovery should recover from errors in console.error" name="ReactErrorLoggingRecovery should recover from errors in console.error" time="0.022">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactMultiChild-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:11" time="1.392" tests="12">
    <testcase classname="ReactMultiChild reconciliation should update children when possible" name="ReactMultiChild reconciliation should update children when possible" time="0.09">
    </testcase>
    <testcase classname="ReactMultiChild reconciliation should replace children with different constructors" name="ReactMultiChild reconciliation should replace children with different constructors" time="0.07">
    </testcase>
    <testcase classname="ReactMultiChild reconciliation should NOT replace children with different owners" name="ReactMultiChild reconciliation should NOT replace children with different owners" time="0.039">
    </testcase>
    <testcase classname="ReactMultiChild reconciliation should replace children with different keys" name="ReactMultiChild reconciliation should replace children with different keys" time="0.066">
    </testcase>
    <testcase classname="ReactMultiChild reconciliation should warn for duplicated array keys with component stack info" name="ReactMultiChild reconciliation should warn for duplicated array keys with component stack info" time="0.069">
    </testcase>
    <testcase classname="ReactMultiChild reconciliation should warn for duplicated iterable keys with component stack info" name="ReactMultiChild reconciliation should warn for duplicated iterable keys with component stack info" time="0.065">
    </testcase>
    <testcase classname="ReactMultiChild should warn for using maps as children with owner info" name="ReactMultiChild should warn for using maps as children with owner info" time="0.076">
    </testcase>
    <testcase classname="ReactMultiChild should warn for using generators as children" name="ReactMultiChild should warn for using generators as children" time="0.06">
    </testcase>
    <testcase classname="ReactMultiChild should not warn for using generators in legacy iterables" name="ReactMultiChild should not warn for using generators in legacy iterables" time="0.063">
    </testcase>
    <testcase classname="ReactMultiChild should not warn for using generators in modern iterables" name="ReactMultiChild should not warn for using generators in modern iterables" time="0.065">
    </testcase>
    <testcase classname="ReactMultiChild should reorder bailed-out children" name="ReactMultiChild should reorder bailed-out children" time="0.059">
    </testcase>
    <testcase classname="ReactMultiChild prepares new children before unmounting old" name="ReactMultiChild prepares new children before unmounting old" time="0.084">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDomServerIntegrationAttributes-4-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:11:55" time="17.906" tests="185">
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with server string render" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with server stream render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with client render on top of good server markup" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with true value with client render on top of bad server markup" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with server string render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with server stream render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with clean client render" time="0.107">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with client render on top of good server markup" time="0.33">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with false value with client render on top of bad server markup" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with server string render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with server stream render" time="0.092">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with client render on top of good server markup" time="0.149">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string value with client render on top of bad server markup" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with server string render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with server stream render" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with clean client render" time="0.239">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with client render on top of good server markup" time="0.254">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;false&quot; value with client render on top of bad server markup" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with server string render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with server stream render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with client render on top of good server markup" time="0.159">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with string &quot;true&quot; value with client render on top of bad server markup" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with server string render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with server stream render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with client render on top of good server markup" time="0.099">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders download prop with number 0 value with client render on top of bad server markup" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with server string render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with server stream render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with clean client render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with client render on top of good server markup" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with null value with client render on top of bad server markup" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with server string render" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with server stream render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with clean client render" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with client render on top of good server markup" time="0.261">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with undefined value with client render on top of bad server markup" time="0.159">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with server stream render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with clean client render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with client render on top of good server markup" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with function value with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with server string render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with server stream render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with server stream render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with clean client render" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with clean client render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with client render on top of good server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with client render on top of good server markup" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with client render on top of bad server markup" name="ReactDOMServerIntegration download property (combined boolean/string attribute) renders no download prop with symbol value with client render on top of bad server markup" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with string value with server string render" name="ReactDOMServerIntegration className property renders className prop with string value with server string render" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with string value with server stream render" name="ReactDOMServerIntegration className property renders className prop with string value with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with string value with clean client render" name="ReactDOMServerIntegration className property renders className prop with string value with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with string value with client render on top of good server markup" name="ReactDOMServerIntegration className property renders className prop with string value with client render on top of good server markup" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with string value with client render on top of bad server markup" name="ReactDOMServerIntegration className property renders className prop with string value with client render on top of bad server markup" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with empty string value with server string render" name="ReactDOMServerIntegration className property renders className prop with empty string value with server string render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with empty string value with server stream render" name="ReactDOMServerIntegration className property renders className prop with empty string value with server stream render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with empty string value with clean client render" name="ReactDOMServerIntegration className property renders className prop with empty string value with clean client render" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with empty string value with client render on top of good server markup" name="ReactDOMServerIntegration className property renders className prop with empty string value with client render on top of good server markup" time="0.244">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop with empty string value with client render on top of bad server markup" name="ReactDOMServerIntegration className property renders className prop with empty string value with client render on top of bad server markup" time="0.135">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with true value with server string render" name="ReactDOMServerIntegration className property renders no className prop with true value with server string render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with true value with server stream render" name="ReactDOMServerIntegration className property renders no className prop with true value with server stream render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with true value with clean client render" name="ReactDOMServerIntegration className property renders no className prop with true value with clean client render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with true value with client render on top of good server markup" name="ReactDOMServerIntegration className property renders no className prop with true value with client render on top of good server markup" time="0.12">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with true value with client render on top of bad server markup" name="ReactDOMServerIntegration className property renders no className prop with true value with client render on top of bad server markup" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with false value with server string render" name="ReactDOMServerIntegration className property renders no className prop with false value with server string render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with false value with server stream render" name="ReactDOMServerIntegration className property renders no className prop with false value with server stream render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with false value with clean client render" name="ReactDOMServerIntegration className property renders no className prop with false value with clean client render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with false value with client render on top of good server markup" name="ReactDOMServerIntegration className property renders no className prop with false value with client render on top of good server markup" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with false value with client render on top of bad server markup" name="ReactDOMServerIntegration className property renders no className prop with false value with client render on top of bad server markup" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with null value with server string render" name="ReactDOMServerIntegration className property renders no className prop with null value with server string render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with null value with server stream render" name="ReactDOMServerIntegration className property renders no className prop with null value with server stream render" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with null value with clean client render" name="ReactDOMServerIntegration className property renders no className prop with null value with clean client render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with null value with client render on top of good server markup" name="ReactDOMServerIntegration className property renders no className prop with null value with client render on top of good server markup" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders no className prop with null value with client render on top of bad server markup" name="ReactDOMServerIntegration className property renders no className prop with null value with client render on top of bad server markup" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders badly cased className with a warning with server string render" name="ReactDOMServerIntegration className property renders badly cased className with a warning with server string render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders badly cased className with a warning with server stream render" name="ReactDOMServerIntegration className property renders badly cased className with a warning with server stream render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders badly cased className with a warning with clean client render" name="ReactDOMServerIntegration className property renders badly cased className with a warning with clean client render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders badly cased className with a warning with client render on top of good server markup" name="ReactDOMServerIntegration className property renders badly cased className with a warning with client render on top of good server markup" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders badly cased className with a warning with client render on top of bad server markup" name="ReactDOMServerIntegration className property renders badly cased className with a warning with client render on top of bad server markup" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with server string render" name="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with server string render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with server stream render" name="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with server stream render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with clean client render" name="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with clean client render" time="0.147">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with client render on top of good server markup" name="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with client render on top of good server markup" time="0.4">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with client render on top of bad server markup" name="ReactDOMServerIntegration className property renders className prop when given the alias with a warning with client render on top of bad server markup" time="0.137">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with server string render" name="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with server string render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with server stream render" name="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with server stream render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with clean client render" name="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with clean client render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with client render on top of good server markup" name="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with client render on top of good server markup" time="0.153">
    </testcase>
    <testcase classname="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with client render on top of bad server markup" name="ReactDOMServerIntegration className property renders className prop when given a badly cased alias with client render on top of bad server markup" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with server string render" name="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with server string render" time="0.1">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with server stream render" name="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with server stream render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with clean client render" name="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with client render on top of good server markup" name="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with client render on top of good server markup" time="0.132">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with client render on top of bad server markup" name="ReactDOMServerIntegration htmlFor property renders htmlFor with string value with client render on top of bad server markup" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with server string render" name="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with server string render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with server stream render" name="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with server stream render" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with clean client render" name="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with client render on top of good server markup" name="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with client render on top of good server markup" time="0.112">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with client render on top of bad server markup" name="ReactDOMServerIntegration htmlFor property renders no badly cased htmlfor with client render on top of bad server markup" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with server string render" name="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with server string render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with server stream render" name="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with server stream render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with clean client render" name="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with client render on top of good server markup" name="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with client render on top of good server markup" time="0.099">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with client render on top of bad server markup" name="ReactDOMServerIntegration htmlFor property renders htmlFor with an empty string with client render on top of bad server markup" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with server string render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with server string render" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with server stream render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with clean client render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with clean client render" time="0.094">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with client render on top of good server markup" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with client render on top of good server markup" time="0.359">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with client render on top of bad server markup" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with true value with client render on top of bad server markup" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with server string render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with server string render" time="0.106">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with server stream render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with server stream render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with clean client render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with clean client render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with client render on top of good server markup" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with client render on top of good server markup" time="0.13">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with client render on top of bad server markup" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with false value with client render on top of bad server markup" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with server string render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with server stream render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with server stream render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with clean client render" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with clean client render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with client render on top of good server markup" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with client render on top of good server markup" time="0.087">
    </testcase>
    <testcase classname="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with client render on top of bad server markup" name="ReactDOMServerIntegration htmlFor property renders no htmlFor prop with null value with client render on top of bad server markup" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with server string render" name="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with server string render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with server stream render" name="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with server stream render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with clean client render" name="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with clean client render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with client render on top of good server markup" name="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with client render on top of good server markup" time="0.118">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with client render on top of bad server markup" name="ReactDOMServerIntegration numeric properties renders positive numeric property with positive value with client render on top of bad server markup" time="0.079">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders numeric property with zero value with server string render" name="ReactDOMServerIntegration numeric properties renders numeric property with zero value with server string render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders numeric property with zero value with server stream render" name="ReactDOMServerIntegration numeric properties renders numeric property with zero value with server stream render" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders numeric property with zero value with clean client render" name="ReactDOMServerIntegration numeric properties renders numeric property with zero value with clean client render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders numeric property with zero value with client render on top of good server markup" name="ReactDOMServerIntegration numeric properties renders numeric property with zero value with client render on top of good server markup" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders numeric property with zero value with client render on top of bad server markup" name="ReactDOMServerIntegration numeric properties renders numeric property with zero value with client render on top of bad server markup" time="0.116">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with server string render" name="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with server stream render" name="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with server stream render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with clean client render" name="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with clean client render" time="0.113">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with client render on top of good server markup" name="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with client render on top of good server markup" time="0.23">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with client render on top of bad server markup" name="ReactDOMServerIntegration numeric properties renders no positive numeric property with zero value with client render on top of bad server markup" time="0.168">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with server string render" name="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with server string render" time="0.143">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with server stream render" name="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with server stream render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with clean client render" name="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with clean client render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with client render on top of good server markup" name="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with client render on top of good server markup" time="0.137">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with client render on top of bad server markup" name="ReactDOMServerIntegration numeric properties renders no numeric prop with function value with client render on top of bad server markup" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with server string render" name="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with server string render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with server stream render" name="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with server stream render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with clean client render" name="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with clean client render" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with client render on top of good server markup" name="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with client render on top of good server markup" time="0.206">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with client render on top of bad server markup" name="ReactDOMServerIntegration numeric properties renders no numeric prop with symbol value with client render on top of bad server markup" time="0.129">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with server string render" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with server string render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with server stream render" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with server stream render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with clean client render" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with client render on top of good server markup" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with client render on top of good server markup" time="0.203">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with client render on top of bad server markup" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with function value with client render on top of bad server markup" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with server string render" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with server string render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with server stream render" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with server stream render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with clean client render" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with clean client render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with client render on top of good server markup" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with client render on top of good server markup" time="0.138">
    </testcase>
    <testcase classname="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with client render on top of bad server markup" name="ReactDOMServerIntegration numeric properties renders no positive numeric prop with symbol value with client render on top of bad server markup" time="0.094">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with server string render" name="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with server stream render" name="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with server stream render" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with clean client render" name="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with clean client render" time="0.156">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with client render on top of good server markup" name="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with client render on top of good server markup" time="0.348">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with client render on top of bad server markup" name="ReactDOMServerIntegration props with special meaning in React renders no ref attribute with client render on top of bad server markup" time="0.286">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no children attribute with server string render" name="ReactDOMServerIntegration props with special meaning in React renders no children attribute with server string render" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no children attribute with server stream render" name="ReactDOMServerIntegration props with special meaning in React renders no children attribute with server stream render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no children attribute with clean client render" name="ReactDOMServerIntegration props with special meaning in React renders no children attribute with clean client render" time="0.079">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no children attribute with client render on top of good server markup" name="ReactDOMServerIntegration props with special meaning in React renders no children attribute with client render on top of good server markup" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no children attribute with client render on top of bad server markup" name="ReactDOMServerIntegration props with special meaning in React renders no children attribute with client render on top of bad server markup" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no key attribute with server string render" name="ReactDOMServerIntegration props with special meaning in React renders no key attribute with server string render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no key attribute with server stream render" name="ReactDOMServerIntegration props with special meaning in React renders no key attribute with server stream render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no key attribute with clean client render" name="ReactDOMServerIntegration props with special meaning in React renders no key attribute with clean client render" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no key attribute with client render on top of good server markup" name="ReactDOMServerIntegration props with special meaning in React renders no key attribute with client render on top of good server markup" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no key attribute with client render on top of bad server markup" name="ReactDOMServerIntegration props with special meaning in React renders no key attribute with client render on top of bad server markup" time="0.106">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with server string render" name="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with server string render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with server stream render" name="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with server stream render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with clean client render" name="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with clean client render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with client render on top of good server markup" name="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with client render on top of good server markup" time="0.11">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with client render on top of bad server markup" name="ReactDOMServerIntegration props with special meaning in React renders no dangerouslySetInnerHTML attribute with client render on top of bad server markup" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with server string render" name="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with server string render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with server stream render" name="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with clean client render" name="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with clean client render" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with client render on top of good server markup" name="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with client render on top of good server markup" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with client render on top of bad server markup" name="ReactDOMServerIntegration props with special meaning in React renders no suppressContentEditableWarning attribute with client render on top of bad server markup" time="0.079">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with server string render" name="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with server string render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with server stream render" name="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with server stream render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with clean client render" name="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with clean client render" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with client render on top of good server markup" name="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with client render on top of good server markup" time="0.282">
    </testcase>
    <testcase classname="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with client render on top of bad server markup" name="ReactDOMServerIntegration props with special meaning in React renders no suppressHydrationWarning attribute with client render on top of bad server markup" time="0.18">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactServerRenderingHydration-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:11" time="2.49" tests="22">
    <testcase classname="ReactDOMServerHydration should have the correct mounting behavior (new hydrate API)" name="ReactDOMServerHydration should have the correct mounting behavior (new hydrate API)" time="0.193">
    </testcase>
    <testcase classname="ReactDOMServerHydration should emit autofocus on the server but not focus() when hydrating" name="ReactDOMServerHydration should emit autofocus on the server but not focus() when hydrating" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerHydration should not focus on either server or client with autofocus={false}" name="ReactDOMServerHydration should not focus on either server or client with autofocus={false}" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerHydration should not focus on either server or client with autofocus={false} even if there is a markup mismatch" name="ReactDOMServerHydration should not focus on either server or client with autofocus={false} even if there is a markup mismatch" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerHydration should warn when the style property differs" name="ReactDOMServerHydration should warn when the style property differs" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerHydration should not warn when the style property differs on whitespace or order in IE" name="ReactDOMServerHydration should not warn when the style property differs on whitespace or order in IE" time="0.106">
    </testcase>
    <testcase classname="ReactDOMServerHydration should warn when the style property differs on whitespace in non-IE browsers" name="ReactDOMServerHydration should warn when the style property differs on whitespace in non-IE browsers" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerHydration should throw rendering portals on the server" name="ReactDOMServerHydration should throw rendering portals on the server" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerHydration should be able to render and hydrate Mode components" name="ReactDOMServerHydration should be able to render and hydrate Mode components" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServerHydration should be able to render and hydrate forwardRef components" name="ReactDOMServerHydration should be able to render and hydrate forwardRef components" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerHydration should be able to render and hydrate Profiler components" name="ReactDOMServerHydration should be able to render and hydrate Profiler components" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerHydration should ignore noscript content on the client and not warn about mismatches" name="ReactDOMServerHydration should ignore noscript content on the client and not warn about mismatches" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerHydration should be able to use lazy components after hydrating" name="ReactDOMServerHydration should be able to use lazy components after hydrating" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerHydration does not re-enter hydration after committing the first one" name="ReactDOMServerHydration does not re-enter hydration after committing the first one" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerHydration Suspense + hydration in legacy mode" name="ReactDOMServerHydration Suspense + hydration in legacy mode" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerHydration Suspense + hydration in legacy mode (at root)" name="ReactDOMServerHydration Suspense + hydration in legacy mode (at root)" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerHydration Suspense + hydration in legacy mode with no fallback" name="ReactDOMServerHydration Suspense + hydration in legacy mode with no fallback" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerHydration should not warn if dangerouslySetInnerHtml=undefined" name="ReactDOMServerHydration should not warn if dangerouslySetInnerHtml=undefined" time="0.169">
    </testcase>
    <testcase classname="ReactDOMServerHydration should warn if innerHTML mismatches with dangerouslySetInnerHTML=undefined and children on the client" name="ReactDOMServerHydration should warn if innerHTML mismatches with dangerouslySetInnerHTML=undefined and children on the client" time="0.132">
    </testcase>
    <testcase classname="ReactDOMServerHydration should warn if innerHTML mismatches with dangerouslySetInnerHTML=undefined on the client" name="ReactDOMServerHydration should warn if innerHTML mismatches with dangerouslySetInnerHTML=undefined on the client" time="0.111">
    </testcase>
    <testcase classname="ReactDOMServerHydration should warn when hydrating read-only properties" name="ReactDOMServerHydration should warn when hydrating read-only properties" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerHydration should not re-assign properties on hydration" name="ReactDOMServerHydration should not re-assign properties on hydration" time="0.071">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactComponent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:13" time="1.96" tests="22">
    <testcase classname="ReactComponent should throw on invalid render targets" name="ReactComponent should throw on invalid render targets" time="0.105">
    </testcase>
    <testcase classname="ReactComponent should throw when supplying a ref outside of render method" name="ReactComponent should throw when supplying a ref outside of render method" time="0.074">
    </testcase>
    <testcase classname="ReactComponent should throw (in dev) when children are mutated during render" name="ReactComponent should throw (in dev) when children are mutated during render" time="0.049">
    </testcase>
    <testcase classname="ReactComponent should throw (in dev) when children are mutated during update" name="ReactComponent should throw (in dev) when children are mutated during update" time="0.064">
    </testcase>
    <testcase classname="ReactComponent should support refs on owned components" name="ReactComponent should support refs on owned components" time="0.039">
    </testcase>
    <testcase classname="ReactComponent should not have refs on unmounted components" name="ReactComponent should not have refs on unmounted components" time="0.048">
    </testcase>
    <testcase classname="ReactComponent should support callback-style refs" name="ReactComponent should support callback-style refs" time="0.054">
    </testcase>
    <testcase classname="ReactComponent should support object-style refs" name="ReactComponent should support object-style refs" time="0.047">
    </testcase>
    <testcase classname="ReactComponent should support new-style refs with mixed-up owners" name="ReactComponent should support new-style refs with mixed-up owners" time="0.054">
    </testcase>
    <testcase classname="ReactComponent should call refs at the correct time" name="ReactComponent should call refs at the correct time" time="0.039">
    </testcase>
    <testcase classname="ReactComponent fires the callback after a component is rendered" name="ReactComponent fires the callback after a component is rendered" time="0.057">
    </testcase>
    <testcase classname="ReactComponent throws usefully when rendering badly-typed elements" name="ReactComponent throws usefully when rendering badly-typed elements" time="0.098">
    </testcase>
    <testcase classname="ReactComponent includes owner name in the error about badly-typed elements" name="ReactComponent includes owner name in the error about badly-typed elements" time="0.093">
    </testcase>
    <testcase classname="ReactComponent throws if a plain object is used as a child" name="ReactComponent throws if a plain object is used as a child" time="0.083">
    </testcase>
    <testcase classname="ReactComponent throws if a plain object even if it is in an owner" name="ReactComponent throws if a plain object even if it is in an owner" time="0.064">
    </testcase>
    <testcase classname="ReactComponent throws if a plain object is used as a child when using SSR" name="ReactComponent throws if a plain object is used as a child when using SSR" time="0.08">
    </testcase>
    <testcase classname="ReactComponent throws if a plain object even if it is in an owner when using SSR" name="ReactComponent throws if a plain object even if it is in an owner when using SSR" time="0.036">
    </testcase>
    <testcase classname="ReactComponent with new features warns on function as a return value from a function" name="ReactComponent with new features warns on function as a return value from a function" time="0.06">
    </testcase>
    <testcase classname="ReactComponent with new features warns on function as a return value from a class" name="ReactComponent with new features warns on function as a return value from a class" time="0.064">
    </testcase>
    <testcase classname="ReactComponent with new features warns on function as a child to host component" name="ReactComponent with new features warns on function as a child to host component" time="0.045">
    </testcase>
    <testcase classname="ReactComponent with new features does not warn for function-as-a-child that gets resolved" name="ReactComponent with new features does not warn for function-as-a-child that gets resolved" time="0.061">
    </testcase>
    <testcase classname="ReactComponent with new features deduplicates function type warnings based on component type" name="ReactComponent with new features deduplicates function type warnings based on component type" time="0.069">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactChildReconciler-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:14" time="0.745" tests="5">
    <testcase classname="ReactChildReconciler does not treat functions as iterables" name="ReactChildReconciler does not treat functions as iterables" time="0.099">
    </testcase>
    <testcase classname="ReactChildReconciler warns for duplicated array keys" name="ReactChildReconciler warns for duplicated array keys" time="0.059">
    </testcase>
    <testcase classname="ReactChildReconciler warns for duplicated array keys with component stack info" name="ReactChildReconciler warns for duplicated array keys with component stack info" time="0.072">
    </testcase>
    <testcase classname="ReactChildReconciler warns for duplicated iterable keys" name="ReactChildReconciler warns for duplicated iterable keys" time="0.055">
    </testcase>
    <testcase classname="ReactChildReconciler warns for duplicated iterable keys with component stack info" name="ReactChildReconciler warns for duplicated iterable keys with component stack info" time="0.052">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationSpecialTypes-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:11" time="3.963" tests="30">
    <testcase classname="ReactDOMServerIntegration renders a forwardedRef component and its children with server string render" name="ReactDOMServerIntegration renders a forwardedRef component and its children with server string render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a forwardedRef component and its children with server stream render" name="ReactDOMServerIntegration renders a forwardedRef component and its children with server stream render" time="0.11">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a forwardedRef component and its children with clean client render" name="ReactDOMServerIntegration renders a forwardedRef component and its children with clean client render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a forwardedRef component and its children with client render on top of good server markup" name="ReactDOMServerIntegration renders a forwardedRef component and its children with client render on top of good server markup" time="0.127">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a forwardedRef component and its children with client render on top of bad server markup" name="ReactDOMServerIntegration renders a forwardedRef component and its children with client render on top of bad server markup" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a Profiler component and its children with server string render" name="ReactDOMServerIntegration renders a Profiler component and its children with server string render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a Profiler component and its children with server stream render" name="ReactDOMServerIntegration renders a Profiler component and its children with server stream render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a Profiler component and its children with clean client render" name="ReactDOMServerIntegration renders a Profiler component and its children with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a Profiler component and its children with client render on top of good server markup" name="ReactDOMServerIntegration renders a Profiler component and its children with client render on top of good server markup" time="0.14">
    </testcase>
    <testcase classname="ReactDOMServerIntegration renders a Profiler component and its children with client render on top of bad server markup" name="ReactDOMServerIntegration renders a Profiler component and its children with client render on top of bad server markup" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders basic render with server string render" name="ReactDOMServerIntegration memoized function components renders basic render with server string render" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders basic render with server stream render" name="ReactDOMServerIntegration memoized function components renders basic render with server stream render" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders basic render with clean client render" name="ReactDOMServerIntegration memoized function components renders basic render with clean client render" time="0.112">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders basic render with client render on top of good server markup" name="ReactDOMServerIntegration memoized function components renders basic render with client render on top of good server markup" time="0.141">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders basic render with client render on top of bad server markup" name="ReactDOMServerIntegration memoized function components renders basic render with client render on top of bad server markup" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders composition with forwardRef with server string render" name="ReactDOMServerIntegration memoized function components renders composition with forwardRef with server string render" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders composition with forwardRef with server stream render" name="ReactDOMServerIntegration memoized function components renders composition with forwardRef with server stream render" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders composition with forwardRef with clean client render" name="ReactDOMServerIntegration memoized function components renders composition with forwardRef with clean client render" time="0.092">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders composition with forwardRef with client render on top of good server markup" name="ReactDOMServerIntegration memoized function components renders composition with forwardRef with client render on top of good server markup" time="0.168">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders composition with forwardRef with client render on top of bad server markup" name="ReactDOMServerIntegration memoized function components renders composition with forwardRef with client render on top of bad server markup" time="0.173">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders with comparator with server string render" name="ReactDOMServerIntegration memoized function components renders with comparator with server string render" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders with comparator with server stream render" name="ReactDOMServerIntegration memoized function components renders with comparator with server stream render" time="0.13">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders with comparator with clean client render" name="ReactDOMServerIntegration memoized function components renders with comparator with clean client render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders with comparator with client render on top of good server markup" name="ReactDOMServerIntegration memoized function components renders with comparator with client render on top of good server markup" time="0.234">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders with comparator with client render on top of bad server markup" name="ReactDOMServerIntegration memoized function components renders with comparator with client render on top of bad server markup" time="0.13">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with server string render" name="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with server string render" time="0.119">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with server stream render" name="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with server stream render" time="0.11">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with clean client render" name="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with clean client render" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with client render on top of good server markup" name="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with client render on top of good server markup" time="0.191">
    </testcase>
    <testcase classname="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with client render on top of bad server markup" name="ReactDOMServerIntegration memoized function components renders comparator functions are not invoked on the server with client render on top of bad server markup" time="0.106">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMFizzServerNode-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:14" time="1.723" tests="15">
    <testcase classname="ReactDOMFizzServer should call renderToPipeableStream" name="ReactDOMFizzServer should call renderToPipeableStream" time="0.033">
    </testcase>
    <testcase classname="ReactDOMFizzServer should emit DOCTYPE at the root of the document" name="ReactDOMFizzServer should emit DOCTYPE at the root of the document" time="0.03">
    </testcase>
    <testcase classname="ReactDOMFizzServer should emit bootstrap script src at the end" name="ReactDOMFizzServer should emit bootstrap script src at the end" time="0.025">
    </testcase>
    <testcase classname="ReactDOMFizzServer should start writing after pipe" name="ReactDOMFizzServer should start writing after pipe" time="0.008">
    </testcase>
    <testcase classname="ReactDOMFizzServer emits all HTML as one unit if we wait until the end to start" name="ReactDOMFizzServer emits all HTML as one unit if we wait until the end to start" time="0.026">
    </testcase>
    <testcase classname="ReactDOMFizzServer should error the stream when an error is thrown at the root" name="ReactDOMFizzServer should error the stream when an error is thrown at the root" time="0.038">
    </testcase>
    <testcase classname="ReactDOMFizzServer should error the stream when an error is thrown inside a fallback" name="ReactDOMFizzServer should error the stream when an error is thrown inside a fallback" time="0.02">
    </testcase>
    <testcase classname="ReactDOMFizzServer should not error the stream when an error is thrown inside suspense boundary" name="ReactDOMFizzServer should not error the stream when an error is thrown inside suspense boundary" time="0.016">
    </testcase>
    <testcase classname="ReactDOMFizzServer should not attempt to render the fallback if the main content completes first" name="ReactDOMFizzServer should not attempt to render the fallback if the main content completes first" time="0.009">
    </testcase>
    <testcase classname="ReactDOMFizzServer should be able to complete by aborting even if the promise never resolves" name="ReactDOMFizzServer should be able to complete by aborting even if the promise never resolves" time="0.008">
    </testcase>
    <testcase classname="ReactDOMFizzServer should be able to complete by abort when the fallback is also suspended" name="ReactDOMFizzServer should be able to complete by abort when the fallback is also suspended" time="0.043">
    </testcase>
    <testcase classname="ReactDOMFizzServer should be able to get context value when promise resolves" name="ReactDOMFizzServer should be able to get context value when promise resolves" time="0.022">
    </testcase>
    <testcase classname="ReactDOMFizzServer should be able to get context value when calls renderToPipeableStream twice at the same time" name="ReactDOMFizzServer should be able to get context value when calls renderToPipeableStream twice at the same time" time="0.036">
    </testcase>
    <testcase classname="ReactDOMFizzServer should be able to pop context after suspending" name="ReactDOMFizzServer should be able to pop context after suspending" time="0.011">
    </testcase>
    <testcase classname="ReactDOMFizzServer should not continue rendering after the writable ends unexpectedly" name="ReactDOMFizzServer should not continue rendering after the writable ends unexpectedly" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/multiple-copies-of-react-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:15" time="0.777" tests="1">
    <testcase classname="when different React version is used with string ref throws the &quot;Refs must have owner&quot; warning" name="when different React version is used with string ref throws the &quot;Refs must have owner&quot; warning" time="0.062">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMNestedEvents-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:16" time="0.551" tests="1">
    <testcase classname="ReactDOMNestedEvents nested event dispatches should not cause updates to flush" name="ReactDOMNestedEvents nested event dispatches should not cause updates to flush" time="0.131">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactBrowserEventEmitter-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:16" time="1.144" tests="11">
    <testcase classname="ReactBrowserEventEmitter should bubble simply" name="ReactBrowserEventEmitter should bubble simply" time="0.116">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should bubble to the right handler after an update" name="ReactBrowserEventEmitter should bubble to the right handler after an update" time="0.049">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should continue bubbling if an error is thrown" name="ReactBrowserEventEmitter should continue bubbling if an error is thrown" time="0.125">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should set currentTarget" name="ReactBrowserEventEmitter should set currentTarget" time="0.042">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should support stopPropagation()" name="ReactBrowserEventEmitter should support stopPropagation()" time="0.061">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should support overriding .isPropagationStopped()" name="ReactBrowserEventEmitter should support overriding .isPropagationStopped()" time="0.077">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should stop after first dispatch if stopPropagation" name="ReactBrowserEventEmitter should stop after first dispatch if stopPropagation" time="0.062">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should not stopPropagation if false is returned" name="ReactBrowserEventEmitter should not stopPropagation if false is returned" time="0.053">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should invoke handlers that were removed while bubbling" name="ReactBrowserEventEmitter should invoke handlers that were removed while bubbling" time="0.051">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should not invoke newly inserted handlers while bubbling" name="ReactBrowserEventEmitter should not invoke newly inserted handlers while bubbling" time="0.072">
    </testcase>
    <testcase classname="ReactBrowserEventEmitter should have mouse enter simulated by test utils" name="ReactBrowserEventEmitter should have mouse enter simulated by test utils" time="0.038">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMNativeEventHeuristic-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:16" time="1.249" tests="8">
    <testcase classname="ReactDOMNativeEventHeuristic-test ignores discrete events on a pending removed element" name="ReactDOMNativeEventHeuristic-test ignores discrete events on a pending removed element" time="0.172">
    </testcase>
    <testcase classname="ReactDOMNativeEventHeuristic-test ignores discrete events on a pending removed event listener" name="ReactDOMNativeEventHeuristic-test ignores discrete events on a pending removed event listener" time="0.073">
    </testcase>
    <testcase classname="ReactDOMNativeEventHeuristic-test uses the newest discrete events on a pending changed event listener" name="ReactDOMNativeEventHeuristic-test uses the newest discrete events on a pending changed event listener" time="0.123">
    </testcase>
    <testcase classname="ReactDOMNativeEventHeuristic-test mouse over should be user-blocking but not discrete" name="ReactDOMNativeEventHeuristic-test mouse over should be user-blocking but not discrete" time="0.154">
    </testcase>
    <testcase classname="ReactDOMNativeEventHeuristic-test mouse enter should be user-blocking but not discrete" name="ReactDOMNativeEventHeuristic-test mouse enter should be user-blocking but not discrete" time="0.149">
    </testcase>
    <testcase classname="ReactDOMNativeEventHeuristic-test continuous native events flush as expected" name="ReactDOMNativeEventHeuristic-test continuous native events flush as expected" time="0.057">
    </testcase>
    <testcase classname="ReactDOMNativeEventHeuristic-test should batch inside native events" name="ReactDOMNativeEventHeuristic-test should batch inside native events" time="0.091">
    </testcase>
    <testcase classname="ReactDOMNativeEventHeuristic-test should not flush discrete events at the end of outermost batchedUpdates" name="ReactDOMNativeEventHeuristic-test should not flush discrete events at the end of outermost batchedUpdates" time="0.067">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactTestUtilsAct-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:12" time="4.808" tests="52">
    <testcase classname="ReactTestUtils.act() concurrent mode sync can use act to flush effects" name="ReactTestUtils.act() concurrent mode sync can use act to flush effects" time="0.086">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync flushes effects on every call" name="ReactTestUtils.act() concurrent mode sync flushes effects on every call" time="0.127">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync should keep flushing effects until they&apos;re done" name="ReactTestUtils.act() concurrent mode sync should keep flushing effects until they&apos;re done" time="0.023">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync should flush effects only on exiting the outermost act" name="ReactTestUtils.act() concurrent mode sync should flush effects only on exiting the outermost act" time="0.058">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync warns if a setState is called outside of act(...)" name="ReactTestUtils.act() concurrent mode sync warns if a setState is called outside of act(...)" time="0.07">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync warns if a setState is called outside of act(...) after a component threw" name="ReactTestUtils.act() concurrent mode sync warns if a setState is called outside of act(...) after a component threw" time="0.091">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync does not warn if IS_REACT_ACT_ENVIRONMENT is set to false" name="ReactTestUtils.act() concurrent mode sync does not warn if IS_REACT_ACT_ENVIRONMENT is set to false" time="0.047">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync fake timers lets a ticker update" name="ReactTestUtils.act() concurrent mode sync fake timers lets a ticker update" time="0.068">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync fake timers can use the async version to catch microtasks" name="ReactTestUtils.act() concurrent mode sync fake timers can use the async version to catch microtasks" time="0.071">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync fake timers can handle cascading promises with fake timers" name="ReactTestUtils.act() concurrent mode sync fake timers can handle cascading promises with fake timers" time="0.088">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode sync fake timers flushes immediate re-renders with act" name="ReactTestUtils.act() concurrent mode sync fake timers flushes immediate re-renders with act" time="0.044">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode asynchronous tests works with timeouts" name="ReactTestUtils.act() concurrent mode asynchronous tests works with timeouts" time="0.163">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode asynchronous tests flushes microtasks before exiting (async function)" name="ReactTestUtils.act() concurrent mode asynchronous tests flushes microtasks before exiting (async function)" time="0.038">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode asynchronous tests flushes microtasks before exiting (sync function)" name="ReactTestUtils.act() concurrent mode asynchronous tests flushes microtasks before exiting (sync function)" time="0.026">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode asynchronous tests warns if you do not await an act call" name="ReactTestUtils.act() concurrent mode asynchronous tests warns if you do not await an act call" time="0.054">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode asynchronous tests warns if you try to interleave multiple act calls" name="ReactTestUtils.act() concurrent mode asynchronous tests warns if you try to interleave multiple act calls" time="0.283">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode asynchronous tests async commits and effects are guaranteed to be flushed" name="ReactTestUtils.act() concurrent mode asynchronous tests async commits and effects are guaranteed to be flushed" time="0.026">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode asynchronous tests can handle cascading promises" name="ReactTestUtils.act() concurrent mode asynchronous tests can handle cascading promises" time="0.032">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode error propagation propagates errors - sync" name="ReactTestUtils.act() concurrent mode error propagation propagates errors - sync" time="0.024">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode error propagation should propagate errors from effects - sync" name="ReactTestUtils.act() concurrent mode error propagation should propagate errors from effects - sync" time="0.044">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode error propagation propagates errors - async" name="ReactTestUtils.act() concurrent mode error propagation propagates errors - async" time="0.172">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode error propagation should cleanup after errors - sync" name="ReactTestUtils.act() concurrent mode error propagation should cleanup after errors - sync" time="0.022">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode error propagation should cleanup after errors - async" name="ReactTestUtils.act() concurrent mode error propagation should cleanup after errors - async" time="0.131">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode suspense triggers fallbacks if available" name="ReactTestUtils.act() concurrent mode suspense triggers fallbacks if available" time="0.02">
    </testcase>
    <testcase classname="ReactTestUtils.act() concurrent mode throw in prod mode [GATED, SHOULD FAIL] warns if you try to use act() in prod mode" name="ReactTestUtils.act() concurrent mode throw in prod mode [GATED, SHOULD FAIL] warns if you try to use act() in prod mode" time="0.026">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync can use act to flush effects" name="ReactTestUtils.act() legacy mode sync can use act to flush effects" time="0.024">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync flushes effects on every call" name="ReactTestUtils.act() legacy mode sync flushes effects on every call" time="0.064">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync should keep flushing effects until they&apos;re done" name="ReactTestUtils.act() legacy mode sync should keep flushing effects until they&apos;re done" time="0.059">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync should flush effects only on exiting the outermost act" name="ReactTestUtils.act() legacy mode sync should flush effects only on exiting the outermost act" time="0.059">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync warns if a setState is called outside of act(...)" name="ReactTestUtils.act() legacy mode sync warns if a setState is called outside of act(...)" time="0.072">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync warns if a setState is called outside of act(...) after a component threw" name="ReactTestUtils.act() legacy mode sync warns if a setState is called outside of act(...) after a component threw" time="0.061">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync does not warn if IS_REACT_ACT_ENVIRONMENT is set to false" name="ReactTestUtils.act() legacy mode sync does not warn if IS_REACT_ACT_ENVIRONMENT is set to false" time="0.03">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync fake timers lets a ticker update" name="ReactTestUtils.act() legacy mode sync fake timers lets a ticker update" time="0.113">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync fake timers can use the async version to catch microtasks" name="ReactTestUtils.act() legacy mode sync fake timers can use the async version to catch microtasks" time="0.036">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync fake timers can handle cascading promises with fake timers" name="ReactTestUtils.act() legacy mode sync fake timers can handle cascading promises with fake timers" time="0.057">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode sync fake timers flushes immediate re-renders with act" name="ReactTestUtils.act() legacy mode sync fake timers flushes immediate re-renders with act" time="0.04">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode asynchronous tests works with timeouts" name="ReactTestUtils.act() legacy mode asynchronous tests works with timeouts" time="0.152">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode asynchronous tests flushes microtasks before exiting (async function)" name="ReactTestUtils.act() legacy mode asynchronous tests flushes microtasks before exiting (async function)" time="0.03">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode asynchronous tests flushes microtasks before exiting (sync function)" name="ReactTestUtils.act() legacy mode asynchronous tests flushes microtasks before exiting (sync function)" time="0.027">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode asynchronous tests warns if you do not await an act call" name="ReactTestUtils.act() legacy mode asynchronous tests warns if you do not await an act call" time="0.043">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode asynchronous tests warns if you try to interleave multiple act calls" name="ReactTestUtils.act() legacy mode asynchronous tests warns if you try to interleave multiple act calls" time="0.298">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode asynchronous tests async commits and effects are guaranteed to be flushed" name="ReactTestUtils.act() legacy mode asynchronous tests async commits and effects are guaranteed to be flushed" time="0.093">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode asynchronous tests can handle cascading promises" name="ReactTestUtils.act() legacy mode asynchronous tests can handle cascading promises" time="0.151">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode error propagation propagates errors - sync" name="ReactTestUtils.act() legacy mode error propagation propagates errors - sync" time="0.048">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode error propagation should propagate errors from effects - sync" name="ReactTestUtils.act() legacy mode error propagation should propagate errors from effects - sync" time="0.11">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode error propagation propagates errors - async" name="ReactTestUtils.act() legacy mode error propagation propagates errors - async" time="0.146">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode error propagation should cleanup after errors - sync" name="ReactTestUtils.act() legacy mode error propagation should cleanup after errors - sync" time="0.067">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode error propagation should cleanup after errors - async" name="ReactTestUtils.act() legacy mode error propagation should cleanup after errors - async" time="0.225">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode suspense triggers fallbacks if available" name="ReactTestUtils.act() legacy mode suspense triggers fallbacks if available" time="0.085">
    </testcase>
    <testcase classname="ReactTestUtils.act() legacy mode throw in prod mode [GATED, SHOULD FAIL] warns if you try to use act() in prod mode" name="ReactTestUtils.act() legacy mode throw in prod mode [GATED, SHOULD FAIL] warns if you try to use act() in prod mode" time="0.056">
    </testcase>
    <testcase classname="ReactTestUtils.act() unacted effects does not warn in legacy mode" name="ReactTestUtils.act() unacted effects does not warn in legacy mode" time="0.003">
    </testcase>
    <testcase classname="ReactTestUtils.act() unacted effects does not warn in concurrent mode" name="ReactTestUtils.act() unacted effects does not warn in concurrent mode" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactCompositeComponent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:12" time="5.402" tests="53">
    <testcase classname="ReactCompositeComponent should not support module pattern components" name="ReactCompositeComponent should not support module pattern components" time="0.112">
    </testcase>
    <testcase classname="ReactCompositeComponent should support rendering to different child types over time" name="ReactCompositeComponent should support rendering to different child types over time" time="0.041">
    </testcase>
    <testcase classname="ReactCompositeComponent should react to state changes from callbacks" name="ReactCompositeComponent should react to state changes from callbacks" time="0.083">
    </testcase>
    <testcase classname="ReactCompositeComponent should rewire refs when rendering to different child types" name="ReactCompositeComponent should rewire refs when rendering to different child types" time="0.06">
    </testcase>
    <testcase classname="ReactCompositeComponent should not cache old DOM nodes when switching constructors" name="ReactCompositeComponent should not cache old DOM nodes when switching constructors" time="0.103">
    </testcase>
    <testcase classname="ReactCompositeComponent should use default values for undefined props" name="ReactCompositeComponent should use default values for undefined props" time="0.109">
    </testcase>
    <testcase classname="ReactCompositeComponent should not mutate passed-in props object" name="ReactCompositeComponent should not mutate passed-in props object" time="0.092">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn about `forceUpdate` on not-yet-mounted components" name="ReactCompositeComponent should warn about `forceUpdate` on not-yet-mounted components" time="0.124">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn about `setState` on not-yet-mounted components" name="ReactCompositeComponent should warn about `setState` on not-yet-mounted components" time="0.205">
    </testcase>
    <testcase classname="ReactCompositeComponent should not warn about `forceUpdate` on unmounted components" name="ReactCompositeComponent should not warn about `forceUpdate` on unmounted components" time="0.158">
    </testcase>
    <testcase classname="ReactCompositeComponent should not warn about `setState` on unmounted components" name="ReactCompositeComponent should not warn about `setState` on unmounted components" time="0.078">
    </testcase>
    <testcase classname="ReactCompositeComponent should silently allow `setState`, not call cb on unmounting components" name="ReactCompositeComponent should silently allow `setState`, not call cb on unmounting components" time="0.054">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn when rendering a class with a render method that does not extend React.Component" name="ReactCompositeComponent should warn when rendering a class with a render method that does not extend React.Component" time="0.102">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn about `setState` in render" name="ReactCompositeComponent should warn about `setState` in render" time="0.092">
    </testcase>
    <testcase classname="ReactCompositeComponent should cleanup even if render() fatals" name="ReactCompositeComponent should cleanup even if render() fatals" time="0.037">
    </testcase>
    <testcase classname="ReactCompositeComponent should call componentWillUnmount before unmounting" name="ReactCompositeComponent should call componentWillUnmount before unmounting" time="0.075">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn when shouldComponentUpdate() returns undefined" name="ReactCompositeComponent should warn when shouldComponentUpdate() returns undefined" time="0.063">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn when componentDidUnmount method is defined" name="ReactCompositeComponent should warn when componentDidUnmount method is defined" time="0.06">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn when componentDidReceiveProps method is defined" name="ReactCompositeComponent should warn when componentDidReceiveProps method is defined" time="0.061">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn when defaultProps was defined as an instance property" name="ReactCompositeComponent should warn when defaultProps was defined as an instance property" time="0.062">
    </testcase>
    <testcase classname="ReactCompositeComponent should pass context to children when not owner" name="ReactCompositeComponent should pass context to children when not owner" time="0.058">
    </testcase>
    <testcase classname="ReactCompositeComponent should skip update when rerendering element in container" name="ReactCompositeComponent should skip update when rerendering element in container" time="0.044">
    </testcase>
    <testcase classname="ReactCompositeComponent should pass context when re-rendered for static child" name="ReactCompositeComponent should pass context when re-rendered for static child" time="0.072">
    </testcase>
    <testcase classname="ReactCompositeComponent should pass context when re-rendered for static child within a composite component" name="ReactCompositeComponent should pass context when re-rendered for static child within a composite component" time="0.045">
    </testcase>
    <testcase classname="ReactCompositeComponent should pass context transitively" name="ReactCompositeComponent should pass context transitively" time="0.084">
    </testcase>
    <testcase classname="ReactCompositeComponent should pass context when re-rendered" name="ReactCompositeComponent should pass context when re-rendered" time="0.039">
    </testcase>
    <testcase classname="ReactCompositeComponent unmasked context propagates through updates" name="ReactCompositeComponent unmasked context propagates through updates" time="0.065">
    </testcase>
    <testcase classname="ReactCompositeComponent should trigger componentWillReceiveProps for context changes" name="ReactCompositeComponent should trigger componentWillReceiveProps for context changes" time="0.039">
    </testcase>
    <testcase classname="ReactCompositeComponent should disallow nested render calls" name="ReactCompositeComponent should disallow nested render calls" time="0.063">
    </testcase>
    <testcase classname="ReactCompositeComponent only renders once if updated in componentWillReceiveProps" name="ReactCompositeComponent only renders once if updated in componentWillReceiveProps" time="0.037">
    </testcase>
    <testcase classname="ReactCompositeComponent only renders once if updated in componentWillReceiveProps when batching" name="ReactCompositeComponent only renders once if updated in componentWillReceiveProps when batching" time="0.046">
    </testcase>
    <testcase classname="ReactCompositeComponent should update refs if shouldComponentUpdate gives false" name="ReactCompositeComponent should update refs if shouldComponentUpdate gives false" time="0.055">
    </testcase>
    <testcase classname="ReactCompositeComponent should allow access to findDOMNode in componentWillUnmount" name="ReactCompositeComponent should allow access to findDOMNode in componentWillUnmount" time="0.067">
    </testcase>
    <testcase classname="ReactCompositeComponent context should be passed down from the parent" name="ReactCompositeComponent context should be passed down from the parent" time="0.041">
    </testcase>
    <testcase classname="ReactCompositeComponent should replace state" name="ReactCompositeComponent should replace state" time="0.063">
    </testcase>
    <testcase classname="ReactCompositeComponent should support objects with prototypes as state" name="ReactCompositeComponent should support objects with prototypes as state" time="0.119">
    </testcase>
    <testcase classname="ReactCompositeComponent should not warn about unmounting during unmounting" name="ReactCompositeComponent should not warn about unmounting during unmounting" time="0.081">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn when mutated props are passed" name="ReactCompositeComponent should warn when mutated props are passed" time="0.084">
    </testcase>
    <testcase classname="ReactCompositeComponent should only call componentWillUnmount once" name="ReactCompositeComponent should only call componentWillUnmount once" time="0.046">
    </testcase>
    <testcase classname="ReactCompositeComponent prepares new child before unmounting old" name="ReactCompositeComponent prepares new child before unmounting old" time="0.07">
    </testcase>
    <testcase classname="ReactCompositeComponent respects a shallow shouldComponentUpdate implementation" name="ReactCompositeComponent respects a shallow shouldComponentUpdate implementation" time="0.067">
    </testcase>
    <testcase classname="ReactCompositeComponent does not do a deep comparison for a shallow shouldComponentUpdate implementation" name="ReactCompositeComponent does not do a deep comparison for a shallow shouldComponentUpdate implementation" time="0.059">
    </testcase>
    <testcase classname="ReactCompositeComponent should call setState callback with no arguments" name="ReactCompositeComponent should call setState callback with no arguments" time="0.027">
    </testcase>
    <testcase classname="ReactCompositeComponent this.state should be updated on setState callback inside componentWillMount" name="ReactCompositeComponent this.state should be updated on setState callback inside componentWillMount" time="0.112">
    </testcase>
    <testcase classname="ReactCompositeComponent should call the setState callback even if shouldComponentUpdate = false" name="ReactCompositeComponent should call the setState callback even if shouldComponentUpdate = false" time="0.149">
    </testcase>
    <testcase classname="ReactCompositeComponent should return a meaningful warning when constructor is returned" name="ReactCompositeComponent should return a meaningful warning when constructor is returned" time="0.176">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn about reassigning this.props while rendering" name="ReactCompositeComponent should warn about reassigning this.props while rendering" time="0.082">
    </testcase>
    <testcase classname="ReactCompositeComponent should return error if render is not defined" name="ReactCompositeComponent should return error if render is not defined" time="0.09">
    </testcase>
    <testcase classname="ReactCompositeComponent should support classes shadowing isReactComponent" name="ReactCompositeComponent should support classes shadowing isReactComponent" time="0.111">
    </testcase>
    <testcase classname="ReactCompositeComponent should not warn on updating function component from componentWillMount" name="ReactCompositeComponent should not warn on updating function component from componentWillMount" time="0.067">
    </testcase>
    <testcase classname="ReactCompositeComponent should not warn on updating function component from componentWillUpdate" name="ReactCompositeComponent should not warn on updating function component from componentWillUpdate" time="0.061">
    </testcase>
    <testcase classname="ReactCompositeComponent should not warn on updating function component from componentWillReceiveProps" name="ReactCompositeComponent should not warn on updating function component from componentWillReceiveProps" time="0.093">
    </testcase>
    <testcase classname="ReactCompositeComponent should warn on updating function component from render" name="ReactCompositeComponent should warn on updating function component from render" time="0.08">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/findDOMNode-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:17" time="0.829" tests="8">
    <testcase classname="findDOMNode findDOMNode should return null if passed null" name="findDOMNode findDOMNode should return null if passed null" time="0.001">
    </testcase>
    <testcase classname="findDOMNode findDOMNode should find dom element" name="findDOMNode findDOMNode should find dom element" time="0.003">
    </testcase>
    <testcase classname="findDOMNode findDOMNode should find dom element after an update from null" name="findDOMNode findDOMNode should find dom element after an update from null" time="0.003">
    </testcase>
    <testcase classname="findDOMNode findDOMNode should reject random objects" name="findDOMNode findDOMNode should reject random objects" time="0.002">
    </testcase>
    <testcase classname="findDOMNode findDOMNode should reject unmounted objects with render func" name="findDOMNode findDOMNode should reject unmounted objects with render func" time="0.046">
    </testcase>
    <testcase classname="findDOMNode findDOMNode should not throw an error when called within a component that is not mounted" name="findDOMNode findDOMNode should not throw an error when called within a component that is not mounted" time="0.002">
    </testcase>
    <testcase classname="findDOMNode findDOMNode should warn if used to find a host component inside StrictMode" name="findDOMNode findDOMNode should warn if used to find a host component inside StrictMode" time="0.004">
    </testcase>
    <testcase classname="findDOMNode findDOMNode should warn if passed a component that is inside StrictMode" name="findDOMNode findDOMNode should warn if passed a component that is inside StrictMode" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactEventIndependence-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:17" time="0.541" tests="3">
    <testcase classname="ReactEventIndependence does not crash with other react inside" name="ReactEventIndependence does not crash with other react inside" time="0.09">
    </testcase>
    <testcase classname="ReactEventIndependence does not crash with other react outside" name="ReactEventIndependence does not crash with other react outside" time="0.079">
    </testcase>
    <testcase classname="ReactEventIndependence does not when event fired on unmounted tree" name="ReactEventIndependence does not when event fired on unmounted tree" time="0.045">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactCompositeComponentDOMMinimalism-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:17" time="0.563" tests="3">
    <testcase classname="ReactCompositeComponentDOMMinimalism should not render extra nodes for non-interpolated text" name="ReactCompositeComponentDOMMinimalism should not render extra nodes for non-interpolated text" time="0.082">
    </testcase>
    <testcase classname="ReactCompositeComponentDOMMinimalism should not render extra nodes for non-interpolated text" name="ReactCompositeComponentDOMMinimalism should not render extra nodes for non-interpolated text" time="0.002">
    </testcase>
    <testcase classname="ReactCompositeComponentDOMMinimalism should not render extra nodes for non-interpolated text" name="ReactCompositeComponentDOMMinimalism should not render extra nodes for non-interpolated text" time="0.028">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMComponentTree-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:18" time="0.505" tests="6">
    <testcase classname="ReactDOMComponentTree finds nodes for instances on events" name="ReactDOMComponentTree finds nodes for instances on events" time="0.081">
    </testcase>
    <testcase classname="ReactDOMComponentTree finds closest instance for node when an event happens" name="ReactDOMComponentTree finds closest instance for node when an event happens" time="0.016">
    </testcase>
    <testcase classname="ReactDOMComponentTree updates event handlers from fiber props" name="ReactDOMComponentTree updates event handlers from fiber props" time="0.004">
    </testcase>
    <testcase classname="ReactDOMComponentTree finds a controlled instance from node and gets its current fiber props" name="ReactDOMComponentTree finds a controlled instance from node and gets its current fiber props" time="0.02">
    </testcase>
    <testcase classname="ReactDOMComponentTree finds instance of node that is attempted to be unmounted" name="ReactDOMComponentTree finds instance of node that is attempted to be unmounted" time="0.011">
    </testcase>
    <testcase classname="ReactDOMComponentTree finds instance from node to stop rendering over other react rendered components" name="ReactDOMComponentTree finds instance from node to stop rendering over other react rendered components" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationLegacyContextDisabled-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:17" time="1.65" tests="10">
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with server string render" name="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with server string render" time="0.133">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with server stream render" name="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with server stream render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with clean client render" name="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with client render on top of good server markup" name="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with client render on top of good server markup" time="0.114">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with client render on top of bad server markup" name="ReactDOMServerIntegrationLegacyContextDisabled renders undefined legacy context with warning with client render on top of bad server markup" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with server string render" name="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with server string render" time="0.033">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with server stream render" name="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with server stream render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with clean client render" name="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with clean client render" time="0.158">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with client render on top of good server markup" name="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with client render on top of good server markup" time="0.329">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with client render on top of bad server markup" name="ReactDOMServerIntegrationLegacyContextDisabled renders modern context with client render on top of bad server markup" time="0.244">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactIdentity-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:18" time="1.372" tests="11">
    <testcase classname="ReactIdentity should allow key property to express identity" name="ReactIdentity should allow key property to express identity" time="0.103">
    </testcase>
    <testcase classname="ReactIdentity should use composite identity" name="ReactIdentity should use composite identity" time="0.048">
    </testcase>
    <testcase classname="ReactIdentity should allow any character as a key, in a detached parent" name="ReactIdentity should allow any character as a key, in a detached parent" time="0.049">
    </testcase>
    <testcase classname="ReactIdentity should allow any character as a key, in an attached parent" name="ReactIdentity should allow any character as a key, in an attached parent" time="0.042">
    </testcase>
    <testcase classname="ReactIdentity should not allow scripts in keys to execute" name="ReactIdentity should not allow scripts in keys to execute" time="0.051">
    </testcase>
    <testcase classname="ReactIdentity should let restructured components retain their uniqueness" name="ReactIdentity should let restructured components retain their uniqueness" time="0.048">
    </testcase>
    <testcase classname="ReactIdentity should let nested restructures retain their uniqueness" name="ReactIdentity should let nested restructures retain their uniqueness" time="0.054">
    </testcase>
    <testcase classname="ReactIdentity should let text nodes retain their uniqueness" name="ReactIdentity should let text nodes retain their uniqueness" time="0.098">
    </testcase>
    <testcase classname="ReactIdentity should retain key during updates in composite components" name="ReactIdentity should retain key during updates in composite components" time="0.096">
    </testcase>
    <testcase classname="ReactIdentity should not allow implicit and explicit keys to collide" name="ReactIdentity should not allow implicit and explicit keys to collide" time="0.118">
    </testcase>
    <testcase classname="ReactIdentity should throw if key is a Temporal-like object" name="ReactIdentity should throw if key is a Temporal-like object" time="0.098">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactServerRenderingBrowser-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:20" time="0.622" tests="2">
    <testcase classname="ReactServerRenderingBrowser returns the same results as react-dom/server" name="ReactServerRenderingBrowser returns the same results as react-dom/server" time="0.129">
    </testcase>
    <testcase classname="ReactServerRenderingBrowser throws meaningfully for server-only APIs" name="ReactServerRenderingBrowser throws meaningfully for server-only APIs" time="0.039">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMFizzShellHydration-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:17" time="4.651" tests="4">
    <testcase classname="ReactDOMFizzShellHydration suspending in the shell during hydration" name="ReactDOMFizzShellHydration suspending in the shell during hydration" time="2.391">
    </testcase>
    <testcase classname="ReactDOMFizzShellHydration suspending in the shell during a normal client render" name="ReactDOMFizzShellHydration suspending in the shell during a normal client render" time="0.759">
    </testcase>
    <testcase classname="ReactDOMFizzShellHydration updating the root at lower priority than initial hydration does not force a client render" name="ReactDOMFizzShellHydration updating the root at lower priority than initial hydration does not force a client render" time="0.412">
    </testcase>
    <testcase classname="ReactDOMFizzShellHydration updating the root while the shell is suspended forces a client render" name="ReactDOMFizzShellHydration updating the root while the shell is suspended forces a client render" time="0.402">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationRefs-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:21" time="1.32" tests="5">
    <testcase classname="ReactDOMServerIntegration refs should not run ref code on server" name="ReactDOMServerIntegration refs should not run ref code on server" time="0.195">
    </testcase>
    <testcase classname="ReactDOMServerIntegration refs should run ref code on client" name="ReactDOMServerIntegration refs should run ref code on client" time="0.12">
    </testcase>
    <testcase classname="ReactDOMServerIntegration refs should send the correct element to ref functions on client" name="ReactDOMServerIntegration refs should send the correct element to ref functions on client" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegration refs should have string refs on client when rendered over server markup" name="ReactDOMServerIntegration refs should have string refs on client when rendered over server markup" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration should forward refs" name="ReactDOMServerIntegration should forward refs" time="0.132">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMTextarea-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:18" time="3.913" tests="42">
    <testcase classname="ReactDOMTextarea should allow setting `defaultValue`" name="ReactDOMTextarea should allow setting `defaultValue`" time="0.073">
    </testcase>
    <testcase classname="ReactDOMTextarea should display `defaultValue` of number 0" name="ReactDOMTextarea should display `defaultValue` of number 0" time="0.054">
    </testcase>
    <testcase classname="ReactDOMTextarea should display &quot;false&quot; for `defaultValue` of `false`" name="ReactDOMTextarea should display &quot;false&quot; for `defaultValue` of `false`" time="0.053">
    </testcase>
    <testcase classname="ReactDOMTextarea should display &quot;foobar&quot; for `defaultValue` of `objToString`" name="ReactDOMTextarea should display &quot;foobar&quot; for `defaultValue` of `objToString`" time="0.08">
    </testcase>
    <testcase classname="ReactDOMTextarea should set defaultValue" name="ReactDOMTextarea should set defaultValue" time="0.107">
    </testcase>
    <testcase classname="ReactDOMTextarea should not render value as an attribute" name="ReactDOMTextarea should not render value as an attribute" time="0.192">
    </testcase>
    <testcase classname="ReactDOMTextarea should display `value` of number 0" name="ReactDOMTextarea should display `value` of number 0" time="0.138">
    </testcase>
    <testcase classname="ReactDOMTextarea should update defaultValue to empty string" name="ReactDOMTextarea should update defaultValue to empty string" time="0.15">
    </testcase>
    <testcase classname="ReactDOMTextarea should allow setting `value` to `giraffe`" name="ReactDOMTextarea should allow setting `value` to `giraffe`" time="0.091">
    </testcase>
    <testcase classname="ReactDOMTextarea will not initially assign an empty value (covers case where firefox throws a validation error when required attribute is set)" name="ReactDOMTextarea will not initially assign an empty value (covers case where firefox throws a validation error when required attribute is set)" time="0.045">
    </testcase>
    <testcase classname="ReactDOMTextarea should render defaultValue for SSR" name="ReactDOMTextarea should render defaultValue for SSR" time="0.073">
    </testcase>
    <testcase classname="ReactDOMTextarea should render value for SSR" name="ReactDOMTextarea should render value for SSR" time="0.038">
    </testcase>
    <testcase classname="ReactDOMTextarea should allow setting `value` to `true`" name="ReactDOMTextarea should allow setting `value` to `true`" time="0.08">
    </testcase>
    <testcase classname="ReactDOMTextarea should allow setting `value` to `false`" name="ReactDOMTextarea should allow setting `value` to `false`" time="0.066">
    </testcase>
    <testcase classname="ReactDOMTextarea should allow setting `value` to `objToString`" name="ReactDOMTextarea should allow setting `value` to `objToString`" time="0.048">
    </testcase>
    <testcase classname="ReactDOMTextarea should throw when value is set to a Temporal-like object" name="ReactDOMTextarea should throw when value is set to a Temporal-like object" time="0.085">
    </testcase>
    <testcase classname="ReactDOMTextarea should take updates to `defaultValue` for uncontrolled textarea" name="ReactDOMTextarea should take updates to `defaultValue` for uncontrolled textarea" time="0.043">
    </testcase>
    <testcase classname="ReactDOMTextarea should take updates to children in lieu of `defaultValue` for uncontrolled textarea" name="ReactDOMTextarea should take updates to children in lieu of `defaultValue` for uncontrolled textarea" time="0.052">
    </testcase>
    <testcase classname="ReactDOMTextarea should not incur unnecessary DOM mutations" name="ReactDOMTextarea should not incur unnecessary DOM mutations" time="0.086">
    </testcase>
    <testcase classname="ReactDOMTextarea should properly control a value of number `0`" name="ReactDOMTextarea should properly control a value of number `0`" time="0.054">
    </testcase>
    <testcase classname="ReactDOMTextarea should ignore children content" name="ReactDOMTextarea should ignore children content" time="0.047">
    </testcase>
    <testcase classname="ReactDOMTextarea should receive defaultValue and still ignore children content" name="ReactDOMTextarea should receive defaultValue and still ignore children content" time="0.041">
    </testcase>
    <testcase classname="ReactDOMTextarea should keep value when switching to uncontrolled element if not changed" name="ReactDOMTextarea should keep value when switching to uncontrolled element if not changed" time="0.075">
    </testcase>
    <testcase classname="ReactDOMTextarea should keep value when switching to uncontrolled element if changed" name="ReactDOMTextarea should keep value when switching to uncontrolled element if changed" time="0.057">
    </testcase>
    <testcase classname="ReactDOMTextarea should ignore numbers as children" name="ReactDOMTextarea should ignore numbers as children" time="0.045">
    </testcase>
    <testcase classname="ReactDOMTextarea should ignore booleans as children" name="ReactDOMTextarea should ignore booleans as children" time="0.068">
    </testcase>
    <testcase classname="ReactDOMTextarea should ignore objects as children" name="ReactDOMTextarea should ignore objects as children" time="0.05">
    </testcase>
    <testcase classname="ReactDOMTextarea should unmount" name="ReactDOMTextarea should unmount" time="0.063">
    </testcase>
    <testcase classname="ReactDOMTextarea should warn if value is null" name="ReactDOMTextarea should warn if value is null" time="0.041">
    </testcase>
    <testcase classname="ReactDOMTextarea should warn if value and defaultValue are specified" name="ReactDOMTextarea should warn if value and defaultValue are specified" time="0.084">
    </testcase>
    <testcase classname="ReactDOMTextarea should not warn about missing onChange in uncontrolled textareas" name="ReactDOMTextarea should not warn about missing onChange in uncontrolled textareas" time="0.04">
    </testcase>
    <testcase classname="ReactDOMTextarea does not set textContent if value is unchanged" name="ReactDOMTextarea does not set textContent if value is unchanged" time="0.066">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a Symbol value treats initial Symbol value as an empty string" name="ReactDOMTextarea When given a Symbol value treats initial Symbol value as an empty string" time="0.061">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a Symbol value treats initial Symbol children as an empty string" name="ReactDOMTextarea When given a Symbol value treats initial Symbol children as an empty string" time="0.045">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a Symbol value treats updated Symbol value as an empty string" name="ReactDOMTextarea When given a Symbol value treats updated Symbol value as an empty string" time="0.063">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a Symbol value treats initial Symbol defaultValue as an empty string" name="ReactDOMTextarea When given a Symbol value treats initial Symbol defaultValue as an empty string" time="0.038">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a Symbol value treats updated Symbol defaultValue as an empty string" name="ReactDOMTextarea When given a Symbol value treats updated Symbol defaultValue as an empty string" time="0.096">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a function value treats initial function value as an empty string" name="ReactDOMTextarea When given a function value treats initial function value as an empty string" time="0.146">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a function value treats initial function children as an empty string" name="ReactDOMTextarea When given a function value treats initial function children as an empty string" time="0.138">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a function value treats updated function value as an empty string" name="ReactDOMTextarea When given a function value treats updated function value as an empty string" time="0.202">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a function value treats initial function defaultValue as an empty string" name="ReactDOMTextarea When given a function value treats initial function defaultValue as an empty string" time="0.173">
    </testcase>
    <testcase classname="ReactDOMTextarea When given a function value treats updated function defaultValue as an empty string" name="ReactDOMTextarea When given a function value treats updated function defaultValue as an empty string" time="0.039">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMTestSelectors-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:19" time="3.704" tests="37">
    <testcase classname="ReactDOMTestSelectors findAllNodes should support searching from the document root" name="ReactDOMTestSelectors findAllNodes should support searching from the document root" time="0.116">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support searching from the container" name="ReactDOMTestSelectors findAllNodes should support searching from the container" time="0.048">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support searching from a previous match if the match had a data-testname" name="ReactDOMTestSelectors findAllNodes should support searching from a previous match if the match had a data-testname" time="0.081">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should not support searching from a previous match if the match did not have a data-testname" name="ReactDOMTestSelectors findAllNodes should not support searching from a previous match if the match did not have a data-testname" time="0.056">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support an multiple component types in the selector array" name="ReactDOMTestSelectors findAllNodes should support an multiple component types in the selector array" time="0.068">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should find multiple matches" name="ReactDOMTestSelectors findAllNodes should find multiple matches" time="0.064">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should ignore nested matches" name="ReactDOMTestSelectors findAllNodes should ignore nested matches" time="0.038">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should enforce the specific order of selectors" name="ReactDOMTestSelectors findAllNodes should enforce the specific order of selectors" time="0.049">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should not search within hidden subtrees" name="ReactDOMTestSelectors findAllNodes should not search within hidden subtrees" time="0.097">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support filtering by display text" name="ReactDOMTestSelectors findAllNodes should support filtering by display text" time="0.039">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support filtering by explicit accessibiliy role" name="ReactDOMTestSelectors findAllNodes should support filtering by explicit accessibiliy role" time="0.061">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support filtering by explicit secondary accessibiliy role" name="ReactDOMTestSelectors findAllNodes should support filtering by explicit secondary accessibiliy role" time="0.097">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support filtering by implicit accessibiliy role" name="ReactDOMTestSelectors findAllNodes should support filtering by implicit accessibiliy role" time="0.106">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support filtering by implicit accessibiliy role with attributes qualifications" name="ReactDOMTestSelectors findAllNodes should support filtering by implicit accessibiliy role with attributes qualifications" time="0.149">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should support searching ahead with the has() selector" name="ReactDOMTestSelectors findAllNodes should support searching ahead with the has() selector" time="0.114">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should throw if no container can be found" name="ReactDOMTestSelectors findAllNodes should throw if no container can be found" time="0.11">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findAllNodes should throw if an invalid host root is specified" name="ReactDOMTestSelectors findAllNodes should throw if an invalid host root is specified" time="0.16">
    </testcase>
    <testcase classname="ReactDOMTestSelectors getFindAllNodesFailureDescription should describe findAllNodes failures caused by the component type selector" name="ReactDOMTestSelectors getFindAllNodesFailureDescription should describe findAllNodes failures caused by the component type selector" time="0.059">
    </testcase>
    <testcase classname="ReactDOMTestSelectors getFindAllNodesFailureDescription should return null if findAllNodeswas able to find a match" name="ReactDOMTestSelectors getFindAllNodesFailureDescription should return null if findAllNodeswas able to find a match" time="0.078">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findBoundingRects should return a single rect for a component that returns a single root host element" name="ReactDOMTestSelectors findBoundingRects should return a single rect for a component that returns a single root host element" time="0.095">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findBoundingRects should return a multiple rects for multiple matches" name="ReactDOMTestSelectors findBoundingRects should return a multiple rects for multiple matches" time="0.07">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findBoundingRects should return a multiple rects for single match that returns a fragment" name="ReactDOMTestSelectors findBoundingRects should return a multiple rects for single match that returns a fragment" time="0.082">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findBoundingRects should merge overlapping rects" name="ReactDOMTestSelectors findBoundingRects should merge overlapping rects" time="0.068">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findBoundingRects should merge some types of adjacent rects (if they are the same in one dimension)" name="ReactDOMTestSelectors findBoundingRects should merge some types of adjacent rects (if they are the same in one dimension)" time="0.053">
    </testcase>
    <testcase classname="ReactDOMTestSelectors findBoundingRects should not search within hidden subtrees" name="ReactDOMTestSelectors findBoundingRects should not search within hidden subtrees" time="0.048">
    </testcase>
    <testcase classname="ReactDOMTestSelectors focusWithin should return false if the specified component path has no matches" name="ReactDOMTestSelectors focusWithin should return false if the specified component path has no matches" time="0.057">
    </testcase>
    <testcase classname="ReactDOMTestSelectors focusWithin should return false if there are no focusable elements within the matched subtree" name="ReactDOMTestSelectors focusWithin should return false if there are no focusable elements within the matched subtree" time="0.084">
    </testcase>
    <testcase classname="ReactDOMTestSelectors focusWithin should return false if the only focusable elements are disabled" name="ReactDOMTestSelectors focusWithin should return false if the only focusable elements are disabled" time="0.045">
    </testcase>
    <testcase classname="ReactDOMTestSelectors focusWithin should return false if the only focusable elements are hidden" name="ReactDOMTestSelectors focusWithin should return false if the only focusable elements are hidden" time="0.065">
    </testcase>
    <testcase classname="ReactDOMTestSelectors focusWithin should successfully focus the first focusable element within the tree" name="ReactDOMTestSelectors focusWithin should successfully focus the first focusable element within the tree" time="0.063">
    </testcase>
    <testcase classname="ReactDOMTestSelectors focusWithin should successfully focus the first focusable element even if application logic interferes" name="ReactDOMTestSelectors focusWithin should successfully focus the first focusable element even if application logic interferes" time="0.031">
    </testcase>
    <testcase classname="ReactDOMTestSelectors focusWithin should not focus within hidden subtrees" name="ReactDOMTestSelectors focusWithin should not focus within hidden subtrees" time="0.072">
    </testcase>
    <testcase classname="ReactDOMTestSelectors observeVisibleRects should notify a listener when the underlying instance intersection changes" name="ReactDOMTestSelectors observeVisibleRects should notify a listener when the underlying instance intersection changes" time="0.043">
    </testcase>
    <testcase classname="ReactDOMTestSelectors observeVisibleRects should notify a listener of multiple targets when the underlying instance intersection changes" name="ReactDOMTestSelectors observeVisibleRects should notify a listener of multiple targets when the underlying instance intersection changes" time="0.056">
    </testcase>
    <testcase classname="ReactDOMTestSelectors observeVisibleRects should stop listening when its disconnected" name="ReactDOMTestSelectors observeVisibleRects should stop listening when its disconnected" time="0.053">
    </testcase>
    <testcase classname="ReactDOMTestSelectors observeVisibleRects should update which targets its listening to after a commit" name="ReactDOMTestSelectors observeVisibleRects should update which targets its listening to after a commit" time="0.092">
    </testcase>
    <testcase classname="ReactDOMTestSelectors observeVisibleRects should not observe components within hidden subtrees" name="ReactDOMTestSelectors observeVisibleRects should not observe components within hidden subtrees" time="0.037">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactTestUtils-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:22" time="0.894" tests="18">
    <testcase classname="ReactTestUtils Simulate should have locally attached media events" name="ReactTestUtils Simulate should have locally attached media events" time="0.012">
    </testcase>
    <testcase classname="ReactTestUtils gives Jest mocks a passthrough implementation with mockComponent()" name="ReactTestUtils gives Jest mocks a passthrough implementation with mockComponent()" time="0.003">
    </testcase>
    <testcase classname="ReactTestUtils can scryRenderedComponentsWithType" name="ReactTestUtils can scryRenderedComponentsWithType" time="0.002">
    </testcase>
    <testcase classname="ReactTestUtils can scryRenderedDOMComponentsWithClass with TextComponent" name="ReactTestUtils can scryRenderedDOMComponentsWithClass with TextComponent" time="0.014">
    </testcase>
    <testcase classname="ReactTestUtils can scryRenderedDOMComponentsWithClass with className contains \n" name="ReactTestUtils can scryRenderedDOMComponentsWithClass with className contains \n" time="0.003">
    </testcase>
    <testcase classname="ReactTestUtils can scryRenderedDOMComponentsWithClass with multiple classes" name="ReactTestUtils can scryRenderedDOMComponentsWithClass with multiple classes" time="0.024">
    </testcase>
    <testcase classname="ReactTestUtils traverses children in the correct order" name="ReactTestUtils traverses children in the correct order" time="0.004">
    </testcase>
    <testcase classname="ReactTestUtils should support injected wrapper components as DOM components" name="ReactTestUtils should support injected wrapper components as DOM components" time="0.061">
    </testcase>
    <testcase classname="ReactTestUtils can scry with stateless components involved" name="ReactTestUtils can scry with stateless components involved" time="0.002">
    </testcase>
    <testcase classname="ReactTestUtils provides a clear error when passing invalid objects to scry" name="ReactTestUtils provides a clear error when passing invalid objects to scry" time="0.007">
    </testcase>
    <testcase classname="ReactTestUtils Simulate should change the value of an input field" name="ReactTestUtils Simulate should change the value of an input field" time="0.005">
    </testcase>
    <testcase classname="ReactTestUtils Simulate should change the value of an input field in a component" name="ReactTestUtils Simulate should change the value of an input field in a component" time="0.003">
    </testcase>
    <testcase classname="ReactTestUtils Simulate should throw when attempting to use a React element" name="ReactTestUtils Simulate should throw when attempting to use a React element" time="0.018">
    </testcase>
    <testcase classname="ReactTestUtils Simulate should throw when attempting to use a component instance" name="ReactTestUtils Simulate should throw when attempting to use a component instance" time="0.002">
    </testcase>
    <testcase classname="ReactTestUtils Simulate should not warn when used with extra properties" name="ReactTestUtils Simulate should not warn when used with extra properties" time="0.004">
    </testcase>
    <testcase classname="ReactTestUtils Simulate should set the type of the event" name="ReactTestUtils Simulate should set the type of the event" time="0.001">
    </testcase>
    <testcase classname="ReactTestUtils Simulate should work with renderIntoDocument" name="ReactTestUtils Simulate should work with renderIntoDocument" time="0.002">
    </testcase>
    <testcase classname="ReactTestUtils should call setState callback with no arguments" name="ReactTestUtils should call setState callback with no arguments" time="0.011">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMInvalidARIAHook-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:23" time="0.677" tests="6">
    <testcase classname="ReactDOMInvalidARIAHook aria-* props should allow valid aria-* props" name="ReactDOMInvalidARIAHook aria-* props should allow valid aria-* props" time="0.081">
    </testcase>
    <testcase classname="ReactDOMInvalidARIAHook aria-* props should warn for one invalid aria-* prop" name="ReactDOMInvalidARIAHook aria-* props should warn for one invalid aria-* prop" time="0.106">
    </testcase>
    <testcase classname="ReactDOMInvalidARIAHook aria-* props should warn for many invalid aria-* props" name="ReactDOMInvalidARIAHook aria-* props should warn for many invalid aria-* props" time="0.041">
    </testcase>
    <testcase classname="ReactDOMInvalidARIAHook aria-* props should warn for an improperly cased aria-* prop" name="ReactDOMInvalidARIAHook aria-* props should warn for an improperly cased aria-* prop" time="0.046">
    </testcase>
    <testcase classname="ReactDOMInvalidARIAHook aria-* props should warn for use of recognized camel case aria attributes" name="ReactDOMInvalidARIAHook aria-* props should warn for use of recognized camel case aria attributes" time="0.04">
    </testcase>
    <testcase classname="ReactDOMInvalidARIAHook aria-* props should warn for use of unrecognized camel case aria attributes" name="ReactDOMInvalidARIAHook aria-* props should warn for use of unrecognized camel case aria attributes" time="0.052">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationLegacyContext-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:18" time="6.26" tests="59">
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with context with server string render" name="ReactDOMServerIntegration legacy context renders class child with context with server string render" time="0.119">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with context with server stream render" name="ReactDOMServerIntegration legacy context renders class child with context with server stream render" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with context with clean client render" name="ReactDOMServerIntegration legacy context renders class child with context with clean client render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with context with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders class child with context with client render on top of good server markup" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with context with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders class child with context with client render on top of bad server markup" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with context with server string render" name="ReactDOMServerIntegration legacy context renders stateless child with context with server string render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with context with server stream render" name="ReactDOMServerIntegration legacy context renders stateless child with context with server stream render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with context with clean client render" name="ReactDOMServerIntegration legacy context renders stateless child with context with clean client render" time="0.224">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with context with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders stateless child with context with client render on top of good server markup" time="0.313">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with context with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders stateless child with context with client render on top of bad server markup" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child without context with server string render" name="ReactDOMServerIntegration legacy context renders class child without context with server string render" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child without context with server stream render" name="ReactDOMServerIntegration legacy context renders class child without context with server stream render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child without context with clean client render" name="ReactDOMServerIntegration legacy context renders class child without context with clean client render" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child without context with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders class child without context with client render on top of good server markup" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child without context with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders class child without context with client render on top of bad server markup" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child without context with server string render" name="ReactDOMServerIntegration legacy context renders stateless child without context with server string render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child without context with server stream render" name="ReactDOMServerIntegration legacy context renders stateless child without context with server stream render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child without context with clean client render" name="ReactDOMServerIntegration legacy context renders stateless child without context with clean client render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child without context with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders stateless child without context with client render on top of good server markup" time="0.134">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child without context with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders stateless child without context with client render on top of bad server markup" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with wrong context with server string render" name="ReactDOMServerIntegration legacy context renders class child with wrong context with server string render" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with wrong context with server stream render" name="ReactDOMServerIntegration legacy context renders class child with wrong context with server stream render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with wrong context with clean client render" name="ReactDOMServerIntegration legacy context renders class child with wrong context with clean client render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with wrong context with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders class child with wrong context with client render on top of good server markup" time="0.124">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders class child with wrong context with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders class child with wrong context with client render on top of bad server markup" time="0.083">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with wrong context with server string render" name="ReactDOMServerIntegration legacy context renders stateless child with wrong context with server string render" time="0.036">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with wrong context with server stream render" name="ReactDOMServerIntegration legacy context renders stateless child with wrong context with server stream render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with wrong context with clean client render" name="ReactDOMServerIntegration legacy context renders stateless child with wrong context with clean client render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with wrong context with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders stateless child with wrong context with client render on top of good server markup" time="0.351">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders stateless child with wrong context with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders stateless child with wrong context with client render on top of bad server markup" time="0.193">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with server string render" name="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with server string render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with server stream render" name="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with server stream render" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with clean client render" name="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with clean client render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with client render on top of good server markup" time="0.172">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders with context passed through to a grandchild with client render on top of bad server markup" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with server string render" name="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with server string render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with server stream render" name="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with server stream render" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with clean client render" name="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with clean client render" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with client render on top of good server markup" time="0.15">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders a child context overriding a parent context with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with server string render" name="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with server string render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with server stream render" name="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with server stream render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with clean client render" name="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with clean client render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with client render on top of good server markup" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders a child context merged with a parent context with client render on top of bad server markup" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with server string render" name="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with server string render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with server stream render" name="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with server stream render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with clean client render" name="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with clean client render" time="0.142">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with client render on top of good server markup" time="0.25">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders with a call to componentWillMount before getChildContext with client render on top of bad server markup" time="0.153">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with server string render" name="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with server string render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with server stream render" name="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with server stream render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with clean client render" name="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with clean client render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with client render on top of good server markup" name="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with client render on top of good server markup" time="0.14">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context renders if getChildContext exists but childContextTypes is missing with a warning with client render on top of bad server markup" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context throws when rendering if getChildContext returns a value not in childContextTypes with server string render" name="ReactDOMServerIntegration legacy context throws when rendering if getChildContext returns a value not in childContextTypes with server string render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context throws when rendering if getChildContext returns a value not in childContextTypes with clean client render" name="ReactDOMServerIntegration legacy context throws when rendering if getChildContext returns a value not in childContextTypes with clean client render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context throws when rendering if getChildContext returns a value not in childContextTypes with client render on top of bad server markup" name="ReactDOMServerIntegration legacy context throws when rendering if getChildContext returns a value not in childContextTypes with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration legacy context warns when childContextTypes is not defined" name="ReactDOMServerIntegration legacy context warns when childContextTypes is not defined" time="0.049">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMHydrationDiff-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:21" time="4.598" tests="35">
    <testcase classname="ReactDOMServerHydration text mismatch warns when client and server render different text" name="ReactDOMServerHydration text mismatch warns when client and server render different text" time="0.163">
    </testcase>
    <testcase classname="ReactDOMServerHydration text mismatch warns when client and server render different html" name="ReactDOMServerHydration text mismatch warns when client and server render different html" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerHydration attribute mismatch warns when client and server render different attributes" name="ReactDOMServerHydration attribute mismatch warns when client and server render different attributes" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerHydration attribute mismatch warns when client renders extra attributes" name="ReactDOMServerHydration attribute mismatch warns when client renders extra attributes" time="0.184">
    </testcase>
    <testcase classname="ReactDOMServerHydration attribute mismatch warns when server renders extra attributes" name="ReactDOMServerHydration attribute mismatch warns when server renders extra attributes" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerHydration attribute mismatch warns when both client and server render extra attributes" name="ReactDOMServerHydration attribute mismatch warns when both client and server render extra attributes" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerHydration attribute mismatch warns when client and server render different styles" name="ReactDOMServerHydration attribute mismatch warns when client and server render different styles" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the client extra elements on the client warns when client renders an extra element as only child" name="ReactDOMServerHydration extra nodes on the client extra elements on the client warns when client renders an extra element as only child" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the client extra elements on the client warns when client renders an extra element in the beginning" name="ReactDOMServerHydration extra nodes on the client extra elements on the client warns when client renders an extra element in the beginning" time="0.083">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the client extra elements on the client warns when client renders an extra element in the middle" name="ReactDOMServerHydration extra nodes on the client extra elements on the client warns when client renders an extra element in the middle" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the client extra elements on the client warns when client renders an extra element in the end" name="ReactDOMServerHydration extra nodes on the client extra elements on the client warns when client renders an extra element in the end" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the client extra text nodes on the client warns when client renders an extra text node as only child" name="ReactDOMServerHydration extra nodes on the client extra text nodes on the client warns when client renders an extra text node as only child" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the client extra text nodes on the client warns when client renders an extra text node in the beginning" name="ReactDOMServerHydration extra nodes on the client extra text nodes on the client warns when client renders an extra text node in the beginning" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the client extra text nodes on the client warns when client renders an extra text node in the beginning" name="ReactDOMServerHydration extra nodes on the client extra text nodes on the client warns when client renders an extra text node in the beginning" time="0.089">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the client extra text nodes on the client warns when client renders an extra text node in the end" name="ReactDOMServerHydration extra nodes on the client extra text nodes on the client warns when client renders an extra text node in the end" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the server extra elements on the server warns when server renders an extra element as only child" name="ReactDOMServerHydration extra nodes on the server extra elements on the server warns when server renders an extra element as only child" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the server extra elements on the server warns when server renders an extra element in the beginning" name="ReactDOMServerHydration extra nodes on the server extra elements on the server warns when server renders an extra element in the beginning" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the server extra elements on the server warns when server renders an extra element in the middle" name="ReactDOMServerHydration extra nodes on the server extra elements on the server warns when server renders an extra element in the middle" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the server extra elements on the server warns when server renders an extra element in the end" name="ReactDOMServerHydration extra nodes on the server extra elements on the server warns when server renders an extra element in the end" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the server extra text nodes on the server warns when server renders an extra text node as only child" name="ReactDOMServerHydration extra nodes on the server extra text nodes on the server warns when server renders an extra text node as only child" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the server extra text nodes on the server warns when server renders an extra text node in the beginning" name="ReactDOMServerHydration extra nodes on the server extra text nodes on the server warns when server renders an extra text node in the beginning" time="0.079">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the server extra text nodes on the server warns when server renders an extra text node in the middle" name="ReactDOMServerHydration extra nodes on the server extra text nodes on the server warns when server renders an extra text node in the middle" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerHydration extra nodes on the server extra text nodes on the server warns when server renders an extra text node in the end" name="ReactDOMServerHydration extra nodes on the server extra text nodes on the server warns when server renders an extra text node in the end" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Suspense warns when client renders an extra Suspense node in content mode" name="ReactDOMServerHydration special nodes Suspense warns when client renders an extra Suspense node in content mode" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Suspense warns when server renders an extra Suspense node in content mode" name="ReactDOMServerHydration special nodes Suspense warns when server renders an extra Suspense node in content mode" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Suspense warns when client renders an extra Suspense node in fallback mode" name="ReactDOMServerHydration special nodes Suspense warns when client renders an extra Suspense node in fallback mode" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Suspense warns when server renders an extra Suspense node in fallback mode" name="ReactDOMServerHydration special nodes Suspense warns when server renders an extra Suspense node in fallback mode" time="0.039">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Suspense warns when client renders an extra node inside Suspense content" name="ReactDOMServerHydration special nodes Suspense warns when client renders an extra node inside Suspense content" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Suspense warns when server renders an extra node inside Suspense content" name="ReactDOMServerHydration special nodes Suspense warns when server renders an extra node inside Suspense content" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Suspense warns when client renders an extra node inside Suspense fallback" name="ReactDOMServerHydration special nodes Suspense warns when client renders an extra node inside Suspense fallback" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Suspense warns when server renders an extra node inside Suspense fallback" name="ReactDOMServerHydration special nodes Suspense warns when server renders an extra node inside Suspense fallback" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Fragment warns when client renders an extra Fragment node" name="ReactDOMServerHydration special nodes Fragment warns when client renders an extra Fragment node" time="0.079">
    </testcase>
    <testcase classname="ReactDOMServerHydration special nodes Fragment warns when server renders an extra Fragment node" name="ReactDOMServerHydration special nodes Fragment warns when server renders an extra Fragment node" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerHydration misc cases warns when client renders an extra node deeper in the tree" name="ReactDOMServerHydration misc cases warns when client renders an extra node deeper in the tree" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerHydration misc cases warns when server renders an extra node deeper in the tree" name="ReactDOMServerHydration misc cases warns when server renders an extra node deeper in the tree" time="0.058">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOM-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:24" time="1.797" tests="13">
    <testcase classname="ReactDOM should bubble onSubmit" name="ReactDOM should bubble onSubmit" time="0.088">
    </testcase>
    <testcase classname="ReactDOM allows a DOM element to be used with a string" name="ReactDOM allows a DOM element to be used with a string" time="0.05">
    </testcase>
    <testcase classname="ReactDOM should allow children to be passed as an argument" name="ReactDOM should allow children to be passed as an argument" time="0.051">
    </testcase>
    <testcase classname="ReactDOM should overwrite props.children with children argument" name="ReactDOM should overwrite props.children with children argument" time="0.046">
    </testcase>
    <testcase classname="ReactDOM should purge the DOM cache when removing nodes" name="ReactDOM should purge the DOM cache when removing nodes" time="0.047">
    </testcase>
    <testcase classname="ReactDOM throws in render() if the mount callback is not a function" name="ReactDOM throws in render() if the mount callback is not a function" time="0.152">
    </testcase>
    <testcase classname="ReactDOM throws in render() if the update callback is not a function" name="ReactDOM throws in render() if the update callback is not a function" time="0.098">
    </testcase>
    <testcase classname="ReactDOM preserves focus" name="ReactDOM preserves focus" time="0.127">
    </testcase>
    <testcase classname="ReactDOM calls focus() on autoFocus elements after they have been mounted to the DOM" name="ReactDOM calls focus() on autoFocus elements after they have been mounted to the DOM" time="0.119">
    </testcase>
    <testcase classname="ReactDOM shouldn&apos;t fire duplicate event handler while handling other nested dispatch" name="ReactDOM shouldn&apos;t fire duplicate event handler while handling other nested dispatch" time="0.134">
    </testcase>
    <testcase classname="ReactDOM should not crash with devtools installed" name="ReactDOM should not crash with devtools installed" time="0.227">
    </testcase>
    <testcase classname="ReactDOM should not crash calling findDOMNode inside a function component" name="ReactDOM should not crash calling findDOMNode inside a function component" time="0.048">
    </testcase>
    <testcase classname="ReactDOM reports stacks with re-entrant renderToString() calls on the client" name="ReactDOM reports stacks with re-entrant renderToString() calls on the client" time="0.1">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMOption-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:25" time="1.793" tests="11">
    <testcase classname="ReactDOMOption should flatten children to a string" name="ReactDOMOption should flatten children to a string" time="0.068">
    </testcase>
    <testcase classname="ReactDOMOption should warn for invalid child tags" name="ReactDOMOption should warn for invalid child tags" time="0.057">
    </testcase>
    <testcase classname="ReactDOMOption should warn for component child if no value prop is provided" name="ReactDOMOption should warn for component child if no value prop is provided" time="0.08">
    </testcase>
    <testcase classname="ReactDOMOption should not warn for component child if value prop is provided" name="ReactDOMOption should not warn for component child if value prop is provided" time="0.113">
    </testcase>
    <testcase classname="ReactDOMOption should ignore null/undefined/false children without warning" name="ReactDOMOption should ignore null/undefined/false children without warning" time="0.082">
    </testcase>
    <testcase classname="ReactDOMOption should throw on object children" name="ReactDOMOption should throw on object children" time="0.207">
    </testcase>
    <testcase classname="ReactDOMOption should support element-ish child" name="ReactDOMOption should support element-ish child" time="0.189">
    </testcase>
    <testcase classname="ReactDOMOption should be able to use dangerouslySetInnerHTML on option" name="ReactDOMOption should be able to use dangerouslySetInnerHTML on option" time="0.047">
    </testcase>
    <testcase classname="ReactDOMOption should set attribute for empty value" name="ReactDOMOption should set attribute for empty value" time="0.036">
    </testcase>
    <testcase classname="ReactDOMOption should allow ignoring `value` on option" name="ReactDOMOption should allow ignoring `value` on option" time="0.071">
    </testcase>
    <testcase classname="ReactDOMOption generates a warning and hydration error when an invalid nested tag is used as a child" name="ReactDOMOption generates a warning and hydration error when an invalid nested tag is used as a child" time="0.064">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationClassContextType-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:24" time="4.096" tests="35">
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with context with server string render" name="ReactDOMServerIntegration class contextType renders class child with context with server string render" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with context with server stream render" name="ReactDOMServerIntegration class contextType renders class child with context with server stream render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with context with clean client render" name="ReactDOMServerIntegration class contextType renders class child with context with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with context with client render on top of good server markup" name="ReactDOMServerIntegration class contextType renders class child with context with client render on top of good server markup" time="0.205">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with context with client render on top of bad server markup" name="ReactDOMServerIntegration class contextType renders class child with context with client render on top of bad server markup" time="0.181">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child without context with server string render" name="ReactDOMServerIntegration class contextType renders class child without context with server string render" time="0.169">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child without context with server stream render" name="ReactDOMServerIntegration class contextType renders class child without context with server stream render" time="0.196">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child without context with clean client render" name="ReactDOMServerIntegration class contextType renders class child without context with clean client render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child without context with client render on top of good server markup" name="ReactDOMServerIntegration class contextType renders class child without context with client render on top of good server markup" time="0.177">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child without context with client render on top of bad server markup" name="ReactDOMServerIntegration class contextType renders class child without context with client render on top of bad server markup" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with wrong context with server string render" name="ReactDOMServerIntegration class contextType renders class child with wrong context with server string render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with wrong context with server stream render" name="ReactDOMServerIntegration class contextType renders class child with wrong context with server stream render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with wrong context with clean client render" name="ReactDOMServerIntegration class contextType renders class child with wrong context with clean client render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with wrong context with client render on top of good server markup" name="ReactDOMServerIntegration class contextType renders class child with wrong context with client render on top of good server markup" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders class child with wrong context with client render on top of bad server markup" name="ReactDOMServerIntegration class contextType renders class child with wrong context with client render on top of bad server markup" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with server string render" name="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with server string render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with server stream render" name="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with server stream render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with clean client render" name="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with clean client render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with client render on top of good server markup" name="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with client render on top of good server markup" time="0.117">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with client render on top of bad server markup" name="ReactDOMServerIntegration class contextType renders with context passed through to a grandchild with client render on top of bad server markup" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with server string render" name="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with server string render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with server stream render" name="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with server stream render" time="0.034">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with clean client render" name="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with clean client render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with client render on top of good server markup" name="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with client render on top of good server markup" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with client render on top of bad server markup" name="ReactDOMServerIntegration class contextType renders a child context overriding a parent context with client render on top of bad server markup" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders multiple contexts with server string render" name="ReactDOMServerIntegration class contextType renders multiple contexts with server string render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders multiple contexts with server stream render" name="ReactDOMServerIntegration class contextType renders multiple contexts with server stream render" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders multiple contexts with clean client render" name="ReactDOMServerIntegration class contextType renders multiple contexts with clean client render" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders multiple contexts with client render on top of good server markup" name="ReactDOMServerIntegration class contextType renders multiple contexts with client render on top of good server markup" time="0.268">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders multiple contexts with client render on top of bad server markup" name="ReactDOMServerIntegration class contextType renders multiple contexts with client render on top of bad server markup" time="0.144">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders nested context unwinding with server string render" name="ReactDOMServerIntegration class contextType renders nested context unwinding with server string render" time="0.16">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders nested context unwinding with server stream render" name="ReactDOMServerIntegration class contextType renders nested context unwinding with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders nested context unwinding with clean client render" name="ReactDOMServerIntegration class contextType renders nested context unwinding with clean client render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders nested context unwinding with client render on top of good server markup" name="ReactDOMServerIntegration class contextType renders nested context unwinding with client render on top of good server markup" time="0.133">
    </testcase>
    <testcase classname="ReactDOMServerIntegration class contextType renders nested context unwinding with client render on top of bad server markup" name="ReactDOMServerIntegration class contextType renders nested context unwinding with client render on top of bad server markup" time="0.074">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactEmptyComponent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:27" time="2.218" tests="24">
    <testcase classname="ReactEmptyComponent when null should not throw when rendering" name="ReactEmptyComponent when null should not throw when rendering" time="0.092">
    </testcase>
    <testcase classname="ReactEmptyComponent when null should not produce child DOM nodes for nullish and false" name="ReactEmptyComponent when null should not produce child DOM nodes for nullish and false" time="0.054">
    </testcase>
    <testcase classname="ReactEmptyComponent when null should be able to switch between rendering nullish and a normal tag" name="ReactEmptyComponent when null should be able to switch between rendering nullish and a normal tag" time="0.062">
    </testcase>
    <testcase classname="ReactEmptyComponent when null should be able to switch in a list of children" name="ReactEmptyComponent when null should be able to switch in a list of children" time="0.044">
    </testcase>
    <testcase classname="ReactEmptyComponent when null should distinguish between a script placeholder and an actual script tag" name="ReactEmptyComponent when null should distinguish between a script placeholder and an actual script tag" time="0.079">
    </testcase>
    <testcase classname="ReactEmptyComponent when null should have findDOMNode return null when multiple layers of composite components render to the same nullish placeholder" name="ReactEmptyComponent when null should have findDOMNode return null when multiple layers of composite components render to the same nullish placeholder" time="0.065">
    </testcase>
    <testcase classname="ReactEmptyComponent when null works when switching components" name="ReactEmptyComponent when null works when switching components" time="0.05">
    </testcase>
    <testcase classname="ReactEmptyComponent when null can render nullish at the top level" name="ReactEmptyComponent when null can render nullish at the top level" time="0.06">
    </testcase>
    <testcase classname="ReactEmptyComponent when null does not break when updating during mount" name="ReactEmptyComponent when null does not break when updating during mount" time="0.043">
    </testcase>
    <testcase classname="ReactEmptyComponent when null preserves the dom node during updates" name="ReactEmptyComponent when null preserves the dom node during updates" time="0.054">
    </testcase>
    <testcase classname="ReactEmptyComponent when null should not warn about React.forwardRef that returns nullish" name="ReactEmptyComponent when null should not warn about React.forwardRef that returns nullish" time="0.051">
    </testcase>
    <testcase classname="ReactEmptyComponent when null should not warn about React.memo that returns nullish" name="ReactEmptyComponent when null should not warn about React.memo that returns nullish" time="0.056">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined should not throw when rendering" name="ReactEmptyComponent when undefined should not throw when rendering" time="0.061">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined should not produce child DOM nodes for nullish and false" name="ReactEmptyComponent when undefined should not produce child DOM nodes for nullish and false" time="0.056">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined should be able to switch between rendering nullish and a normal tag" name="ReactEmptyComponent when undefined should be able to switch between rendering nullish and a normal tag" time="0.055">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined should be able to switch in a list of children" name="ReactEmptyComponent when undefined should be able to switch in a list of children" time="0.056">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined should distinguish between a script placeholder and an actual script tag" name="ReactEmptyComponent when undefined should distinguish between a script placeholder and an actual script tag" time="0.112">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined should have findDOMNode return null when multiple layers of composite components render to the same nullish placeholder" name="ReactEmptyComponent when undefined should have findDOMNode return null when multiple layers of composite components render to the same nullish placeholder" time="0.07">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined works when switching components" name="ReactEmptyComponent when undefined works when switching components" time="0.16">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined can render nullish at the top level" name="ReactEmptyComponent when undefined can render nullish at the top level" time="0.134">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined does not break when updating during mount" name="ReactEmptyComponent when undefined does not break when updating during mount" time="0.199">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined preserves the dom node during updates" name="ReactEmptyComponent when undefined preserves the dom node during updates" time="0.05">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined should not warn about React.forwardRef that returns nullish" name="ReactEmptyComponent when undefined should not warn about React.forwardRef that returns nullish" time="0.062">
    </testcase>
    <testcase classname="ReactEmptyComponent when undefined should not warn about React.memo that returns nullish" name="ReactEmptyComponent when undefined should not warn about React.memo that returns nullish" time="0.077">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/CSSPropertyOperations-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:28" time="0.628" tests="15">
    <testcase classname="CSSPropertyOperations should automatically append `px` to relevant styles" name="CSSPropertyOperations should automatically append `px` to relevant styles" time="0.011">
    </testcase>
    <testcase classname="CSSPropertyOperations should trim values" name="CSSPropertyOperations should trim values" time="0.001">
    </testcase>
    <testcase classname="CSSPropertyOperations should not append `px` to styles that might need a number" name="CSSPropertyOperations should not append `px` to styles that might need a number" time="0">
    </testcase>
    <testcase classname="CSSPropertyOperations should create vendor-prefixed markup correctly" name="CSSPropertyOperations should create vendor-prefixed markup correctly" time="0.001">
    </testcase>
    <testcase classname="CSSPropertyOperations should not hyphenate custom CSS property" name="CSSPropertyOperations should not hyphenate custom CSS property" time="0.001">
    </testcase>
    <testcase classname="CSSPropertyOperations should set style attribute when styles exist" name="CSSPropertyOperations should set style attribute when styles exist" time="0.013">
    </testcase>
    <testcase classname="CSSPropertyOperations should not set style attribute when no styles exist" name="CSSPropertyOperations should not set style attribute when no styles exist" time="0.001">
    </testcase>
    <testcase classname="CSSPropertyOperations should warn when using hyphenated style names" name="CSSPropertyOperations should warn when using hyphenated style names" time="0.009">
    </testcase>
    <testcase classname="CSSPropertyOperations should warn when updating hyphenated style names" name="CSSPropertyOperations should warn when updating hyphenated style names" time="0.035">
    </testcase>
    <testcase classname="CSSPropertyOperations warns when miscapitalizing vendored style names" name="CSSPropertyOperations warns when miscapitalizing vendored style names" time="0.009">
    </testcase>
    <testcase classname="CSSPropertyOperations should warn about style having a trailing semicolon" name="CSSPropertyOperations should warn about style having a trailing semicolon" time="0.004">
    </testcase>
    <testcase classname="CSSPropertyOperations should warn about style containing a NaN value" name="CSSPropertyOperations should warn about style containing a NaN value" time="0.037">
    </testcase>
    <testcase classname="CSSPropertyOperations should not warn when setting CSS custom properties" name="CSSPropertyOperations should not warn when setting CSS custom properties" time="0.004">
    </testcase>
    <testcase classname="CSSPropertyOperations should warn about style containing an Infinity value" name="CSSPropertyOperations should warn about style containing an Infinity value" time="0.007">
    </testcase>
    <testcase classname="CSSPropertyOperations should not add units to CSS custom properties" name="CSSPropertyOperations should not add units to CSS custom properties" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationSelect-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:23" time="6.721" tests="71">
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with server string render" name="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with server string render" time="0.113">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with server stream render" name="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with server stream render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with clean client render" name="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with clean client render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with client render on top of good server markup" time="0.244">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select with a value and an onChange with client render on top of bad server markup" time="0.18">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with server string render" name="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with server string render" time="0.16">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with server stream render" name="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with server stream render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with clean client render" name="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with client render on top of good server markup" time="0.147">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select with a value and readOnly with client render on top of bad server markup" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with server string render" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with server string render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with server stream render" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with server stream render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with clean client render" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with clean client render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with client render on top of good server markup" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and an onChange with client render on top of bad server markup" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with server string render" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with server string render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with server stream render" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with clean client render" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with client render on top of good server markup" time="0.119">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select with a multiple values and readOnly with client render on top of bad server markup" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with server string render" name="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with server string render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with server stream render" name="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with server stream render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with clean client render" name="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with clean client render" time="0.113">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with client render on top of good server markup" time="0.12">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select with a value and no onChange/readOnly with client render on top of bad server markup" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a defaultValue with server string render" name="ReactDOMServerIntegrationSelect renders a select with a defaultValue with server string render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a defaultValue with server stream render" name="ReactDOMServerIntegrationSelect renders a select with a defaultValue with server stream render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a defaultValue with clean client render" name="ReactDOMServerIntegrationSelect renders a select with a defaultValue with clean client render" time="0.095">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a defaultValue with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select with a defaultValue with client render on top of good server markup" time="0.262">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with a defaultValue with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select with a defaultValue with client render on top of bad server markup" time="0.175">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with server string render" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with server string render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with server stream render" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with server stream render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with clean client render" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with client render on top of good server markup" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue with client render on top of bad server markup" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with server string render" name="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with server string render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with server stream render" name="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with server stream render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with clean client render" name="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with clean client render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with client render on top of good server markup" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select with options that use dangerouslySetInnerHTML with client render on top of bad server markup" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and 0 as child with server string render" name="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and 0 as child with server string render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and 0 as child with clean client render" name="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and 0 as child with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and 0 as child with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and 0 as child with client render on top of bad server markup" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and empty string as child with server string render" name="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and empty string as child with server string render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and empty string as child with clean client render" name="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and empty string as child with clean client render" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and empty string as child with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect throws when rendering a select with option that uses dangerouslySetInnerHTML and empty string as child with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with server string render" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with server string render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with server stream render" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with server stream render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with clean client render" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with clean client render" time="0.153">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with client render on top of good server markup" time="0.251">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select value overriding defaultValue no matter the prop order with client render on top of bad server markup" time="0.166">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children with server string render" name="ReactDOMServerIntegrationSelect renders a select option with flattened children with server string render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children with server stream render" name="ReactDOMServerIntegrationSelect renders a select option with flattened children with server stream render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children with clean client render" name="ReactDOMServerIntegrationSelect renders a select option with flattened children with clean client render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select option with flattened children with client render on top of good server markup" time="0.118">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select option with flattened children with client render on top of bad server markup" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with server string render" name="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with server string render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with server stream render" name="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with server stream render" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with clean client render" name="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with clean client render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with client render on top of good server markup" time="0.117">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a select option with flattened children no value with client render on top of bad server markup" time="0.028">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with server string render" name="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with server string render" time="0.083">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with server stream render" name="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with server stream render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with clean client render" name="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with clean client render" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with client render on top of good server markup" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a boolean true select value match the string &quot;true&quot; with client render on top of bad server markup" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with server string render" name="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with server string render" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with server stream render" name="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with server stream render" time="0.094">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with clean client render" name="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with client render on top of good server markup" name="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with client render on top of good server markup" time="0.109">
    </testcase>
    <testcase classname="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with client render on top of bad server markup" name="ReactDOMServerIntegrationSelect renders a missing select value does not match the string &quot;undefined&quot; with client render on top of bad server markup" time="0.058">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactCompositeComponentState-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:29" time="0.591" tests="8">
    <testcase classname="ReactCompositeComponent-state should support setting state" name="ReactCompositeComponent-state should support setting state" time="0.1">
    </testcase>
    <testcase classname="ReactCompositeComponent-state should call componentDidUpdate of children first" name="ReactCompositeComponent-state should call componentDidUpdate of children first" time="0.016">
    </testcase>
    <testcase classname="ReactCompositeComponent-state should batch unmounts" name="ReactCompositeComponent-state should batch unmounts" time="0.004">
    </testcase>
    <testcase classname="ReactCompositeComponent-state should update state when called from child cWRP" name="ReactCompositeComponent-state should update state when called from child cWRP" time="0.004">
    </testcase>
    <testcase classname="ReactCompositeComponent-state should merge state when sCU returns false" name="ReactCompositeComponent-state should merge state when sCU returns false" time="0.023">
    </testcase>
    <testcase classname="ReactCompositeComponent-state should treat assigning to this.state inside cWRP as a replaceState, with a warning" name="ReactCompositeComponent-state should treat assigning to this.state inside cWRP as a replaceState, with a warning" time="0.005">
    </testcase>
    <testcase classname="ReactCompositeComponent-state should treat assigning to this.state inside cWM as a replaceState, with a warning" name="ReactCompositeComponent-state should treat assigning to this.state inside cWM as a replaceState, with a warning" time="0.003">
    </testcase>
    <testcase classname="ReactCompositeComponent-state should support setState in componentWillUnmount" name="ReactCompositeComponent-state should support setState in componentWillUnmount" time="0.018">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMUseId-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:24" time="6.472" tests="11">
    <testcase classname="useId basic example" name="useId basic example" time="0.634">
    </testcase>
    <testcase classname="useId indirections" name="useId indirections" time="0.382">
    </testcase>
    <testcase classname="useId StrictMode double rendering" name="useId StrictMode double rendering" time="0.385">
    </testcase>
    <testcase classname="useId empty (null) children" name="useId empty (null) children" time="0.795">
    </testcase>
    <testcase classname="useId large ids" name="useId large ids" time="0.497">
    </testcase>
    <testcase classname="useId multiple ids in a single component" name="useId multiple ids in a single component" time="0.344">
    </testcase>
    <testcase classname="useId local render phase updates" name="useId local render phase updates" time="0.403">
    </testcase>
    <testcase classname="useId basic incremental hydration" name="useId basic incremental hydration" time="0.384">
    </testcase>
    <testcase classname="useId inserting/deleting siblings outside a dehydrated Suspense boundary" name="useId inserting/deleting siblings outside a dehydrated Suspense boundary" time="0.459">
    </testcase>
    <testcase classname="useId inserting/deleting siblings inside a dehydrated Suspense boundary" name="useId inserting/deleting siblings inside a dehydrated Suspense boundary" time="0.804">
    </testcase>
    <testcase classname="useId identifierPrefix option" name="useId identifierPrefix option" time="0.379">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMFizzServer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:03" time="27.373" tests="45">
    <testcase classname="ReactDOMFizzServer should asynchronously load a lazy component" name="ReactDOMFizzServer should asynchronously load a lazy component" time="2.334">
    </testcase>
    <testcase classname="ReactDOMFizzServer #23331: does not warn about hydration mismatches if something suspended in an earlier sibling" name="ReactDOMFizzServer #23331: does not warn about hydration mismatches if something suspended in an earlier sibling" time="1.112">
    </testcase>
    <testcase classname="ReactDOMFizzServer should support nonce scripts" name="ReactDOMFizzServer should support nonce scripts" time="0.542">
    </testcase>
    <testcase classname="ReactDOMFizzServer should client render a boundary if a lazy component rejects" name="ReactDOMFizzServer should client render a boundary if a lazy component rejects" time="1.045">
    </testcase>
    <testcase classname="ReactDOMFizzServer should asynchronously load a lazy element" name="ReactDOMFizzServer should asynchronously load a lazy element" time="0.502">
    </testcase>
    <testcase classname="ReactDOMFizzServer should client render a boundary if a lazy element rejects" name="ReactDOMFizzServer should client render a boundary if a lazy element rejects" time="0.444">
    </testcase>
    <testcase classname="ReactDOMFizzServer should asynchronously load the suspense boundary" name="ReactDOMFizzServer should asynchronously load the suspense boundary" time="0.378">
    </testcase>
    <testcase classname="ReactDOMFizzServer waits for pending content to come in from the server and then hydrates it" name="ReactDOMFizzServer waits for pending content to come in from the server and then hydrates it" time="0.455">
    </testcase>
    <testcase classname="ReactDOMFizzServer handles an error on the client if the server ends up erroring" name="ReactDOMFizzServer handles an error on the client if the server ends up erroring" time="0.883">
    </testcase>
    <testcase classname="ReactDOMFizzServer shows inserted items before pending in a SuspenseList as fallbacks while hydrating" name="ReactDOMFizzServer shows inserted items before pending in a SuspenseList as fallbacks while hydrating" time="0.392">
    </testcase>
    <testcase classname="ReactDOMFizzServer client renders a boundary if it does not resolve before aborting" name="ReactDOMFizzServer client renders a boundary if it does not resolve before aborting" time="0.36">
    </testcase>
    <testcase classname="ReactDOMFizzServer should allow for two containers to be written to the same document" name="ReactDOMFizzServer should allow for two containers to be written to the same document" time="0.402">
    </testcase>
    <testcase classname="ReactDOMFizzServer can resolve async content in esoteric parents" name="ReactDOMFizzServer can resolve async content in esoteric parents" time="0.438">
    </testcase>
    <testcase classname="ReactDOMFizzServer can resolve async content in table parents" name="ReactDOMFizzServer can resolve async content in table parents" time="0.405">
    </testcase>
    <testcase classname="ReactDOMFizzServer can stream into an SVG container" name="ReactDOMFizzServer can stream into an SVG container" time="0.937">
    </testcase>
    <testcase classname="ReactDOMFizzServer should include a component stack across suspended boundaries" name="ReactDOMFizzServer should include a component stack across suspended boundaries" time="0.366">
    </testcase>
    <testcase classname="ReactDOMFizzServer should can suspend in a class component with legacy context" name="ReactDOMFizzServer should can suspend in a class component with legacy context" time="0.359">
    </testcase>
    <testcase classname="ReactDOMFizzServer should resume the context from where it left off" name="ReactDOMFizzServer should resume the context from where it left off" time="0.352">
    </testcase>
    <testcase classname="ReactDOMFizzServer should recover the outer context when an error happens inside a provider" name="ReactDOMFizzServer should recover the outer context when an error happens inside a provider" time="0.363">
    </testcase>
    <testcase classname="ReactDOMFizzServer client renders a boundary if it errors before finishing the fallback" name="ReactDOMFizzServer client renders a boundary if it errors before finishing the fallback" time="0.377">
    </testcase>
    <testcase classname="ReactDOMFizzServer should be able to abort the fallback if the main content finishes first" name="ReactDOMFizzServer should be able to abort the fallback if the main content finishes first" time="0.363">
    </testcase>
    <testcase classname="ReactDOMFizzServer [GATED, SHOULD FAIL] should respect unstable_avoidThisFallback" name="ReactDOMFizzServer [GATED, SHOULD FAIL] should respect unstable_avoidThisFallback" time="0.983">
    </testcase>
    <testcase classname="ReactDOMFizzServer calls getServerSnapshot instead of getSnapshot" name="ReactDOMFizzServer calls getServerSnapshot instead of getSnapshot" time="0.656">
    </testcase>
    <testcase classname="ReactDOMFizzServer calls getServerSnapshot instead of getSnapshot (with selector and isEqual)" name="ReactDOMFizzServer calls getServerSnapshot instead of getSnapshot (with selector and isEqual)" time="0.396">
    </testcase>
    <testcase classname="ReactDOMFizzServer errors during hydration in the shell force a client render at the root, and during the client render it recovers" name="ReactDOMFizzServer errors during hydration in the shell force a client render at the root, and during the client render it recovers" time="0.373">
    </testcase>
    <testcase classname="ReactDOMFizzServer errors during hydration force a client render at the nearest Suspense boundary, and during the client render it recovers" name="ReactDOMFizzServer errors during hydration force a client render at the nearest Suspense boundary, and during the client render it recovers" time="0.421">
    </testcase>
    <testcase classname="ReactDOMFizzServer errors during hydration force a client render at the nearest Suspense boundary, and during the client render it fails again" name="ReactDOMFizzServer errors during hydration force a client render at the nearest Suspense boundary, and during the client render it fails again" time="0.38">
    </testcase>
    <testcase classname="ReactDOMFizzServer [GATED, SHOULD FAIL] does not recreate the fallback if server errors and hydration suspends" name="ReactDOMFizzServer [GATED, SHOULD FAIL] does not recreate the fallback if server errors and hydration suspends" time="0.464">
    </testcase>
    <testcase classname="ReactDOMFizzServer [GATED, SHOULD FAIL] does not recreate the fallback if server errors and hydration suspends and root receives a transition" name="ReactDOMFizzServer [GATED, SHOULD FAIL] does not recreate the fallback if server errors and hydration suspends and root receives a transition" time="0.925">
    </testcase>
    <testcase classname="ReactDOMFizzServer [GATED, SHOULD FAIL] recreates the fallback if server errors and hydration suspends but client receives new props" name="ReactDOMFizzServer [GATED, SHOULD FAIL] recreates the fallback if server errors and hydration suspends but client receives new props" time="0.69">
    </testcase>
    <testcase classname="ReactDOMFizzServer errors during hydration force a client render at the nearest Suspense boundary, and during the client render it recovers, then a deeper child suspends" name="ReactDOMFizzServer errors during hydration force a client render at the nearest Suspense boundary, and during the client render it recovers, then a deeper child suspends" time="0.393">
    </testcase>
    <testcase classname="ReactDOMFizzServer logs regular (non-hydration) errors when the UI recovers" name="ReactDOMFizzServer logs regular (non-hydration) errors when the UI recovers" time="0.391">
    </testcase>
    <testcase classname="ReactDOMFizzServer logs multiple hydration errors in the same render" name="ReactDOMFizzServer logs multiple hydration errors in the same render" time="0.384">
    </testcase>
    <testcase classname="ReactDOMFizzServer supports ServerContext" name="ReactDOMFizzServer supports ServerContext" time="0.418">
    </testcase>
    <testcase classname="ReactDOMFizzServer Supports iterable" name="ReactDOMFizzServer Supports iterable" time="0.399">
    </testcase>
    <testcase classname="ReactDOMFizzServer bootstrapScriptContent escaping the &quot;S&quot; in &quot;&lt;/?[Ss]cript&quot; strings are replaced with unicode escaped lowercase s or S depending on case, preserving case sensitivity of nearby characters" name="ReactDOMFizzServer bootstrapScriptContent escaping the &quot;S&quot; in &quot;&lt;/?[Ss]cript&quot; strings are replaced with unicode escaped lowercase s or S depending on case, preserving case sensitivity of nearby characters" time="0.356">
    </testcase>
    <testcase classname="ReactDOMFizzServer bootstrapScriptContent escaping does not escape \u2028, or \u2029 characters" name="ReactDOMFizzServer bootstrapScriptContent escaping does not escape \u2028, or \u2029 characters" time="0.788">
    </testcase>
    <testcase classname="ReactDOMFizzServer bootstrapScriptContent escaping does not escape &lt;, &gt;, or &amp; characters" name="ReactDOMFizzServer bootstrapScriptContent escaping does not escape &lt;, &gt;, or &amp; characters" time="0.873">
    </testcase>
    <testcase classname="ReactDOMFizzServer #24384: Suspending should halt hydration warnings and not emit any if hydration completes successfully after unsuspending" name="ReactDOMFizzServer #24384: Suspending should halt hydration warnings and not emit any if hydration completes successfully after unsuspending" time="0.391">
    </testcase>
    <testcase classname="ReactDOMFizzServer #24384: Suspending should halt hydration warnings but still emit hydration warnings after unsuspending if mismatches are genuine" name="ReactDOMFizzServer #24384: Suspending should halt hydration warnings but still emit hydration warnings after unsuspending if mismatches are genuine" time="0.385">
    </testcase>
    <testcase classname="ReactDOMFizzServer only warns once on hydration mismatch while within a suspense boundary" name="ReactDOMFizzServer only warns once on hydration mismatch while within a suspense boundary" time="0.414">
    </testcase>
    <testcase classname="ReactDOMFizzServer supresses hydration warnings when an error occurs within a Suspense boundary" name="ReactDOMFizzServer supresses hydration warnings when an error occurs within a Suspense boundary" time="0.39">
    </testcase>
    <testcase classname="ReactDOMFizzServer does not invokeGuardedCallback for errors after the first hydration error" name="ReactDOMFizzServer does not invokeGuardedCallback for errors after the first hydration error" time="0.344">
    </testcase>
    <testcase classname="ReactDOMFizzServer does not invokeGuardedCallback for errors after a preceding fiber suspends" name="ReactDOMFizzServer does not invokeGuardedCallback for errors after a preceding fiber suspends" time="0.374">
    </testcase>
    <testcase classname="ReactDOMFizzServer suspending after erroring will cause errors previously queued to be silenced until the boundary resolves" name="ReactDOMFizzServer suspending after erroring will cause errors previously queued to be silenced until the boundary resolves" time="0.352">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMTextComponent-test.js" errors="0" failures="0" skipped="5" timestamp="2022-08-05T04:12:31" time="0.537" tests="9">
    <testcase classname="ReactDOMTextComponent updates a mounted text component in place" name="ReactDOMTextComponent updates a mounted text component in place" time="0.084">
    </testcase>
    <testcase classname="ReactDOMTextComponent can be toggled in and out of the markup" name="ReactDOMTextComponent can be toggled in and out of the markup" time="0.008">
    </testcase>
    <testcase classname="ReactDOMTextComponent can reconcile text merged by Node.normalize() alongside other elements" name="ReactDOMTextComponent can reconcile text merged by Node.normalize() alongside other elements" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMTextComponent can reconcile text merged by Node.normalize()" name="ReactDOMTextComponent can reconcile text merged by Node.normalize()" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMTextComponent can reconcile text from pre-rendered markup" name="ReactDOMTextComponent can reconcile text from pre-rendered markup" time="0.043">
    </testcase>
    <testcase classname="ReactDOMTextComponent can reconcile text arbitrarily split into multiple nodes" name="ReactDOMTextComponent can reconcile text arbitrarily split into multiple nodes" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMTextComponent can reconcile text arbitrarily split into multiple nodes on some substitutions only" name="ReactDOMTextComponent can reconcile text arbitrarily split into multiple nodes on some substitutions only" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMTextComponent can unmount normalized text nodes" name="ReactDOMTextComponent can unmount normalized text nodes" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMTextComponent throws for Temporal-like text nodes" name="ReactDOMTextComponent throws for Temporal-like text nodes" time="0.016">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactMount-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:29" time="1.912" tests="17">
    <testcase classname="ReactMount unmountComponentAtNode throws when given a non-node" name="ReactMount unmountComponentAtNode throws when given a non-node" time="0.086">
    </testcase>
    <testcase classname="ReactMount unmountComponentAtNode returns false on non-React containers" name="ReactMount unmountComponentAtNode returns false on non-React containers" time="0.048">
    </testcase>
    <testcase classname="ReactMount unmountComponentAtNode returns true on React containers" name="ReactMount unmountComponentAtNode returns true on React containers" time="0.055">
    </testcase>
    <testcase classname="ReactMount warns when given a factory" name="ReactMount warns when given a factory" time="0.047">
    </testcase>
    <testcase classname="ReactMount should render different components in same root" name="ReactMount should render different components in same root" time="0.061">
    </testcase>
    <testcase classname="ReactMount should unmount and remount if the key changes" name="ReactMount should unmount and remount if the key changes" time="0.05">
    </testcase>
    <testcase classname="ReactMount should reuse markup if rendering to the same target twice" name="ReactMount should reuse markup if rendering to the same target twice" time="0.059">
    </testcase>
    <testcase classname="ReactMount does not warn if mounting into left padded rendered markup" name="ReactMount does not warn if mounting into left padded rendered markup" time="0.047">
    </testcase>
    <testcase classname="ReactMount should warn if mounting into right padded rendered markup" name="ReactMount should warn if mounting into right padded rendered markup" time="0.095">
    </testcase>
    <testcase classname="ReactMount should not warn if mounting into non-empty node" name="ReactMount should not warn if mounting into non-empty node" time="0.038">
    </testcase>
    <testcase classname="ReactMount should warn when mounting into document.body" name="ReactMount should warn when mounting into document.body" time="0.129">
    </testcase>
    <testcase classname="ReactMount should account for escaping on a checksum mismatch" name="ReactMount should account for escaping on a checksum mismatch" time="0.146">
    </testcase>
    <testcase classname="ReactMount should warn if render removes React-rendered children" name="ReactMount should warn if render removes React-rendered children" time="0.205">
    </testcase>
    <testcase classname="ReactMount should warn if the unmounted node was rendered by another copy of React" name="ReactMount should warn if the unmounted node was rendered by another copy of React" time="0.15">
    </testcase>
    <testcase classname="ReactMount passes the correct callback context" name="ReactMount passes the correct callback context" time="0.141">
    </testcase>
    <testcase classname="ReactMount initial mount of legacy root is sync inside batchedUpdates, as if it were wrapped in flushSync" name="ReactMount initial mount of legacy root is sync inside batchedUpdates, as if it were wrapped in flushSync" time="0.053">
    </testcase>
    <testcase classname="ReactMount mount point is a comment node renders at a comment node" name="ReactMount mount point is a comment node renders at a comment node" time="0.089">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerLifecycles-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:31" time="0.962" tests="12">
    <testcase classname="ReactDOMServerLifecycles should invoke the correct legacy lifecycle hooks" name="ReactDOMServerLifecycles should invoke the correct legacy lifecycle hooks" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles should invoke the correct new lifecycle hooks" name="ReactDOMServerLifecycles should invoke the correct new lifecycle hooks" time="0.011">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles should not invoke unsafe cWM if static gDSFP is present" name="ReactDOMServerLifecycles should not invoke unsafe cWM if static gDSFP is present" time="0.032">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles should update instance.state with value returned from getDerivedStateFromProps" name="ReactDOMServerLifecycles should update instance.state with value returned from getDerivedStateFromProps" time="0.021">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles should warn if getDerivedStateFromProps returns undefined" name="ReactDOMServerLifecycles should warn if getDerivedStateFromProps returns undefined" time="0.024">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles should warn if state is not initialized before getDerivedStateFromProps" name="ReactDOMServerLifecycles should warn if state is not initialized before getDerivedStateFromProps" time="0.017">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles should invoke both deprecated and new lifecycles if both are present" name="ReactDOMServerLifecycles should invoke both deprecated and new lifecycles if both are present" time="0.03">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles tracks state updates across components" name="ReactDOMServerLifecycles tracks state updates across components" time="0.033">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles should not invoke cWM if static gDSFP is present" name="ReactDOMServerLifecycles should not invoke cWM if static gDSFP is present" time="0.027">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles should warn about deprecated lifecycle hooks" name="ReactDOMServerLifecycles should warn about deprecated lifecycle hooks" time="0.023">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles react-lifecycles-compat should not warn for components with polyfilled getDerivedStateFromProps" name="ReactDOMServerLifecycles react-lifecycles-compat should not warn for components with polyfilled getDerivedStateFromProps" time="0.018">
    </testcase>
    <testcase classname="ReactDOMServerLifecycles react-lifecycles-compat should not warn for components with polyfilled getSnapshotBeforeUpdate" name="ReactDOMServerLifecycles react-lifecycles-compat should not warn for components with polyfilled getSnapshotBeforeUpdate" time="0.014">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMSVG-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:32" time="0.661" tests="5">
    <testcase classname="ReactDOMSVG creates initial namespaced markup" name="ReactDOMSVG creates initial namespaced markup" time="0.131">
    </testcase>
    <testcase classname="ReactDOMSVG creates elements with SVG namespace inside SVG tag during mount" name="ReactDOMSVG creates elements with SVG namespace inside SVG tag during mount" time="0.019">
    </testcase>
    <testcase classname="ReactDOMSVG creates elements with SVG namespace inside SVG tag during update" name="ReactDOMSVG creates elements with SVG namespace inside SVG tag during update" time="0.006">
    </testcase>
    <testcase classname="ReactDOMSVG can render SVG into a non-React SVG tree" name="ReactDOMSVG can render SVG into a non-React SVG tree" time="0.007">
    </testcase>
    <testcase classname="ReactDOMSVG can render HTML into a foreignObject in non-React SVG tree" name="ReactDOMSVG can render HTML into a foreignObject in non-React SVG tree" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMSuspensePlaceholder-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:32" time="1.301" tests="5">
    <testcase classname="ReactDOMSuspensePlaceholder hides and unhides timed out DOM elements" name="ReactDOMSuspensePlaceholder hides and unhides timed out DOM elements" time="0.276">
    </testcase>
    <testcase classname="ReactDOMSuspensePlaceholder hides and unhides timed out text nodes" name="ReactDOMSuspensePlaceholder hides and unhides timed out text nodes" time="0.039">
    </testcase>
    <testcase classname="ReactDOMSuspensePlaceholder outside concurrent mode, re-hides children if their display is updated but the boundary is still showing the fallback" name="ReactDOMSuspensePlaceholder outside concurrent mode, re-hides children if their display is updated but the boundary is still showing the fallback" time="0.094">
    </testcase>
    <testcase classname="ReactDOMSuspensePlaceholder can call findDOMNode() in a suspended component commit phase" name="ReactDOMSuspensePlaceholder can call findDOMNode() in a suspended component commit phase" time="0.099">
    </testcase>
    <testcase classname="ReactDOMSuspensePlaceholder can call findDOMNode() in a suspended component commit phase (#2)" name="ReactDOMSuspensePlaceholder can call findDOMNode() in a suspended component commit phase (#2)" time="0.072">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMImageLoad-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:33" time="1.282" tests="8">
    <testcase classname="ReactDOMImageLoad captures the load event if it happens before commit phase and replays it between layout and passive effects" name="ReactDOMImageLoad captures the load event if it happens before commit phase and replays it between layout and passive effects" time="0.143">
    </testcase>
    <testcase classname="ReactDOMImageLoad captures the load event if it happens after commit phase and replays it" name="ReactDOMImageLoad captures the load event if it happens after commit phase and replays it" time="0.099">
    </testcase>
    <testcase classname="ReactDOMImageLoad it replays the last load event when more than one fire before the end of the layout phase completes" name="ReactDOMImageLoad it replays the last load event when more than one fire before the end of the layout phase completes" time="0.049">
    </testcase>
    <testcase classname="ReactDOMImageLoad replays load events that happen in passive phase after the passive phase." name="ReactDOMImageLoad replays load events that happen in passive phase after the passive phase." time="0.083">
    </testcase>
    <testcase classname="ReactDOMImageLoad captures and suppresses the load event if it happens before passive effects and a cascading update causes the img to be removed" name="ReactDOMImageLoad captures and suppresses the load event if it happens before passive effects and a cascading update causes the img to be removed" time="0.048">
    </testcase>
    <testcase classname="ReactDOMImageLoad captures and suppresses the load event if it happens before passive effects and a cascading update causes the img to be removed, alternate" name="ReactDOMImageLoad captures and suppresses the load event if it happens before passive effects and a cascading update causes the img to be removed, alternate" time="0.106">
    </testcase>
    <testcase classname="ReactDOMImageLoad correctly replays the last img load even when a yield + update causes the host element to change" name="ReactDOMImageLoad correctly replays the last img load even when a yield + update causes the host element to change" time="0.059">
    </testcase>
    <testcase classname="ReactDOMImageLoad preserves the src property / attribute when triggering a potential new load event" name="ReactDOMImageLoad preserves the src property / attribute when triggering a potential new load event" time="0.099">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMFizzServerBrowser-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:33" time="0.995" tests="10">
    <testcase classname="ReactDOMFizzServer should call renderToReadableStream" name="ReactDOMFizzServer should call renderToReadableStream" time="0.21">
    </testcase>
    <testcase classname="ReactDOMFizzServer should emit DOCTYPE at the root of the document" name="ReactDOMFizzServer should emit DOCTYPE at the root of the document" time="0.03">
    </testcase>
    <testcase classname="ReactDOMFizzServer should emit bootstrap script src at the end" name="ReactDOMFizzServer should emit bootstrap script src at the end" time="0.054">
    </testcase>
    <testcase classname="ReactDOMFizzServer emits all HTML as one unit if we wait until the end to start" name="ReactDOMFizzServer emits all HTML as one unit if we wait until the end to start" time="0.021">
    </testcase>
    <testcase classname="ReactDOMFizzServer should reject the promise when an error is thrown at the root" name="ReactDOMFizzServer should reject the promise when an error is thrown at the root" time="0.014">
    </testcase>
    <testcase classname="ReactDOMFizzServer should reject the promise when an error is thrown inside a fallback" name="ReactDOMFizzServer should reject the promise when an error is thrown inside a fallback" time="0.013">
    </testcase>
    <testcase classname="ReactDOMFizzServer should not error the stream when an error is thrown inside suspense boundary" name="ReactDOMFizzServer should not error the stream when an error is thrown inside suspense boundary" time="0.062">
    </testcase>
    <testcase classname="ReactDOMFizzServer should be able to complete by aborting even if the promise never resolves" name="ReactDOMFizzServer should be able to complete by aborting even if the promise never resolves" time="0.014">
    </testcase>
    <testcase classname="ReactDOMFizzServer should not continue rendering after the reader cancels" name="ReactDOMFizzServer should not continue rendering after the reader cancels" time="0.027">
    </testcase>
    <testcase classname="ReactDOMFizzServer should stream large contents that might overlow individual buffers" name="ReactDOMFizzServer should stream large contents that might overlow individual buffers" time="0.018">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationAttributes-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:26" time="8.624" tests="95">
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with server string render" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with server string render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with server stream render" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with server stream render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with clean client render" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with clean client render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with client render on top of good server markup" time="0.097">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple numbers with client render on top of bad server markup" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with server string render" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with server string render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with server stream render" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with server stream render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with clean client render" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with clean client render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with client render on top of good server markup" time="0.117">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders simple strings with client render on top of bad server markup" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with server string render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with server string render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with server stream render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with server stream render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with clean client render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with clean client render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with client render on top of good server markup" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with true value with client render on top of bad server markup" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with server string render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with server string render" time="0.095">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with server stream render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with server stream render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with clean client render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with clean client render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with client render on top of good server markup" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with false value with client render on top of bad server markup" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with server string render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with server string render" time="0.095">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with server stream render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with server stream render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with clean client render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with clean client render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with client render on top of good server markup" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with null value with client render on top of bad server markup" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with server string render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with server string render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with server stream render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with server stream render" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with clean client render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with clean client render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with client render on top of good server markup" time="0.102">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with function value with client render on top of bad server markup" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with server string render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with server string render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with server stream render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with server stream render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with clean client render" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with clean client render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with client render on top of good server markup" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping string properties renders no string prop with symbol value with client render on top of bad server markup" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with server string render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with server stream render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with clean client render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with client render on top of good server markup" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with true value with client render on top of bad server markup" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with server string render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with server stream render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with client render on top of good server markup" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with false value with client render on top of bad server markup" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with server string render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with clean client render" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with client render on top of good server markup" time="0.118">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with self value with client render on top of bad server markup" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with server string render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with server stream render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with clean client render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with client render on top of good server markup" time="0.135">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with &quot;&quot; value with client render on top of bad server markup" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with server string render" time="0.092">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with server stream render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with clean client render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with client render on top of good server markup" time="0.098">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with string value with client render on top of bad server markup" time="0.034">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with server string render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with server stream render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with clean client render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with client render on top of good server markup" time="0.107">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with array value with client render on top of bad server markup" time="0.087">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with server string render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with server stream render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with clean client render" time="0.128">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with client render on top of good server markup" time="0.234">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with object value with client render on top of bad server markup" time="0.204">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with server string render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with server stream render" time="0.177">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with client render on top of good server markup" time="0.149">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with non-zero number value with client render on top of bad server markup" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with server string render" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with server stream render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with clean client render" time="0.132">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with client render on top of good server markup" time="0.379">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders boolean prop with zero value with client render on top of bad server markup" time="0.16">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with server string render" time="0.165">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with server stream render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with clean client render" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with client render on top of good server markup" time="0.119">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with null value with client render on top of bad server markup" time="0.124">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with server string render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with client render on top of good server markup" time="0.132">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with function value with client render on top of bad server markup" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with server string render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with server string render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with server stream render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with server stream render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with clean client render" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with clean client render" time="0.04">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with client render on top of good server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with client render on top of good server markup" time="0.143">
    </testcase>
    <testcase classname="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with client render on top of bad server markup" name="ReactDOMServerIntegration property to attribute mapping boolean properties renders no boolean prop with symbol value with client render on top of bad server markup" time="0.124">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMConsoleErrorReporting-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:31" time="3.919" tests="14">
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs errors during event handlers" name="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs errors during event handlers" time="0.123">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs render errors without an error boundary" name="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs render errors without an error boundary" time="0.077">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs render errors with an error boundary" name="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs render errors with an error boundary" time="0.094">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs layout effect errors without an error boundary" name="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs layout effect errors without an error boundary" time="0.062">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs layout effect errors with an error boundary" name="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs layout effect errors with an error boundary" time="0.061">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs passive effect errors without an error boundary" name="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs passive effect errors without an error boundary" time="0.059">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs passive effect errors with an error boundary" name="ReactDOMConsoleErrorReporting ReactDOMClient.createRoot logs passive effect errors with an error boundary" time="0.081">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOM.render logs errors during event handlers" name="ReactDOMConsoleErrorReporting ReactDOM.render logs errors during event handlers" time="0.107">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOM.render logs render errors without an error boundary" name="ReactDOMConsoleErrorReporting ReactDOM.render logs render errors without an error boundary" time="0.127">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOM.render logs render errors with an error boundary" name="ReactDOMConsoleErrorReporting ReactDOM.render logs render errors with an error boundary" time="0.081">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOM.render logs layout effect errors without an error boundary" name="ReactDOMConsoleErrorReporting ReactDOM.render logs layout effect errors without an error boundary" time="0.059">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOM.render logs layout effect errors with an error boundary" name="ReactDOMConsoleErrorReporting ReactDOM.render logs layout effect errors with an error boundary" time="0.063">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOM.render logs passive effect errors without an error boundary" name="ReactDOMConsoleErrorReporting ReactDOM.render logs passive effect errors without an error boundary" time="0.061">
    </testcase>
    <testcase classname="ReactDOMConsoleErrorReporting ReactDOM.render logs passive effect errors with an error boundary" name="ReactDOMConsoleErrorReporting ReactDOM.render logs passive effect errors with an error boundary" time="0.068">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactMountDestruction-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:34" time="0.95" tests="3">
    <testcase classname="ReactMount should destroy a react root upon request" name="ReactMount should destroy a react root upon request" time="0.05">
    </testcase>
    <testcase classname="ReactMount should warn when unmounting a non-container root node" name="ReactMount should warn when unmounting a non-container root node" time="0.005">
    </testcase>
    <testcase classname="ReactMount should warn when unmounting a non-container, non-root node" name="ReactMount should warn when unmounting a non-container, non-root node" time="0.012">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationCheckbox-test.js" errors="0" failures="0" skipped="30" timestamp="2022-08-05T04:12:35" time="0.508" tests="30">
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with server string render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with server stream render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with clean client render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with client render on top of good server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with client render on top of bad server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with an onChange with client render on top of bad server markup" time="0.001">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with server string render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with server stream render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with clean client render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked with readOnly with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with server string render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with server stream render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with clean client render" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with client render on top of good server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with client render on top of bad server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox that is checked and no onChange/readOnly with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with server string render" name="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with server stream render" name="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with clean client render" name="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with client render on top of good server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with client render on top of bad server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox with defaultChecked with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with server string render" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with server stream render" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with clean client render" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with client render on top of good server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with client render on top of bad server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with server string render" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with server string render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with server stream render" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with server stream render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with clean client render" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with clean client render" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with client render on top of good server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with client render on top of good server markup" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with client render on top of bad server markup" name="ReactDOMServerIntegrationCheckbox renders a checkbox checked overriding defaultChecked no matter the prop order with client render on top of bad server markup" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMHooks-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:35" time="1.086" tests="3">
    <testcase classname="ReactDOMHooks can ReactDOM.render() from useEffect" name="ReactDOMHooks can ReactDOM.render() from useEffect" time="0.292">
    </testcase>
    <testcase classname="ReactDOMHooks should not bail out when an update is scheduled from within an event handler" name="ReactDOMHooks should not bail out when an update is scheduled from within an event handler" time="0.068">
    </testcase>
    <testcase classname="ReactDOMHooks should not bail out when an update is scheduled from within an event handler in Concurrent Mode" name="ReactDOMHooks should not bail out when an update is scheduled from within an event handler in Concurrent Mode" time="0.043">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactErrorBoundaries-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:30" time="6.668" tests="50">
    <testcase classname="ReactErrorBoundaries does not swallow exceptions on mounting without boundaries" name="ReactErrorBoundaries does not swallow exceptions on mounting without boundaries" time="0.14">
    </testcase>
    <testcase classname="ReactErrorBoundaries does not swallow exceptions on updating without boundaries" name="ReactErrorBoundaries does not swallow exceptions on updating without boundaries" time="0.09">
    </testcase>
    <testcase classname="ReactErrorBoundaries does not swallow exceptions on unmounting without boundaries" name="ReactErrorBoundaries does not swallow exceptions on unmounting without boundaries" time="0.064">
    </testcase>
    <testcase classname="ReactErrorBoundaries prevents errors from leaking into other roots" name="ReactErrorBoundaries prevents errors from leaking into other roots" time="0.077">
    </testcase>
    <testcase classname="ReactErrorBoundaries logs a single error when using error boundary" name="ReactErrorBoundaries logs a single error when using error boundary" time="0.113">
    </testcase>
    <testcase classname="ReactErrorBoundaries renders an error state if child throws in render" name="ReactErrorBoundaries renders an error state if child throws in render" time="0.111">
    </testcase>
    <testcase classname="ReactErrorBoundaries renders an error state if child throws in constructor" name="ReactErrorBoundaries renders an error state if child throws in constructor" time="0.049">
    </testcase>
    <testcase classname="ReactErrorBoundaries renders an error state if child throws in componentWillMount" name="ReactErrorBoundaries renders an error state if child throws in componentWillMount" time="0.076">
    </testcase>
    <testcase classname="ReactErrorBoundaries renders an error state if context provider throws in componentWillMount" name="ReactErrorBoundaries renders an error state if context provider throws in componentWillMount" time="0.069">
    </testcase>
    <testcase classname="ReactErrorBoundaries mounts the error message if mounting fails" name="ReactErrorBoundaries mounts the error message if mounting fails" time="0.069">
    </testcase>
    <testcase classname="ReactErrorBoundaries propagates errors on retry on mounting" name="ReactErrorBoundaries propagates errors on retry on mounting" time="0.078">
    </testcase>
    <testcase classname="ReactErrorBoundaries propagates errors inside boundary during componentWillMount" name="ReactErrorBoundaries propagates errors inside boundary during componentWillMount" time="0.1">
    </testcase>
    <testcase classname="ReactErrorBoundaries propagates errors inside boundary while rendering error state" name="ReactErrorBoundaries propagates errors inside boundary while rendering error state" time="0.159">
    </testcase>
    <testcase classname="ReactErrorBoundaries does not call componentWillUnmount when aborting initial mount" name="ReactErrorBoundaries does not call componentWillUnmount when aborting initial mount" time="0.23">
    </testcase>
    <testcase classname="ReactErrorBoundaries resets callback refs if mounting aborts" name="ReactErrorBoundaries resets callback refs if mounting aborts" time="0.228">
    </testcase>
    <testcase classname="ReactErrorBoundaries resets object refs if mounting aborts" name="ReactErrorBoundaries resets object refs if mounting aborts" time="0.071">
    </testcase>
    <testcase classname="ReactErrorBoundaries successfully mounts if no error occurs" name="ReactErrorBoundaries successfully mounts if no error occurs" time="0.057">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches if child throws in constructor during update" name="ReactErrorBoundaries catches if child throws in constructor during update" time="0.099">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches if child throws in componentWillMount during update" name="ReactErrorBoundaries catches if child throws in componentWillMount during update" time="0.083">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches if child throws in componentWillReceiveProps during update" name="ReactErrorBoundaries catches if child throws in componentWillReceiveProps during update" time="0.062">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches if child throws in componentWillUpdate during update" name="ReactErrorBoundaries catches if child throws in componentWillUpdate during update" time="0.088">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches if child throws in render during update" name="ReactErrorBoundaries catches if child throws in render during update" time="0.083">
    </testcase>
    <testcase classname="ReactErrorBoundaries keeps refs up-to-date during updates" name="ReactErrorBoundaries keeps refs up-to-date during updates" time="0.051">
    </testcase>
    <testcase classname="ReactErrorBoundaries recovers from componentWillUnmount errors on update" name="ReactErrorBoundaries recovers from componentWillUnmount errors on update" time="0.125">
    </testcase>
    <testcase classname="ReactErrorBoundaries recovers from nested componentWillUnmount errors on update" name="ReactErrorBoundaries recovers from nested componentWillUnmount errors on update" time="0.084">
    </testcase>
    <testcase classname="ReactErrorBoundaries picks the right boundary when handling unmounting errors" name="ReactErrorBoundaries picks the right boundary when handling unmounting errors" time="0.091">
    </testcase>
    <testcase classname="ReactErrorBoundaries can recover from error state" name="ReactErrorBoundaries can recover from error state" time="0.05">
    </testcase>
    <testcase classname="ReactErrorBoundaries can update multiple times in error state" name="ReactErrorBoundaries can update multiple times in error state" time="0.06">
    </testcase>
    <testcase classname="ReactErrorBoundaries doesn&apos;t get into inconsistent state during removals" name="ReactErrorBoundaries doesn&apos;t get into inconsistent state during removals" time="0.068">
    </testcase>
    <testcase classname="ReactErrorBoundaries doesn&apos;t get into inconsistent state during additions" name="ReactErrorBoundaries doesn&apos;t get into inconsistent state during additions" time="0.073">
    </testcase>
    <testcase classname="ReactErrorBoundaries doesn&apos;t get into inconsistent state during reorders" name="ReactErrorBoundaries doesn&apos;t get into inconsistent state during reorders" time="0.09">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches errors originating downstream" name="ReactErrorBoundaries catches errors originating downstream" time="0.168">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches errors in componentDidMount" name="ReactErrorBoundaries catches errors in componentDidMount" time="0.08">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches errors in componentDidUpdate" name="ReactErrorBoundaries catches errors in componentDidUpdate" time="0.068">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches errors in useEffect" name="ReactErrorBoundaries catches errors in useEffect" time="0.067">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches errors in useLayoutEffect" name="ReactErrorBoundaries catches errors in useLayoutEffect" time="0.04">
    </testcase>
    <testcase classname="ReactErrorBoundaries propagates errors inside boundary during componentDidMount" name="ReactErrorBoundaries propagates errors inside boundary during componentDidMount" time="0.065">
    </testcase>
    <testcase classname="ReactErrorBoundaries calls static getDerivedStateFromError for each error that is captured" name="ReactErrorBoundaries calls static getDerivedStateFromError for each error that is captured" time="0.107">
    </testcase>
    <testcase classname="ReactErrorBoundaries discards a bad root if the root component fails" name="ReactErrorBoundaries discards a bad root if the root component fails" time="0.1">
    </testcase>
    <testcase classname="ReactErrorBoundaries renders empty output if error boundary does not handle the error" name="ReactErrorBoundaries renders empty output if error boundary does not handle the error" time="0.052">
    </testcase>
    <testcase classname="ReactErrorBoundaries passes first error when two errors happen in commit" name="ReactErrorBoundaries passes first error when two errors happen in commit" time="0.086">
    </testcase>
    <testcase classname="ReactErrorBoundaries propagates uncaught error inside unbatched initial mount" name="ReactErrorBoundaries propagates uncaught error inside unbatched initial mount" time="0.096">
    </testcase>
    <testcase classname="ReactErrorBoundaries handles errors that occur in before-mutation commit hook" name="ReactErrorBoundaries handles errors that occur in before-mutation commit hook" time="0.114">
    </testcase>
    <testcase classname="ReactErrorBoundaries should warn if an error boundary with only componentDidCatch does not update state" name="ReactErrorBoundaries should warn if an error boundary with only componentDidCatch does not update state" time="0.225">
    </testcase>
    <testcase classname="ReactErrorBoundaries should call both componentDidCatch and getDerivedStateFromError if both exist on a component" name="ReactErrorBoundaries should call both componentDidCatch and getDerivedStateFromError if both exist on a component" time="0.153">
    </testcase>
    <testcase classname="ReactErrorBoundaries should catch errors from invariants in completion phase" name="ReactErrorBoundaries should catch errors from invariants in completion phase" time="0.183">
    </testcase>
    <testcase classname="ReactErrorBoundaries should catch errors from errors in the throw phase from boundaries" name="ReactErrorBoundaries should catch errors from errors in the throw phase from boundaries" time="0.072">
    </testcase>
    <testcase classname="ReactErrorBoundaries should protect errors from errors in the stack generation" name="ReactErrorBoundaries should protect errors from errors in the stack generation" time="0.069">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches errors thrown in componentWillUnmount" name="ReactErrorBoundaries catches errors thrown in componentWillUnmount" time="0.074">
    </testcase>
    <testcase classname="ReactErrorBoundaries catches errors thrown while detaching refs" name="ReactErrorBoundaries catches errors thrown while detaching refs" time="0.099">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactTreeTraversal-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:36" time="0.704" tests="11">
    <testcase classname="ReactTreeTraversal Two phase traversal should not traverse when target is outside component boundary" name="ReactTreeTraversal Two phase traversal should not traverse when target is outside component boundary" time="0.098">
    </testcase>
    <testcase classname="ReactTreeTraversal Two phase traversal should traverse two phase across component boundary" name="ReactTreeTraversal Two phase traversal should traverse two phase across component boundary" time="0.021">
    </testcase>
    <testcase classname="ReactTreeTraversal Two phase traversal should traverse two phase at shallowest node" name="ReactTreeTraversal Two phase traversal should traverse two phase at shallowest node" time="0.004">
    </testcase>
    <testcase classname="ReactTreeTraversal Enter leave traversal should not traverse when enter/leaving outside DOM" name="ReactTreeTraversal Enter leave traversal should not traverse when enter/leaving outside DOM" time="0.003">
    </testcase>
    <testcase classname="ReactTreeTraversal Enter leave traversal should not traverse if enter/leave the same node" name="ReactTreeTraversal Enter leave traversal should not traverse if enter/leave the same node" time="0.018">
    </testcase>
    <testcase classname="ReactTreeTraversal Enter leave traversal should traverse enter/leave to sibling - avoids parent" name="ReactTreeTraversal Enter leave traversal should traverse enter/leave to sibling - avoids parent" time="0.004">
    </testcase>
    <testcase classname="ReactTreeTraversal Enter leave traversal should traverse enter/leave to parent - avoids parent" name="ReactTreeTraversal Enter leave traversal should traverse enter/leave to parent - avoids parent" time="0.01">
    </testcase>
    <testcase classname="ReactTreeTraversal Enter leave traversal should enter from the window" name="ReactTreeTraversal Enter leave traversal should enter from the window" time="0.005">
    </testcase>
    <testcase classname="ReactTreeTraversal Enter leave traversal should enter from the window to the shallowest" name="ReactTreeTraversal Enter leave traversal should enter from the window to the shallowest" time="0.043">
    </testcase>
    <testcase classname="ReactTreeTraversal Enter leave traversal should leave to the window" name="ReactTreeTraversal Enter leave traversal should leave to the window" time="0.007">
    </testcase>
    <testcase classname="ReactTreeTraversal Enter leave traversal should leave to the window from the shallowest" name="ReactTreeTraversal Enter leave traversal should leave to the window from the shallowest" time="0.011">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDeprecationWarnings-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:37" time="0.885" tests="5">
    <testcase classname="ReactDeprecationWarnings should warn when given defaultProps" name="ReactDeprecationWarnings should warn when given defaultProps" time="0.449">
    </testcase>
    <testcase classname="ReactDeprecationWarnings should warn when given string refs" name="ReactDeprecationWarnings should warn when given string refs" time="0.037">
    </testcase>
    <testcase classname="ReactDeprecationWarnings should not warn when owner and self are the same for string refs" name="ReactDeprecationWarnings should not warn when owner and self are the same for string refs" time="0.03">
    </testcase>
    <testcase classname="ReactDeprecationWarnings should warn when owner and self are different for string refs" name="ReactDeprecationWarnings should warn when owner and self are different for string refs" time="0.018">
    </testcase>
    <testcase classname="ReactDeprecationWarnings should warn when owner and self are different for string refs" name="ReactDeprecationWarnings should warn when owner and self are different for string refs" time="0.02">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/plugins/__tests__/SelectEventPlugin-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:38" time="0.475" tests="5">
    <testcase classname="SelectEventPlugin does not get confused when dependent events are registered independently" name="SelectEventPlugin does not get confused when dependent events are registered independently" time="0.107">
    </testcase>
    <testcase classname="SelectEventPlugin should fire `onSelect` when a listener is present" name="SelectEventPlugin should fire `onSelect` when a listener is present" time="0.01">
    </testcase>
    <testcase classname="SelectEventPlugin should fire `onSelectCapture` when a listener is present" name="SelectEventPlugin should fire `onSelectCapture` when a listener is present" time="0.005">
    </testcase>
    <testcase classname="SelectEventPlugin should not wait for `mouseup` after receiving `dragend`" name="SelectEventPlugin should not wait for `mouseup` after receiving `dragend`" time="0.011">
    </testcase>
    <testcase classname="SelectEventPlugin should handle selectionchange events" name="SelectEventPlugin should handle selectionchange events" time="0.026">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMEventListener-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:36" time="2.453" tests="22">
    <testcase classname="ReactDOMEventListener Propagation should propagate events one level down" name="ReactDOMEventListener Propagation should propagate events one level down" time="0.073">
    </testcase>
    <testcase classname="ReactDOMEventListener Propagation should propagate events two levels down" name="ReactDOMEventListener Propagation should propagate events two levels down" time="0.117">
    </testcase>
    <testcase classname="ReactDOMEventListener Propagation should not get confused by disappearing elements" name="ReactDOMEventListener Propagation should not get confused by disappearing elements" time="0.03">
    </testcase>
    <testcase classname="ReactDOMEventListener Propagation should batch between handlers from different roots" name="ReactDOMEventListener Propagation should batch between handlers from different roots" time="0.028">
    </testcase>
    <testcase classname="ReactDOMEventListener should not fire duplicate events for a React DOM tree" name="ReactDOMEventListener should not fire duplicate events for a React DOM tree" time="0.093">
    </testcase>
    <testcase classname="ReactDOMEventListener should not fire form events twice" name="ReactDOMEventListener should not fire form events twice" time="0.078">
    </testcase>
    <testcase classname="ReactDOMEventListener should not receive submit events if native, interim DOM handler prevents it" name="ReactDOMEventListener should not receive submit events if native, interim DOM handler prevents it" time="0.074">
    </testcase>
    <testcase classname="ReactDOMEventListener should dispatch loadstart only for media elements" name="ReactDOMEventListener should dispatch loadstart only for media elements" time="0.098">
    </testcase>
    <testcase classname="ReactDOMEventListener should not attempt to listen to unnecessary events on the top level" name="ReactDOMEventListener should not attempt to listen to unnecessary events on the top level" time="0.055">
    </testcase>
    <testcase classname="ReactDOMEventListener should dispatch load for embed elements" name="ReactDOMEventListener should dispatch load for embed elements" time="0.053">
    </testcase>
    <testcase classname="ReactDOMEventListener should delegate media events even without a direct listener" name="ReactDOMEventListener should delegate media events even without a direct listener" time="0.065">
    </testcase>
    <testcase classname="ReactDOMEventListener should delegate dialog events even without a direct listener" name="ReactDOMEventListener should delegate dialog events even without a direct listener" time="0.064">
    </testcase>
    <testcase classname="ReactDOMEventListener should bubble non-native bubbling toggle events" name="ReactDOMEventListener should bubble non-native bubbling toggle events" time="0.059">
    </testcase>
    <testcase classname="ReactDOMEventListener should bubble non-native bubbling cancel/close events" name="ReactDOMEventListener should bubble non-native bubbling cancel/close events" time="0.048">
    </testcase>
    <testcase classname="ReactDOMEventListener should bubble non-native bubbling media events events" name="ReactDOMEventListener should bubble non-native bubbling media events events" time="0.046">
    </testcase>
    <testcase classname="ReactDOMEventListener should bubble non-native bubbling invalid events" name="ReactDOMEventListener should bubble non-native bubbling invalid events" time="0.064">
    </testcase>
    <testcase classname="ReactDOMEventListener should handle non-bubbling capture events correctly" name="ReactDOMEventListener should handle non-bubbling capture events correctly" time="0.057">
    </testcase>
    <testcase classname="ReactDOMEventListener should not emulate bubbling of scroll events" name="ReactDOMEventListener should not emulate bubbling of scroll events" time="0.073">
    </testcase>
    <testcase classname="ReactDOMEventListener should not emulate bubbling of scroll events (no own handler)" name="ReactDOMEventListener should not emulate bubbling of scroll events (no own handler)" time="0.071">
    </testcase>
    <testcase classname="ReactDOMEventListener should subscribe to scroll during updates" name="ReactDOMEventListener should subscribe to scroll during updates" time="0.116">
    </testcase>
    <testcase classname="ReactDOMEventListener should subscribe to scroll during hydration" name="ReactDOMEventListener should subscribe to scroll during hydration" time="0.085">
    </testcase>
    <testcase classname="ReactDOMEventListener should not subscribe to selectionchange twice" name="ReactDOMEventListener should not subscribe to selectionchange twice" time="0.067">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/plugins/__tests__/EnterLeaveEventPlugin-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:38" time="1.146" tests="7">
    <testcase classname="EnterLeaveEventPlugin should set onMouseLeave relatedTarget properly in iframe" name="EnterLeaveEventPlugin should set onMouseLeave relatedTarget properly in iframe" time="0.12">
    </testcase>
    <testcase classname="EnterLeaveEventPlugin should set onMouseEnter relatedTarget properly in iframe" name="EnterLeaveEventPlugin should set onMouseEnter relatedTarget properly in iframe" time="0.048">
    </testcase>
    <testcase classname="EnterLeaveEventPlugin should find the common parent after updates" name="EnterLeaveEventPlugin should find the common parent after updates" time="0.112">
    </testcase>
    <testcase classname="EnterLeaveEventPlugin should call mouseEnter once from sibling rendered inside a rendered component" name="EnterLeaveEventPlugin should call mouseEnter once from sibling rendered inside a rendered component" time="0.139">
    </testcase>
    <testcase classname="EnterLeaveEventPlugin should call mouseEnter when pressing a non tracked React node" name="EnterLeaveEventPlugin should call mouseEnter when pressing a non tracked React node" time="0.094">
    </testcase>
    <testcase classname="EnterLeaveEventPlugin should work with portals outside of the root that has onMouseLeave" name="EnterLeaveEventPlugin should work with portals outside of the root that has onMouseLeave" time="0.095">
    </testcase>
    <testcase classname="EnterLeaveEventPlugin should work with portals that have onMouseEnter outside of the root " name="EnterLeaveEventPlugin should work with portals that have onMouseEnter outside of the root " time="0.171">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/plugins/__tests__/ChangeEventPlugin-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:37" time="2.648" tests="21">
    <testcase classname="ChangeEventPlugin should consider initial text value to be current" name="ChangeEventPlugin should consider initial text value to be current" time="0.111">
    </testcase>
    <testcase classname="ChangeEventPlugin should consider initial text value to be current (capture)" name="ChangeEventPlugin should consider initial text value to be current (capture)" time="0.138">
    </testcase>
    <testcase classname="ChangeEventPlugin should consider initial checkbox checked=true to be current" name="ChangeEventPlugin should consider initial checkbox checked=true to be current" time="0.041">
    </testcase>
    <testcase classname="ChangeEventPlugin should consider initial checkbox checked=false to be current" name="ChangeEventPlugin should consider initial checkbox checked=false to be current" time="0.078">
    </testcase>
    <testcase classname="ChangeEventPlugin should fire change for checkbox input" name="ChangeEventPlugin should fire change for checkbox input" time="0.063">
    </testcase>
    <testcase classname="ChangeEventPlugin should not fire change setting the value programmatically" name="ChangeEventPlugin should not fire change setting the value programmatically" time="0.082">
    </testcase>
    <testcase classname="ChangeEventPlugin should not distinguish equal string and number values" name="ChangeEventPlugin should not distinguish equal string and number values" time="0.051">
    </testcase>
    <testcase classname="ChangeEventPlugin should not fire change when setting checked programmatically" name="ChangeEventPlugin should not fire change when setting checked programmatically" time="0.084">
    </testcase>
    <testcase classname="ChangeEventPlugin should unmount" name="ChangeEventPlugin should unmount" time="0.036">
    </testcase>
    <testcase classname="ChangeEventPlugin should only fire change for checked radio button once" name="ChangeEventPlugin should only fire change for checked radio button once" time="0.058">
    </testcase>
    <testcase classname="ChangeEventPlugin should track radio button cousins in a group" name="ChangeEventPlugin should track radio button cousins in a group" time="0.095">
    </testcase>
    <testcase classname="ChangeEventPlugin should deduplicate input value change events" name="ChangeEventPlugin should deduplicate input value change events" time="0.11">
    </testcase>
    <testcase classname="ChangeEventPlugin should listen for both change and input events when supported" name="ChangeEventPlugin should listen for both change and input events when supported" time="0.045">
    </testcase>
    <testcase classname="ChangeEventPlugin should only fire events when the value changes for range inputs" name="ChangeEventPlugin should only fire events when the value changes for range inputs" time="0.077">
    </testcase>
    <testcase classname="ChangeEventPlugin does not crash for nodes with custom value property" name="ChangeEventPlugin does not crash for nodes with custom value property" time="0.088">
    </testcase>
    <testcase classname="ChangeEventPlugin concurrent mode text input" name="ChangeEventPlugin concurrent mode text input" time="0.057">
    </testcase>
    <testcase classname="ChangeEventPlugin concurrent mode checkbox input" name="ChangeEventPlugin concurrent mode checkbox input" time="0.115">
    </testcase>
    <testcase classname="ChangeEventPlugin concurrent mode textarea" name="ChangeEventPlugin concurrent mode textarea" time="0.219">
    </testcase>
    <testcase classname="ChangeEventPlugin concurrent mode parent of input" name="ChangeEventPlugin concurrent mode parent of input" time="0.229">
    </testcase>
    <testcase classname="ChangeEventPlugin concurrent mode is sync for non-input events" name="ChangeEventPlugin concurrent mode is sync for non-input events" time="0.095">
    </testcase>
    <testcase classname="ChangeEventPlugin concurrent mode mouse enter/leave should be user-blocking but not discrete" name="ChangeEventPlugin concurrent mode mouse enter/leave should be user-blocking but not discrete" time="0.09">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test-3.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:34" time="6.198" tests="63">
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with server string render" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with server string render" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with server stream render" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with server stream render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with clean client render" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with clean client render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with client render on top of good server markup" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with client render on top of good server markup" time="0.099">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as single child with client render on top of bad server markup" time="0.226">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with server string render" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with server string render" time="0.119">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with server stream render" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with server stream render" time="0.239">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with clean client render" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with clean client render" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with client render on top of good server markup" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with client render on top of good server markup" time="0.146">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children escaping &gt;, &lt;, and &amp; renders &gt;,&lt;, and &amp; as multiple children with client render on top of bad server markup" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with server string render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with server string render" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with server stream render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with server stream render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with clean client render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with client render on top of good server markup" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with client render on top of good server markup" time="0.179">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with one text child with special characters with client render on top of bad server markup" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with server string render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with server string render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with server stream render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with server stream render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with clean client render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with clean client render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with client render on top of good server markup" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with client render on top of good server markup" time="0.094">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with two text children with special characters with client render on top of bad server markup" time="0.099">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with server string render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with server string render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with server stream render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with server stream render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with clean client render" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with clean client render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with client render on top of good server markup" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with client render on top of good server markup" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children carriage return and null character renders an element with an attribute value with special characters with client render on top of bad server markup" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with server string render" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with server string render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with server stream render" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with server stream render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with clean client render" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with clean client render" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with client render on top of good server markup" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with client render on top of good server markup" time="0.271">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning null with client render on top of bad server markup" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with server string render" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with server string render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with server stream render" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with server stream render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with clean client render" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with clean client render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with client render on top of good server markup" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with client render on top of good server markup" time="0.111">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning null with client render on top of bad server markup" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with server string render" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with server string render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with server stream render" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with server stream render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with clean client render" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with client render on top of good server markup" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with client render on top of good server markup" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children components that render nullish renders a function returning undefined with client render on top of bad server markup" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with server string render" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with server string render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with server stream render" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with clean client render" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with clean client render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with client render on top of good server markup" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with client render on top of good server markup" time="0.162">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children components that render nullish renders a class returning undefined with client render on top of bad server markup" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a function returning an object with server string render" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a function returning an object with server string render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a function returning an object with clean client render" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a function returning an object with clean client render" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a function returning an object with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a function returning an object with client render on top of bad server markup" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a class returning an object with server string render" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a class returning an object with server string render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a class returning an object with clean client render" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a class returning an object with clean client render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a class returning an object with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering a class returning an object with client render on top of bad server markup" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering top-level object with server string render" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering top-level object with server string render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering top-level object with clean client render" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering top-level object with clean client render" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children components that throw errors throws when rendering top-level object with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children components that throw errors throws when rendering top-level object with client render on top of bad server markup" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering object with server string render" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering object with server string render" time="0.217">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering object with clean client render" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering object with clean client render" time="0.216">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering object with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering object with client render on top of bad server markup" time="0.115">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering null with server string render" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering null with server string render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering null with clean client render" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering null with clean client render" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering null with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering null with client render on top of bad server markup" time="0.031">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering undefined with server string render" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering undefined with server string render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering undefined with clean client render" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering undefined with clean client render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering undefined with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children badly-typed elements throws when rendering undefined with client render on top of bad server markup" time="0.063">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/plugins/__tests__/BeforeInputEventPlugin-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:39" time="1.51" tests="7">
    <testcase classname="BeforeInputEventPlugin should extract onBeforeInput when simulating in Webkit on input[type=text]" name="BeforeInputEventPlugin should extract onBeforeInput when simulating in Webkit on input[type=text]" time="0.144">
    </testcase>
    <testcase classname="BeforeInputEventPlugin should extract onBeforeInput when simulating in Webkit on contenteditable" name="BeforeInputEventPlugin should extract onBeforeInput when simulating in Webkit on contenteditable" time="0.062">
    </testcase>
    <testcase classname="BeforeInputEventPlugin should extract onBeforeInput when simulating in IE11 on input[type=text]" name="BeforeInputEventPlugin should extract onBeforeInput when simulating in IE11 on input[type=text]" time="0.079">
    </testcase>
    <testcase classname="BeforeInputEventPlugin should extract onBeforeInput when simulating in IE11 on contenteditable" name="BeforeInputEventPlugin should extract onBeforeInput when simulating in IE11 on contenteditable" time="0.085">
    </testcase>
    <testcase classname="BeforeInputEventPlugin should extract onBeforeInput when simulating in env with no CompositionEvent on input[type=text]" name="BeforeInputEventPlugin should extract onBeforeInput when simulating in env with no CompositionEvent on input[type=text]" time="0.066">
    </testcase>
    <testcase classname="BeforeInputEventPlugin should extract onBeforeInput when simulating in env with only CompositionEvent on input[type=text]" name="BeforeInputEventPlugin should extract onBeforeInput when simulating in env with only CompositionEvent on input[type=text]" time="0.079">
    </testcase>
    <testcase classname="BeforeInputEventPlugin should extract onBeforeInput when simulating in env with only CompositionEvent on contenteditable" name="BeforeInputEventPlugin should extract onBeforeInput when simulating in env with only CompositionEvent on contenteditable" time="0.079">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/__tests__/SyntheticEvent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:40" time="0.371" tests="3">
    <testcase classname="SyntheticEvent should be able to `preventDefault`" name="SyntheticEvent should be able to `preventDefault`" time="0.062">
    </testcase>
    <testcase classname="SyntheticEvent should be prevented if nativeEvent is prevented" name="SyntheticEvent should be prevented if nativeEvent is prevented" time="0.003">
    </testcase>
    <testcase classname="SyntheticEvent should be able to `stopPropagation`" name="SyntheticEvent should be able to `stopPropagation`" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/__tests__/SyntheticFocusEvent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:40" time="0.456" tests="2">
    <testcase classname="SyntheticFocusEvent onFocus events have the focus type" name="SyntheticFocusEvent onFocus events have the focus type" time="0.08">
    </testcase>
    <testcase classname="SyntheticFocusEvent onBlur events have the blur type" name="SyntheticFocusEvent onBlur events have the blur type" time="0.048">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/__tests__/SyntheticWheelEvent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:41" time="0.482" tests="3">
    <testcase classname="SyntheticWheelEvent should normalize properties from the MouseEvent interface" name="SyntheticWheelEvent should normalize properties from the MouseEvent interface" time="0.086">
    </testcase>
    <testcase classname="SyntheticWheelEvent should normalize properties from the WheelEvent interface" name="SyntheticWheelEvent should normalize properties from the WheelEvent interface" time="0.003">
    </testcase>
    <testcase classname="SyntheticWheelEvent should be able to `preventDefault` and `stopPropagation`" name="SyntheticWheelEvent should be able to `preventDefault` and `stopPropagation`" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/__tests__/SyntheticKeyboardEvent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:41" time="0.775" tests="17">
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 0 and keyCode is 13, returns 13" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 0 and keyCode is 13, returns 13" time="0.095">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 32 or bigger and keyCode is missing, returns charCode" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 32 or bigger and keyCode is missing, returns charCode" time="0.003">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 13 and keyCode is missing, returns charCode" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 13 and keyCode is missing, returns charCode" time="0.002">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is smaller than 32 but is not 13, and keyCode is missing, ignores keypress" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is smaller than 32 but is not 13, and keyCode is missing, ignores keypress" time="0.007">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 10, returns 13" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 10, returns 13" time="0.003">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 10 and ctrl is pressed, returns 13" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is present in nativeEvent when charCode is 10 and ctrl is pressed, returns 13" time="0.003">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is not present in nativeEvent when keyCode is 32 or bigger, returns keyCode" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is not present in nativeEvent when keyCode is 32 or bigger, returns keyCode" time="0.003">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is not present in nativeEvent when keyCode is 13, returns 13" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is not present in nativeEvent when keyCode is 13, returns 13" time="0.051">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is not present in nativeEvent when keyCode is smaller than 32 and is not 13, ignores keypress" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is `keypress` when charCode is not present in nativeEvent when keyCode is smaller than 32 and is not 13, ignores keypress" time="0.003">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is not `keypress` returns 0" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when event is not `keypress` returns 0" time="0.003">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface charCode when charCode is smaller than 32 but is not 13, and keyCode is missing, charCode is 0" name="SyntheticKeyboardEvent KeyboardEvent interface charCode when charCode is smaller than 32 but is not 13, and keyCode is missing, charCode is 0" time="0.003">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface keyCode when event is `keydown` or `keyup` returns a passed keyCode" name="SyntheticKeyboardEvent KeyboardEvent interface keyCode when event is `keydown` or `keyup` returns a passed keyCode" time="0.009">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface keyCode when event is `keypress` returns 0" name="SyntheticKeyboardEvent KeyboardEvent interface keyCode when event is `keypress` returns 0" time="0.002">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface which when event is `keypress` is consistent with `charCode`" name="SyntheticKeyboardEvent KeyboardEvent interface which when event is `keypress` is consistent with `charCode`" time="0.002">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface which when event is `keydown` or `keyup` is consistent with `keyCode`" name="SyntheticKeyboardEvent KeyboardEvent interface which when event is `keydown` or `keyup` is consistent with `keyCode`" time="0.025">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent KeyboardEvent interface code returns code on `keydown`, `keyup` and `keypress`" name="SyntheticKeyboardEvent KeyboardEvent interface code returns code on `keydown`, `keyup` and `keypress`" time="0.006">
    </testcase>
    <testcase classname="SyntheticKeyboardEvent EventInterface is able to `preventDefault` and `stopPropagation`" name="SyntheticKeyboardEvent EventInterface is able to `preventDefault` and `stopPropagation`" time="0.02">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/__tests__/getEventKey-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:42" time="0.524" tests="6">
    <testcase classname="getEventKey when key is implemented in a browser when key is not normalized returns a normalized value" name="getEventKey when key is implemented in a browser when key is not normalized returns a normalized value" time="0.07">
    </testcase>
    <testcase classname="getEventKey when key is implemented in a browser when key is normalized returns a key" name="getEventKey when key is implemented in a browser when key is normalized returns a key" time="0.002">
    </testcase>
    <testcase classname="getEventKey when key is not implemented in a browser when event type is keypress when charCode is 13 returns &quot;Enter&quot;" name="getEventKey when key is not implemented in a browser when event type is keypress when charCode is 13 returns &quot;Enter&quot;" time="0.003">
    </testcase>
    <testcase classname="getEventKey when key is not implemented in a browser when event type is keypress when charCode is not 13 returns a string from a charCode" name="getEventKey when key is not implemented in a browser when event type is keypress when charCode is not 13 returns a string from a charCode" time="0.013">
    </testcase>
    <testcase classname="getEventKey when key is not implemented in a browser when event type is keydown or keyup when keyCode is recognized returns a translated key" name="getEventKey when key is not implemented in a browser when event type is keydown or keyup when keyCode is recognized returns a translated key" time="0.005">
    </testcase>
    <testcase classname="getEventKey when key is not implemented in a browser when event type is keydown or keyup when keyCode is not recognized returns Unidentified" name="getEventKey when key is not implemented in a browser when event type is keydown or keyup when keyCode is not recognized returns Unidentified" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/plugins/__tests__/SimpleEventPlugin-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:39" time="3.446" tests="32">
    <testcase classname="SimpleEventPlugin A non-interactive tags click when disabled" name="SimpleEventPlugin A non-interactive tags click when disabled" time="0.119">
    </testcase>
    <testcase classname="SimpleEventPlugin A non-interactive tags clicks bubble when disabled" name="SimpleEventPlugin A non-interactive tags clicks bubble when disabled" time="0.116">
    </testcase>
    <testcase classname="SimpleEventPlugin does not register a click when clicking a child of a disabled element" name="SimpleEventPlugin does not register a click when clicking a child of a disabled element" time="0.071">
    </testcase>
    <testcase classname="SimpleEventPlugin triggers click events for children of disabled elements" name="SimpleEventPlugin triggers click events for children of disabled elements" time="0.118">
    </testcase>
    <testcase classname="SimpleEventPlugin triggers parent captured click events when target is a child of a disabled elements" name="SimpleEventPlugin triggers parent captured click events when target is a child of a disabled elements" time="0.055">
    </testcase>
    <testcase classname="SimpleEventPlugin triggers captured click events for children of disabled elements" name="SimpleEventPlugin triggers captured click events for children of disabled elements" time="0.047">
    </testcase>
    <testcase classname="SimpleEventPlugin button should forward clicks when it starts out not disabled" name="SimpleEventPlugin button should forward clicks when it starts out not disabled" time="0.061">
    </testcase>
    <testcase classname="SimpleEventPlugin button should not forward clicks when it starts out disabled" name="SimpleEventPlugin button should not forward clicks when it starts out disabled" time="0.031">
    </testcase>
    <testcase classname="SimpleEventPlugin button should forward clicks when it becomes not disabled" name="SimpleEventPlugin button should forward clicks when it becomes not disabled" time="0.073">
    </testcase>
    <testcase classname="SimpleEventPlugin button should not forward clicks when it becomes disabled" name="SimpleEventPlugin button should not forward clicks when it becomes disabled" time="0.064">
    </testcase>
    <testcase classname="SimpleEventPlugin button should work correctly if the listener is changed" name="SimpleEventPlugin button should work correctly if the listener is changed" time="0.046">
    </testcase>
    <testcase classname="SimpleEventPlugin input should forward clicks when it starts out not disabled" name="SimpleEventPlugin input should forward clicks when it starts out not disabled" time="0.049">
    </testcase>
    <testcase classname="SimpleEventPlugin input should not forward clicks when it starts out disabled" name="SimpleEventPlugin input should not forward clicks when it starts out disabled" time="0.075">
    </testcase>
    <testcase classname="SimpleEventPlugin input should forward clicks when it becomes not disabled" name="SimpleEventPlugin input should forward clicks when it becomes not disabled" time="0.109">
    </testcase>
    <testcase classname="SimpleEventPlugin input should not forward clicks when it becomes disabled" name="SimpleEventPlugin input should not forward clicks when it becomes disabled" time="0.097">
    </testcase>
    <testcase classname="SimpleEventPlugin input should work correctly if the listener is changed" name="SimpleEventPlugin input should work correctly if the listener is changed" time="0.115">
    </testcase>
    <testcase classname="SimpleEventPlugin select should forward clicks when it starts out not disabled" name="SimpleEventPlugin select should forward clicks when it starts out not disabled" time="0.143">
    </testcase>
    <testcase classname="SimpleEventPlugin select should not forward clicks when it starts out disabled" name="SimpleEventPlugin select should not forward clicks when it starts out disabled" time="0.217">
    </testcase>
    <testcase classname="SimpleEventPlugin select should forward clicks when it becomes not disabled" name="SimpleEventPlugin select should forward clicks when it becomes not disabled" time="0.154">
    </testcase>
    <testcase classname="SimpleEventPlugin select should not forward clicks when it becomes disabled" name="SimpleEventPlugin select should not forward clicks when it becomes disabled" time="0.238">
    </testcase>
    <testcase classname="SimpleEventPlugin select should work correctly if the listener is changed" name="SimpleEventPlugin select should work correctly if the listener is changed" time="0.07">
    </testcase>
    <testcase classname="SimpleEventPlugin textarea should forward clicks when it starts out not disabled" name="SimpleEventPlugin textarea should forward clicks when it starts out not disabled" time="0.06">
    </testcase>
    <testcase classname="SimpleEventPlugin textarea should not forward clicks when it starts out disabled" name="SimpleEventPlugin textarea should not forward clicks when it starts out disabled" time="0.06">
    </testcase>
    <testcase classname="SimpleEventPlugin textarea should forward clicks when it becomes not disabled" name="SimpleEventPlugin textarea should forward clicks when it becomes not disabled" time="0.07">
    </testcase>
    <testcase classname="SimpleEventPlugin textarea should not forward clicks when it becomes disabled" name="SimpleEventPlugin textarea should not forward clicks when it becomes disabled" time="0.08">
    </testcase>
    <testcase classname="SimpleEventPlugin textarea should work correctly if the listener is changed" name="SimpleEventPlugin textarea should work correctly if the listener is changed" time="0.039">
    </testcase>
    <testcase classname="SimpleEventPlugin batches updates that occur as a result of a nested event dispatch" name="SimpleEventPlugin batches updates that occur as a result of a nested event dispatch" time="0.031">
    </testcase>
    <testcase classname="SimpleEventPlugin interactive events, in concurrent mode flushes pending interactive work before exiting event handler" name="SimpleEventPlugin interactive events, in concurrent mode flushes pending interactive work before exiting event handler" time="0.056">
    </testcase>
    <testcase classname="SimpleEventPlugin interactive events, in concurrent mode end result of many interactive updates is deterministic" name="SimpleEventPlugin interactive events, in concurrent mode end result of many interactive updates is deterministic" time="0.282">
    </testcase>
    <testcase classname="SimpleEventPlugin iOS bubbling click fix does not add a local click to interactive elements" name="SimpleEventPlugin iOS bubbling click fix does not add a local click to interactive elements" time="0.039">
    </testcase>
    <testcase classname="SimpleEventPlugin iOS bubbling click fix adds a local click listener to non-interactive elements" name="SimpleEventPlugin iOS bubbling click fix adds a local click listener to non-interactive elements" time="0.047">
    </testcase>
    <testcase classname="SimpleEventPlugin iOS bubbling click fix registers passive handlers for events affected by the intervention" name="SimpleEventPlugin iOS bubbling click fix registers passive handlers for events affected by the intervention" time="0.075">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDomServerIntegrationAttributes-3-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:37" time="5.693" tests="55">
    <testcase classname="ReactDOMServerIntegration custom elements renders class for custom elements with server string render" name="ReactDOMServerIntegration custom elements renders class for custom elements with server string render" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders class for custom elements with server stream render" name="ReactDOMServerIntegration custom elements renders class for custom elements with server stream render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders class for custom elements with clean client render" name="ReactDOMServerIntegration custom elements renders class for custom elements with clean client render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders class for custom elements with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders class for custom elements with client render on top of good server markup" time="0.119">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders class for custom elements with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders class for custom elements with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders className for custom elements with server string render" name="ReactDOMServerIntegration custom elements renders className for custom elements with server string render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders className for custom elements with server stream render" name="ReactDOMServerIntegration custom elements renders className for custom elements with server stream render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders className for custom elements with clean client render" name="ReactDOMServerIntegration custom elements renders className for custom elements with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders className for custom elements with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders className for custom elements with client render on top of good server markup" time="0.181">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders className for custom elements with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders className for custom elements with client render on top of bad server markup" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with server string render" name="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with server string render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with server stream render" name="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with server stream render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with clean client render" name="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with clean client render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with client render on top of good server markup" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders htmlFor attribute on custom elements with client render on top of bad server markup" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders for attribute on custom elements with server string render" name="ReactDOMServerIntegration custom elements renders for attribute on custom elements with server string render" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders for attribute on custom elements with server stream render" name="ReactDOMServerIntegration custom elements renders for attribute on custom elements with server stream render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders for attribute on custom elements with clean client render" name="ReactDOMServerIntegration custom elements renders for attribute on custom elements with clean client render" time="0.107">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders for attribute on custom elements with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders for attribute on custom elements with client render on top of good server markup" time="0.278">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders for attribute on custom elements with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders for attribute on custom elements with client render on top of bad server markup" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with server string render" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with server string render" time="0.243">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with server stream render" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with server stream render" time="0.106">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with clean client render" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with clean client render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with client render on top of good server markup" time="0.088">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements with client render on top of bad server markup" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with server string render" name="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with server string render" time="0.03">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with server stream render" name="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with server stream render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with clean client render" name="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with clean client render" time="0.065">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with client render on top of good server markup" time="0.103">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders unknown `on*` attributes for custom elements with client render on top of bad server markup" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with server string render" name="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with server string render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with server stream render" name="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with server stream render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with clean client render" name="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with client render on top of good server markup" time="0.111">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders unknown boolean `true` attributes as strings with client render on top of bad server markup" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with server string render" name="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with server string render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with server stream render" name="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with server stream render" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with clean client render" name="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with clean client render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with client render on top of good server markup" time="0.108">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders unknown boolean `false` attributes as strings with client render on top of bad server markup" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with server string render" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with server string render" time="0.044">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with server stream render" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with server stream render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with clean client render" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with clean client render" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with client render on top of good server markup" time="0.293">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements with null value with client render on top of bad server markup" time="0.145">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with server string render" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with server string render" time="0.187">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with server stream render" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with server stream render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with clean client render" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with clean client render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with client render on top of good server markup" time="0.155">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders unknown attributes for custom elements using is with client render on top of bad server markup" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with server string render" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with server string render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with server stream render" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with server stream render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with clean client render" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with clean client render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with client render on top of good server markup" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with client render on top of good server markup" time="0.114">
    </testcase>
    <testcase classname="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with client render on top of bad server markup" name="ReactDOMServerIntegration custom elements renders no unknown attributes for custom elements using is with null value with client render on top of bad server markup" time="0.04">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/__tests__/SyntheticClipboardEvent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:42" time="0.414" tests="2">
    <testcase classname="SyntheticClipboardEvent ClipboardEvent interface clipboardData when event has clipboardData returns event&apos;s clipboardData" name="SyntheticClipboardEvent ClipboardEvent interface clipboardData when event has clipboardData returns event&apos;s clipboardData" time="0.098">
    </testcase>
    <testcase classname="SyntheticClipboardEvent EventInterface is able to `preventDefault` and `stopPropagation`" name="SyntheticClipboardEvent EventInterface is able to `preventDefault` and `stopPropagation`" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/__tests__/SyntheticMouseEvent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:43" time="0.522" tests="2">
    <testcase classname="SyntheticMouseEvent should only use values from movementX/Y when event type is mousemove" name="SyntheticMouseEvent should only use values from movementX/Y when event type is mousemove" time="0.11">
    </testcase>
    <testcase classname="SyntheticMouseEvent should correctly calculate movementX/Y for capture phase" name="SyntheticMouseEvent should correctly calculate movementX/Y for capture phase" time="0.089">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/client/__tests__/getNodeForCharacterOffset-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:43" time="0.495" tests="4">
    <testcase classname="getNodeForCharacterOffset should handle siblings" name="getNodeForCharacterOffset should handle siblings" time="0.025">
    </testcase>
    <testcase classname="getNodeForCharacterOffset should handle trailing chars" name="getNodeForCharacterOffset should handle trailing chars" time="0.003">
    </testcase>
    <testcase classname="getNodeForCharacterOffset should handle trees" name="getNodeForCharacterOffset should handle trees" time="0.007">
    </testcase>
    <testcase classname="getNodeForCharacterOffset should handle non-existent offset" name="getNodeForCharacterOffset should handle non-existent offset" time="0.023">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/client/__tests__/dangerouslySetInnerHTML-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:43" time="0.727" tests="3">
    <testcase classname="dangerouslySetInnerHTML when the node has innerHTML property sets innerHTML on it" name="dangerouslySetInnerHTML when the node has innerHTML property sets innerHTML on it" time="0.025">
    </testcase>
    <testcase classname="dangerouslySetInnerHTML when the node does not have an innerHTML property sets innerHTML on it" name="dangerouslySetInnerHTML when the node does not have an innerHTML property sets innerHTML on it" time="0.008">
    </testcase>
    <testcase classname="dangerouslySetInnerHTML when the node does not have an innerHTML property clears previous children" name="dangerouslySetInnerHTML when the node does not have an innerHTML property clears previous children" time="0.015">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/client/__tests__/trustedTypes-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:43" time="1.237" tests="6">
    <testcase classname="when Trusted Types are available in global object should not stringify trusted values for dangerouslySetInnerHTML" name="when Trusted Types are available in global object should not stringify trusted values for dangerouslySetInnerHTML" time="0.157">
    </testcase>
    <testcase classname="when Trusted Types are available in global object should not stringify trusted values for setAttribute (unknown attribute)" name="when Trusted Types are available in global object should not stringify trusted values for setAttribute (unknown attribute)" time="0.137">
    </testcase>
    <testcase classname="when Trusted Types are available in global object should not stringify trusted values for setAttribute (known attribute)" name="when Trusted Types are available in global object should not stringify trusted values for setAttribute (known attribute)" time="0.127">
    </testcase>
    <testcase classname="when Trusted Types are available in global object should not stringify trusted values for setAttributeNS" name="when Trusted Types are available in global object should not stringify trusted values for setAttributeNS" time="0.157">
    </testcase>
    <testcase classname="when Trusted Types are available in global object dangerouslySetInnerHTML in svg elements in Internet Explorer should log a warning" name="when Trusted Types are available in global object dangerouslySetInnerHTML in svg elements in Internet Explorer should log a warning" time="0.071">
    </testcase>
    <testcase classname="when Trusted Types are available in global object should warn once when rendering script tag in jsx on client" name="when Trusted Types are available in global object should warn once when rendering script tag in jsx on client" time="0.068">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-devtools-timeline/src/content-views/utils/__tests__/moduleFilters-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:44" time="0.539" tests="2">
    <testcase classname="isInternalModule should properly identify stack frames within the provided module ranges" name="isInternalModule should properly identify stack frames within the provided module ranges" time="0.001">
    </testcase>
    <testcase classname="isInternalModule should properly identify stack frames outside of the provided module ranges" name="isInternalModule should properly identify stack frames outside of the provided module ranges" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-devtools-timeline/src/content-views/utils/__tests__/colors-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:44" time="0.64" tests="8">
    <testcase classname="hslaColorToString should transform colors to strings" name="hslaColorToString should transform colors to strings" time="0.009">
    </testcase>
    <testcase classname="dimmedColor should dim luminosity using delta" name="dimmedColor should dim luminosity using delta" time="0.001">
    </testcase>
    <testcase classname="ColorGenerator colorForID should generate a color for an ID" name="ColorGenerator colorForID should generate a color for an ID" time="0.005">
    </testcase>
    <testcase classname="ColorGenerator colorForID should generate colors deterministically given an ID" name="ColorGenerator colorForID should generate colors deterministically given an ID" time="0">
    </testcase>
    <testcase classname="ColorGenerator colorForID should generate different colors for different IDs" name="ColorGenerator colorForID should generate different colors for different IDs" time="0.001">
    </testcase>
    <testcase classname="ColorGenerator colorForID should return colors that have been set manually" name="ColorGenerator colorForID should return colors that have been set manually" time="0">
    </testcase>
    <testcase classname="ColorGenerator colorForID should generate colors from fixed color spaces" name="ColorGenerator colorForID should generate colors from fixed color spaces" time="0.001">
    </testcase>
    <testcase classname="ColorGenerator colorForID should generate colors from range color spaces" name="ColorGenerator colorForID should generate colors from range color spaces" time="0">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-devtools-timeline/src/view-base/utils/__tests__/scrollState-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:45" time="0.687" tests="13">
    <testcase classname="clampState should passthrough offset if state fits within container" name="clampState should passthrough offset if state fits within container" time="0.001">
    </testcase>
    <testcase classname="clampState should clamp offset if offset causes content to go out of container" name="clampState should clamp offset if offset causes content to go out of container" time="0">
    </testcase>
    <testcase classname="clampState should passthrough length if container fits in content" name="clampState should passthrough length if container fits in content" time="0.001">
    </testcase>
    <testcase classname="clampState should clamp length to minimum of max(minContentLength, containerLength)" name="clampState should clamp length to minimum of max(minContentLength, containerLength)" time="0">
    </testcase>
    <testcase classname="clampState should clamp length to maximum of max(containerLength, maxContentLength)" name="clampState should clamp length to maximum of max(containerLength, maxContentLength)" time="0.001">
    </testcase>
    <testcase classname="translateState should translate state by delta and leave length unchanged" name="translateState should translate state by delta and leave length unchanged" time="0">
    </testcase>
    <testcase classname="translateState should clamp resulting offset" name="translateState should clamp resulting offset" time="0.001">
    </testcase>
    <testcase classname="zoomState should scale width by multiplier" name="zoomState should scale width by multiplier" time="0.025">
    </testcase>
    <testcase classname="zoomState should clamp zoomed state" name="zoomState should clamp zoomed state" time="0">
    </testcase>
    <testcase classname="zoomState should maintain containerStart&lt;-&gt;fixedPoint distance" name="zoomState should maintain containerStart&lt;-&gt;fixedPoint distance" time="0.007">
    </testcase>
    <testcase classname="moveStateToRange should set [rangeStart, rangeEnd] = container" name="moveStateToRange should set [rangeStart, rangeEnd] = container" time="0.002">
    </testcase>
    <testcase classname="areScrollStatesEqual should return true if equal" name="areScrollStatesEqual should return true if equal" time="0.001">
    </testcase>
    <testcase classname="areScrollStatesEqual should return false if not equal" name="areScrollStatesEqual should return false if not equal" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-devtools-timeline/src/view-base/utils/__tests__/clamp-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:45" time="0.326" tests="3">
    <testcase classname="clamp should return min if value &lt; min" name="clamp should return min if value &lt; min" time="0.001">
    </testcase>
    <testcase classname="clamp should return value if min &lt;= value &lt;= max" name="clamp should return value if min &lt;= value &lt;= max" time="0.001">
    </testcase>
    <testcase classname="clamp should return max if max &lt; value" name="clamp should return max if max &lt; value" time="0">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-server-dom-webpack/src/__tests__/ReactFlightDOM-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:44" time="2.27" tests="6">
    <testcase classname="ReactFlightDOM should resolve HTML using Node streams" name="ReactFlightDOM should resolve HTML using Node streams" time="0.662">
    </testcase>
    <testcase classname="ReactFlightDOM should resolve the root" name="ReactFlightDOM should resolve the root" time="0.099">
    </testcase>
    <testcase classname="ReactFlightDOM should not get confused by $" name="ReactFlightDOM should not get confused by $" time="0.099">
    </testcase>
    <testcase classname="ReactFlightDOM should not get confused by @" name="ReactFlightDOM should not get confused by @" time="0.098">
    </testcase>
    <testcase classname="ReactFlightDOM should progressively reveal server components" name="ReactFlightDOM should progressively reveal server components" time="0.089">
    </testcase>
    <testcase classname="ReactFlightDOM should preserve state of client components on refetch" name="ReactFlightDOM should preserve state of client components on refetch" time="0.153">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-server-dom-webpack/src/__tests__/ReactFlightDOMBrowser-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:43" time="2.701" tests="4">
    <testcase classname="ReactFlightDOMBrowser should resolve HTML using W3C streams" name="ReactFlightDOMBrowser should resolve HTML using W3C streams" time="1.097">
    </testcase>
    <testcase classname="ReactFlightDOMBrowser should resolve HTML using W3C streams" name="ReactFlightDOMBrowser should resolve HTML using W3C streams" time="0.164">
    </testcase>
    <testcase classname="ReactFlightDOMBrowser should progressively reveal server components" name="ReactFlightDOMBrowser should progressively reveal server components" time="0.33">
    </testcase>
    <testcase classname="ReactFlightDOMBrowser should close the stream upon completion when rendering to W3C streams" name="ReactFlightDOMBrowser should close the stream upon completion when rendering to W3C streams" time="0.072">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-devtools-timeline/src/view-base/__tests__/geometry-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:46" time="1.039" tests="20">
    <testcase classname="pointEqualToPoint should return true when 2 points have the same values" name="pointEqualToPoint should return true when 2 points have the same values" time="0">
    </testcase>
    <testcase classname="pointEqualToPoint should return false when 2 points have different values" name="pointEqualToPoint should return false when 2 points have different values" time="0.001">
    </testcase>
    <testcase classname="sizeEqualToSize should return true when 2 sizes have the same values" name="sizeEqualToSize should return true when 2 sizes have the same values" time="0.001">
    </testcase>
    <testcase classname="sizeEqualToSize should return false when 2 sizes have different values" name="sizeEqualToSize should return false when 2 sizes have different values" time="0">
    </testcase>
    <testcase classname="rectEqualToRect should return true when 2 rects have the same values" name="rectEqualToRect should return true when 2 rects have the same values" time="0.002">
    </testcase>
    <testcase classname="rectEqualToRect should return false when 2 rects have different values" name="rectEqualToRect should return false when 2 rects have different values" time="0">
    </testcase>
    <testcase classname="sizeIsValid should return true when the size has non-negative width and height" name="sizeIsValid should return true when the size has non-negative width and height" time="0.001">
    </testcase>
    <testcase classname="sizeIsValid should return false when the size has negative width or height" name="sizeIsValid should return false when the size has negative width or height" time="0">
    </testcase>
    <testcase classname="sizeIsEmpty should return true when the size has negative area" name="sizeIsEmpty should return true when the size has negative area" time="0.026">
    </testcase>
    <testcase classname="sizeIsEmpty should return true when the size has zero area" name="sizeIsEmpty should return true when the size has zero area" time="0.001">
    </testcase>
    <testcase classname="sizeIsEmpty should return false when the size has positive area" name="sizeIsEmpty should return false when the size has positive area" time="0.001">
    </testcase>
    <testcase classname="rectIntersectsRect should return true when 2 rects intersect" name="rectIntersectsRect should return true when 2 rects intersect" time="0">
    </testcase>
    <testcase classname="rectIntersectsRect should return false when 2 rects do not intersect" name="rectIntersectsRect should return false when 2 rects do not intersect" time="0.001">
    </testcase>
    <testcase classname="intersectionOfRects should return intersection when 2 rects intersect" name="intersectionOfRects should return intersection when 2 rects intersect" time="0.005">
    </testcase>
    <testcase classname="rectContainsPoint should return true if point is on the rect&apos;s edge" name="rectContainsPoint should return true if point is on the rect&apos;s edge" time="0">
    </testcase>
    <testcase classname="rectContainsPoint should return true if point is in rect" name="rectContainsPoint should return true if point is in rect" time="0.001">
    </testcase>
    <testcase classname="rectContainsPoint should return false if point is not in rect" name="rectContainsPoint should return false if point is not in rect" time="0">
    </testcase>
    <testcase classname="unionOfRects should return zero rect if no rects are provided" name="unionOfRects should return zero rect if no rects are provided" time="0">
    </testcase>
    <testcase classname="unionOfRects should return rect if 1 rect is provided" name="unionOfRects should return rect if 1 rect is provided" time="0.001">
    </testcase>
    <testcase classname="unionOfRects should return union of rects if more than one rect is provided" name="unionOfRects should return union of rects if more than one rect is provided" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/__tests__/ReactDOMServerIntegrationElements-test-2.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:28" time="19.36" tests="193">
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with server string render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with server string render" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with server stream render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with server stream render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with clean client render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with client render on top of good server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with client render on top of good server markup" time="0.217">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null single child as blank with client render on top of bad server markup" time="0.129">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with server string render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with server string render" time="0.128">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with server stream render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with server stream render" time="0.144">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with clean client render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with clean client render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with client render on top of good server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with client render on top of good server markup" time="0.094">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false single child as blank with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with server string render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with server string render" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with server stream render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with server stream render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with clean client render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with client render on top of good server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with client render on top of good server markup" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders undefined single child as blank with client render on top of bad server markup" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with server string render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with server string render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with server stream render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with server stream render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with clean client render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with clean client render" time="0.046">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with client render on top of good server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with client render on top of good server markup" time="0.085">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders a null component children as empty with client render on top of bad server markup" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with server string render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with server string render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with server stream render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with server stream render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with clean client render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with clean client render" time="0.053">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with client render on top of good server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with client render on top of good server markup" time="0.157">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null children as blank with client render on top of bad server markup" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with server string render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with server string render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with server stream render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with server stream render" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with clean client render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with clean client render" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with client render on top of good server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with client render on top of good server markup" time="0.263">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders false children as blank with client render on top of bad server markup" time="0.118">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with server string render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with server string render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with server stream render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with server stream render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with clean client render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with clean client render" time="0.034">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with client render on top of good server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with client render on top of good server markup" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders null and false children together as blank with client render on top of bad server markup" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with server string render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with server stream render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with server stream render" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with clean client render" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with clean client render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with client render on top of good server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with client render on top of good server markup" time="0.087">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children null, false, and undefined children renders only null and false children as blank with client render on top of bad server markup" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with server string render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with server stream render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with server stream render" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with clean client render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with clean client render" time="0.028">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with client render on top of good server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with client render on top of good server markup" time="0.136">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders an svg element with client render on top of bad server markup" time="0.072">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with server string render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with server string render" time="0.049">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with server stream render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with server stream render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with clean client render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with clean client render" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with client render on top of good server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with client render on top of good server markup" time="0.324">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with an attribute with client render on top of bad server markup" time="0.195">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with server string render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with server string render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with server stream render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with clean client render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with clean client render" time="0.099">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with client render on top of good server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with client render on top of good server markup" time="0.107">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a namespace attribute with client render on top of bad server markup" time="0.093">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with server string render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with server string render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with server stream render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with server stream render" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with clean client render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with clean client render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with client render on top of good server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with client render on top of good server markup" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg child element with a badly cased alias with client render on top of bad server markup" time="0.127">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with server string render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with server string render" time="0.032">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with server stream render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with server stream render" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with clean client render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with clean client render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with client render on top of good server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with client render on top of good server markup" time="0.097">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a tabIndex attribute with client render on top of bad server markup" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with server string render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with server string render" time="0.058">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with server stream render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with server stream render" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with clean client render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with clean client render" time="0.125">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with client render on top of good server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with client render on top of good server markup" time="0.354">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a badly cased tabIndex attribute with client render on top of bad server markup" time="0.158">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with server string render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with server string render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with server stream render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with server stream render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with clean client render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with clean client render" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with client render on top of good server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with client render on top of good server markup" time="0.155">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders svg element with a mixed case name with client render on top of bad server markup" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with server string render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with server string render" time="0.096">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with server stream render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with clean client render" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with clean client render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with client render on top of good server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with client render on top of good server markup" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children elements with implicit namespaces renders a math element with client render on top of bad server markup" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with server string render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with server string render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with server stream render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with server stream render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with clean client render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with clean client render" time="0.045">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with client render on top of good server markup" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with client render on top of good server markup" time="0.136">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content not starting with \n with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with server string render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with server string render" time="0.091">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with server stream render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with server stream render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with clean client render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with clean client render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with client render on top of good server markup" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with client render on top of good server markup" time="0.155">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children newline-eating elements renders a newline-eating tag with content starting with \n with client render on top of bad server markup" time="0.035">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with server string render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with server string render" time="0.067">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with server stream render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with server stream render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with clean client render" name="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with clean client render" time="0.113">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with client render on top of good server markup" name="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with client render on top of good server markup" time="0.271">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children newline-eating elements renders a normal tag with content starting with \n with client render on top of bad server markup" time="0.234">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders stateless components with server string render" name="ReactDOMServerIntegration elements and children different component implementations renders stateless components with server string render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders stateless components with server stream render" name="ReactDOMServerIntegration elements and children different component implementations renders stateless components with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders stateless components with clean client render" name="ReactDOMServerIntegration elements and children different component implementations renders stateless components with clean client render" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders stateless components with client render on top of good server markup" name="ReactDOMServerIntegration elements and children different component implementations renders stateless components with client render on top of good server markup" time="0.122">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders stateless components with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children different component implementations renders stateless components with client render on top of bad server markup" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with server string render" name="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with server string render" time="0.074">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with server stream render" name="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with server stream render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with clean client render" name="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with clean client render" time="0.037">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with client render on top of good server markup" name="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with client render on top of good server markup" time="0.172">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children different component implementations renders ES6 class components with client render on top of bad server markup" time="0.077">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations throws when rendering factory components with server string render" name="ReactDOMServerIntegration elements and children different component implementations throws when rendering factory components with server string render" time="0.087">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations throws when rendering factory components with clean client render" name="ReactDOMServerIntegration elements and children different component implementations throws when rendering factory components with clean client render" time="0.078">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children different component implementations throws when rendering factory components with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children different component implementations throws when rendering factory components with client render on top of bad server markup" time="0.084">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with server string render" name="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with server string render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with server stream render" name="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with server stream render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with clean client render" name="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with clean client render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with client render on top of good server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with client render on top of good server markup" time="0.126">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders single child hierarchies of components with client render on top of bad server markup" time="0.051">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with server string render" name="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with server string render" time="0.076">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with server stream render" name="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with server stream render" time="0.094">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with clean client render" name="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with clean client render" time="0.251">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with client render on top of good server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with client render on top of good server markup" time="0.369">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders multi-child hierarchies of components with client render on top of bad server markup" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with server string render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with server string render" time="0.082">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with server stream render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with server stream render" time="0.043">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with clean client render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with clean client render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with client render on top of good server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with client render on top of good server markup" time="0.141">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a child with client render on top of bad server markup" time="0.071">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with server string render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with server string render" time="0.047">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with server stream render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with server stream render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with clean client render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with clean client render" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with client render on top of good server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with client render on top of good server markup" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children with client render on top of bad server markup" time="0.066">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with server string render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with server string render" time="0.041">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with server stream render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with server stream render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with clean client render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with clean client render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with client render on top of good server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with client render on top of good server markup" time="0.131">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with multiple children separated by whitespace with client render on top of bad server markup" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with server string render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with server string render" time="0.061">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with server stream render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with server stream render" time="0.06">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with clean client render" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with clean client render" time="0.118">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with client render on top of good server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with client render on top of good server markup" time="0.391">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a div with a single child surrounded by whitespace with client render on top of bad server markup" time="0.136">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with server string render" name="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with server string render" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with server stream render" name="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with server stream render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with clean client render" name="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with clean client render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with client render on top of good server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with client render on top of good server markup" time="0.144">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children component hierarchies renders a composite with multiple children with client render on top of bad server markup" time="0.09">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders an img with server string render" name="ReactDOMServerIntegration elements and children renders an img with server string render" time="0.073">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders an img with server stream render" name="ReactDOMServerIntegration elements and children renders an img with server stream render" time="0.07">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders an img with clean client render" name="ReactDOMServerIntegration elements and children renders an img with clean client render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders an img with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders an img with client render on top of good server markup" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders an img with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders an img with client render on top of bad server markup" time="0.063">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a button with server string render" name="ReactDOMServerIntegration elements and children renders a button with server string render" time="0.064">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a button with server stream render" name="ReactDOMServerIntegration elements and children renders a button with server stream render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a button with clean client render" name="ReactDOMServerIntegration elements and children renders a button with clean client render" time="0.042">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a button with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a button with client render on top of good server markup" time="0.106">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a button with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a button with client render on top of bad server markup" time="0.057">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with server string render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with server string render" time="0.068">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with server stream render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with server stream render" time="0.081">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with clean client render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with clean client render" time="0.025">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with client render on top of good server markup" time="0.148">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML number with client render on top of bad server markup" time="0.116">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with server string render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with server string render" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with server stream render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with server stream render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with clean client render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with clean client render" time="0.145">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with client render on top of good server markup" time="0.339">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML boolean with client render on top of bad server markup" time="0.124">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with server string render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with server string render" time="0.14">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with server stream render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with server stream render" time="0.069">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with clean client render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with clean client render" time="0.032">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with client render on top of good server markup" time="0.172">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML text string with client render on top of bad server markup" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with server string render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with server string render" time="0.048">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with server stream render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with server stream render" time="0.052">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with clean client render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with clean client render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with client render on top of good server markup" time="0.144">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML element string with client render on top of bad server markup" time="0.139">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with server string render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with server string render" time="0.105">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with server stream render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with server stream render" time="0.059">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with clean client render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with clean client render" time="0.095">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with client render on top of good server markup" time="0.149">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML object with client render on top of bad server markup" time="0.062">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with server string render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with server string render" time="0.075">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with server stream render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with server stream render" time="0.055">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with clean client render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with clean client render" time="0.079">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with client render on top of good server markup" time="0.121">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to null with client render on top of bad server markup" time="0.08">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with server string render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with server string render" time="0.101">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with server stream render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with server stream render" time="0.086">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with clean client render" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with clean client render" time="0.142">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with client render on top of good server markup" time="0.375">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a div with dangerouslySetInnerHTML set to undefined with client render on top of bad server markup" time="0.217">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a noscript with children with server string render" name="ReactDOMServerIntegration elements and children renders a noscript with children with server string render" time="0.165">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a noscript with children with server stream render" name="ReactDOMServerIntegration elements and children renders a noscript with children with server stream render" time="0.054">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a noscript with children with clean client render" name="ReactDOMServerIntegration elements and children renders a noscript with children with clean client render" time="0.056">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a noscript with children with client render on top of good server markup" name="ReactDOMServerIntegration elements and children renders a noscript with children with client render on top of good server markup" time="0.104">
    </testcase>
    <testcase classname="ReactDOMServerIntegration elements and children renders a noscript with children with client render on top of bad server markup" name="ReactDOMServerIntegration elements and children renders a noscript with children with client render on top of bad server markup" time="0.073">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-cache/src/__tests__/ReactCacheOld-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:46" time="1.016" tests="8">
    <testcase classname="ReactCache throws a promise if the requested value is not in the cache" name="ReactCache throws a promise if the requested value is not in the cache" time="0.08">
    </testcase>
    <testcase classname="ReactCache throws an error on the subsequent read if the promise is rejected" name="ReactCache throws an error on the subsequent read if the promise is rejected" time="0.051">
    </testcase>
    <testcase classname="ReactCache warns if non-primitive key is passed to a resource without a hash function" name="ReactCache warns if non-primitive key is passed to a resource without a hash function" time="0.059">
    </testcase>
    <testcase classname="ReactCache evicts least recently used values" name="ReactCache evicts least recently used values" time="0.05">
    </testcase>
    <testcase classname="ReactCache preloads during the render phase" name="ReactCache preloads during the render phase" time="0.056">
    </testcase>
    <testcase classname="ReactCache if a thenable resolves multiple times, does not update the first cached value" name="ReactCache if a thenable resolves multiple times, does not update the first cached value" time="0.082">
    </testcase>
    <testcase classname="ReactCache throws if read is called outside render" name="ReactCache throws if read is called outside render" time="0.025">
    </testcase>
    <testcase classname="ReactCache throws if preload is called outside render" name="ReactCache throws if preload is called outside render" time="0.055">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactCreateRef-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:47" time="0.517" tests="1">
    <testcase classname="ReactCreateRef should warn in dev if an invalid ref object is provided" name="ReactCreateRef should warn in dev if an invalid ref object is provided" time="0.173">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactES6Class-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:46" time="1.155" tests="29">
    <testcase classname="ReactES6Class preserves the name of the class for use in error messages" name="ReactES6Class preserves the name of the class for use in error messages" time="0.142">
    </testcase>
    <testcase classname="ReactES6Class throws if no render function is defined" name="ReactES6Class throws if no render function is defined" time="0.023">
    </testcase>
    <testcase classname="ReactES6Class renders a simple stateless component with prop" name="ReactES6Class renders a simple stateless component with prop" time="0.004">
    </testcase>
    <testcase classname="ReactES6Class renders based on state using initial values in this.props" name="ReactES6Class renders based on state using initial values in this.props" time="0.002">
    </testcase>
    <testcase classname="ReactES6Class renders based on state using props in the constructor" name="ReactES6Class renders based on state using props in the constructor" time="0.016">
    </testcase>
    <testcase classname="ReactES6Class sets initial state with value returned by static getDerivedStateFromProps" name="ReactES6Class sets initial state with value returned by static getDerivedStateFromProps" time="0.002">
    </testcase>
    <testcase classname="ReactES6Class warns if getDerivedStateFromProps is not static" name="ReactES6Class warns if getDerivedStateFromProps is not static" time="0.003">
    </testcase>
    <testcase classname="ReactES6Class warns if getDerivedStateFromError is not static" name="ReactES6Class warns if getDerivedStateFromError is not static" time="0.011">
    </testcase>
    <testcase classname="ReactES6Class warns if getSnapshotBeforeUpdate is static" name="ReactES6Class warns if getSnapshotBeforeUpdate is static" time="0.004">
    </testcase>
    <testcase classname="ReactES6Class warns if state not initialized before static getDerivedStateFromProps" name="ReactES6Class warns if state not initialized before static getDerivedStateFromProps" time="0.036">
    </testcase>
    <testcase classname="ReactES6Class updates initial state with values returned by static getDerivedStateFromProps" name="ReactES6Class updates initial state with values returned by static getDerivedStateFromProps" time="0.028">
    </testcase>
    <testcase classname="ReactES6Class renders updated state with values returned by static getDerivedStateFromProps" name="ReactES6Class renders updated state with values returned by static getDerivedStateFromProps" time="0.005">
    </testcase>
    <testcase classname="ReactES6Class renders based on context in the constructor" name="ReactES6Class renders based on context in the constructor" time="0.003">
    </testcase>
    <testcase classname="ReactES6Class renders only once when setting state in componentWillMount" name="ReactES6Class renders only once when setting state in componentWillMount" time="0.002">
    </testcase>
    <testcase classname="ReactES6Class should warn with non-object in the initial state property" name="ReactES6Class should warn with non-object in the initial state property" time="0.032">
    </testcase>
    <testcase classname="ReactES6Class should render with null in the initial state property" name="ReactES6Class should render with null in the initial state property" time="0.003">
    </testcase>
    <testcase classname="ReactES6Class setState through an event handler" name="ReactES6Class setState through an event handler" time="0.003">
    </testcase>
    <testcase classname="ReactES6Class should not implicitly bind event handlers" name="ReactES6Class should not implicitly bind event handlers" time="0.018">
    </testcase>
    <testcase classname="ReactES6Class renders using forceUpdate even when there is no state" name="ReactES6Class renders using forceUpdate even when there is no state" time="0.006">
    </testcase>
    <testcase classname="ReactES6Class will call all the normal life cycle methods" name="ReactES6Class will call all the normal life cycle methods" time="0.032">
    </testcase>
    <testcase classname="ReactES6Class warns when classic properties are defined on the instance, but does not invoke them." name="ReactES6Class warns when classic properties are defined on the instance, but does not invoke them." time="0.017">
    </testcase>
    <testcase classname="ReactES6Class does not warn about getInitialState() on class components if state is also defined." name="ReactES6Class does not warn about getInitialState() on class components if state is also defined." time="0.004">
    </testcase>
    <testcase classname="ReactES6Class should warn when misspelling shouldComponentUpdate" name="ReactES6Class should warn when misspelling shouldComponentUpdate" time="0.015">
    </testcase>
    <testcase classname="ReactES6Class should warn when misspelling componentWillReceiveProps" name="ReactES6Class should warn when misspelling componentWillReceiveProps" time="0.035">
    </testcase>
    <testcase classname="ReactES6Class should warn when misspelling UNSAFE_componentWillReceiveProps" name="ReactES6Class should warn when misspelling UNSAFE_componentWillReceiveProps" time="0.023">
    </testcase>
    <testcase classname="ReactES6Class should throw AND warn when trying to access classic APIs" name="ReactES6Class should throw AND warn when trying to access classic APIs" time="0.055">
    </testcase>
    <testcase classname="ReactES6Class supports this.context passed via getChildContext" name="ReactES6Class supports this.context passed via getChildContext" time="0.004">
    </testcase>
    <testcase classname="ReactES6Class supports classic refs" name="ReactES6Class supports classic refs" time="0.003">
    </testcase>
    <testcase classname="ReactES6Class supports drilling through to the DOM using findDOMNode" name="ReactES6Class supports drilling through to the DOM using findDOMNode" time="0.015">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactElementJSX-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:47" time="2.14" tests="18">
    <testcase classname="ReactElement.jsx allows static methods to be called using the type property" name="ReactElement.jsx allows static methods to be called using the type property" time="0.167">
    </testcase>
    <testcase classname="ReactElement.jsx identifies valid elements" name="ReactElement.jsx identifies valid elements" time="0.038">
    </testcase>
    <testcase classname="ReactElement.jsx is indistinguishable from a plain object" name="ReactElement.jsx is indistinguishable from a plain object" time="0.067">
    </testcase>
    <testcase classname="ReactElement.jsx should use default prop value when removing a prop" name="ReactElement.jsx should use default prop value when removing a prop" time="0.046">
    </testcase>
    <testcase classname="ReactElement.jsx should normalize props with default values" name="ReactElement.jsx should normalize props with default values" time="0.07">
    </testcase>
    <testcase classname="ReactElement.jsx throws when changing a prop (in dev) after element creation" name="ReactElement.jsx throws when changing a prop (in dev) after element creation" time="0.073">
    </testcase>
    <testcase classname="ReactElement.jsx throws when adding a prop (in dev) after element creation" name="ReactElement.jsx throws when adding a prop (in dev) after element creation" time="0.106">
    </testcase>
    <testcase classname="ReactElement.jsx does not warn for NaN props" name="ReactElement.jsx does not warn for NaN props" time="0.045">
    </testcase>
    <testcase classname="ReactElement.jsx should warn when `key` is being accessed on composite element" name="ReactElement.jsx should warn when `key` is being accessed on composite element" time="0.068">
    </testcase>
    <testcase classname="ReactElement.jsx warns when a jsxs is passed something that is not an array" name="ReactElement.jsx warns when a jsxs is passed something that is not an array" time="0.051">
    </testcase>
    <testcase classname="ReactElement.jsx should warn when `key` is being accessed on a host element" name="ReactElement.jsx should warn when `key` is being accessed on a host element" time="0.061">
    </testcase>
    <testcase classname="ReactElement.jsx should warn when `ref` is being accessed" name="ReactElement.jsx should warn when `ref` is being accessed" time="0.068">
    </testcase>
    <testcase classname="ReactElement.jsx [GATED, SHOULD FAIL] identifies elements, but not JSON, if Symbols are supported" name="ReactElement.jsx [GATED, SHOULD FAIL] identifies elements, but not JSON, if Symbols are supported" time="0.133">
    </testcase>
    <testcase classname="ReactElement.jsx identifies elements, but not JSON, if Symbols are polyfilled" name="ReactElement.jsx identifies elements, but not JSON, if Symbols are polyfilled" time="0.126">
    </testcase>
    <testcase classname="ReactElement.jsx should warn when unkeyed children are passed to jsx" name="ReactElement.jsx should warn when unkeyed children are passed to jsx" time="0.135">
    </testcase>
    <testcase classname="ReactElement.jsx should warn when keys are passed as part of props" name="ReactElement.jsx should warn when keys are passed as part of props" time="0.104">
    </testcase>
    <testcase classname="ReactElement.jsx should not warn when unkeyed children are passed to jsxs" name="ReactElement.jsx should not warn when unkeyed children are passed to jsxs" time="0.04">
    </testcase>
    <testcase classname="ReactElement.jsx does not call lazy initializers eagerly" name="ReactElement.jsx does not call lazy initializers eagerly" time="0.127">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactCoffeeScriptClass-test.coffee" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:48" time="1.465" tests="29">
    <testcase classname="ReactCoffeeScriptClass preserves the name of the class for use in error messages" name="ReactCoffeeScriptClass preserves the name of the class for use in error messages" time="0.121">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass throws if no render function is defined" name="ReactCoffeeScriptClass throws if no render function is defined" time="0.051">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass renders a simple stateless component with prop" name="ReactCoffeeScriptClass renders a simple stateless component with prop" time="0.006">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass renders based on state using initial values in this.props" name="ReactCoffeeScriptClass renders based on state using initial values in this.props" time="0.003">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass renders based on state using props in the constructor" name="ReactCoffeeScriptClass renders based on state using props in the constructor" time="0.004">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass sets initial state with value returned by static getDerivedStateFromProps" name="ReactCoffeeScriptClass sets initial state with value returned by static getDerivedStateFromProps" time="0.003">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass warns if getDerivedStateFromProps is not static" name="ReactCoffeeScriptClass warns if getDerivedStateFromProps is not static" time="0.002">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass warns if getDerivedStateFromError is not static" name="ReactCoffeeScriptClass warns if getDerivedStateFromError is not static" time="0.003">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass warns if getSnapshotBeforeUpdate is static" name="ReactCoffeeScriptClass warns if getSnapshotBeforeUpdate is static" time="0.014">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass warns if state not initialized before static getDerivedStateFromProps" name="ReactCoffeeScriptClass warns if state not initialized before static getDerivedStateFromProps" time="0.003">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass updates initial state with values returned by static getDerivedStateFromProps" name="ReactCoffeeScriptClass updates initial state with values returned by static getDerivedStateFromProps" time="0.003">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass renders updated state with values returned by static getDerivedStateFromProps" name="ReactCoffeeScriptClass renders updated state with values returned by static getDerivedStateFromProps" time="0.016">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass renders based on context in the constructor" name="ReactCoffeeScriptClass renders based on context in the constructor" time="0.002">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass renders only once when setting state in componentWillMount" name="ReactCoffeeScriptClass renders only once when setting state in componentWillMount" time="0.002">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass should warn with non-object in the initial state property" name="ReactCoffeeScriptClass should warn with non-object in the initial state property" time="0.036">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass should render with null in the initial state property" name="ReactCoffeeScriptClass should render with null in the initial state property" time="0.006">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass setState through an event handler" name="ReactCoffeeScriptClass setState through an event handler" time="0.005">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass should not implicitly bind event handlers" name="ReactCoffeeScriptClass should not implicitly bind event handlers" time="0.002">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass renders using forceUpdate even when there is no state" name="ReactCoffeeScriptClass renders using forceUpdate even when there is no state" time="0.002">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass will call all the normal life cycle methods" name="ReactCoffeeScriptClass will call all the normal life cycle methods" time="0.034">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass warns when classic properties are defined on the instance, but does not invoke them." name="ReactCoffeeScriptClass warns when classic properties are defined on the instance, but does not invoke them." time="0.005">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass does not warn about getInitialState() on class components if state is also defined." name="ReactCoffeeScriptClass does not warn about getInitialState() on class components if state is also defined." time="0.002">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass should warn when misspelling shouldComponentUpdate" name="ReactCoffeeScriptClass should warn when misspelling shouldComponentUpdate" time="0.003">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass should warn when misspelling componentWillReceiveProps" name="ReactCoffeeScriptClass should warn when misspelling componentWillReceiveProps" time="0.023">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass should warn when misspelling UNSAFE_componentWillReceiveProps" name="ReactCoffeeScriptClass should warn when misspelling UNSAFE_componentWillReceiveProps" time="0.003">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass should throw AND warn when trying to access classic APIs" name="ReactCoffeeScriptClass should throw AND warn when trying to access classic APIs" time="0.002">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass supports this.context passed via getChildContext" name="ReactCoffeeScriptClass supports this.context passed via getChildContext" time="0.002">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass supports classic refs" name="ReactCoffeeScriptClass supports classic refs" time="0.013">
    </testcase>
    <testcase classname="ReactCoffeeScriptClass supports drilling through to the DOM using findDOMNode" name="ReactCoffeeScriptClass supports drilling through to the DOM using findDOMNode" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactJSXElement-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:48" time="2.08" tests="17">
    <testcase classname="ReactJSXElement returns a complete element according to spec" name="ReactJSXElement returns a complete element according to spec" time="0.115">
    </testcase>
    <testcase classname="ReactJSXElement allows a lower-case to be passed as the string type" name="ReactJSXElement allows a lower-case to be passed as the string type" time="0.081">
    </testcase>
    <testcase classname="ReactJSXElement allows a string to be passed as the type" name="ReactJSXElement allows a string to be passed as the type" time="0.049">
    </testcase>
    <testcase classname="ReactJSXElement returns an immutable element" name="ReactJSXElement returns an immutable element" time="0.07">
    </testcase>
    <testcase classname="ReactJSXElement does not reuse the object that is spread into props" name="ReactJSXElement does not reuse the object that is spread into props" time="0.078">
    </testcase>
    <testcase classname="ReactJSXElement extracts key and ref from the rest of the props" name="ReactJSXElement extracts key and ref from the rest of the props" time="0.058">
    </testcase>
    <testcase classname="ReactJSXElement coerces the key to a string" name="ReactJSXElement coerces the key to a string" time="0.077">
    </testcase>
    <testcase classname="ReactJSXElement merges JSX children onto the children prop" name="ReactJSXElement merges JSX children onto the children prop" time="0.065">
    </testcase>
    <testcase classname="ReactJSXElement does not override children if no JSX children are provided" name="ReactJSXElement does not override children if no JSX children are provided" time="0.045">
    </testcase>
    <testcase classname="ReactJSXElement overrides children if null is provided as a JSX child" name="ReactJSXElement overrides children if null is provided as a JSX child" time="0.046">
    </testcase>
    <testcase classname="ReactJSXElement overrides children if undefined is provided as an argument" name="ReactJSXElement overrides children if undefined is provided as an argument" time="0.087">
    </testcase>
    <testcase classname="ReactJSXElement merges JSX children onto the children prop in an array" name="ReactJSXElement merges JSX children onto the children prop in an array" time="0.062">
    </testcase>
    <testcase classname="ReactJSXElement allows static methods to be called using the type property" name="ReactJSXElement allows static methods to be called using the type property" time="0.048">
    </testcase>
    <testcase classname="ReactJSXElement identifies valid elements" name="ReactJSXElement identifies valid elements" time="0.047">
    </testcase>
    <testcase classname="ReactJSXElement is indistinguishable from a plain object" name="ReactJSXElement is indistinguishable from a plain object" time="0.029">
    </testcase>
    <testcase classname="ReactJSXElement should use default prop value when removing a prop" name="ReactJSXElement should use default prop value when removing a prop" time="0.041">
    </testcase>
    <testcase classname="ReactJSXElement should normalize props with default values" name="ReactJSXElement should normalize props with default values" time="0.061">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactVersion-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:50" time="0.222" tests="1">
    <testcase classname=" ReactVersion matches package.json" name=" ReactVersion matches package.json" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactJSXElementValidator-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:48" time="2.569" tests="23">
    <testcase classname="ReactJSXElementValidator warns for keys for arrays of elements in children position" name="ReactJSXElementValidator warns for keys for arrays of elements in children position" time="0.106">
    </testcase>
    <testcase classname="ReactJSXElementValidator warns for keys for arrays of elements with owner info" name="ReactJSXElementValidator warns for keys for arrays of elements with owner info" time="0.142">
    </testcase>
    <testcase classname="ReactJSXElementValidator warns for keys for iterables of elements in rest args" name="ReactJSXElementValidator warns for keys for iterables of elements in rest args" time="0.032">
    </testcase>
    <testcase classname="ReactJSXElementValidator does not warn for arrays of elements with keys" name="ReactJSXElementValidator does not warn for arrays of elements with keys" time="0.084">
    </testcase>
    <testcase classname="ReactJSXElementValidator does not warn for iterable elements with keys" name="ReactJSXElementValidator does not warn for iterable elements with keys" time="0.06">
    </testcase>
    <testcase classname="ReactJSXElementValidator does not warn for numeric keys in entry iterable as a child" name="ReactJSXElementValidator does not warn for numeric keys in entry iterable as a child" time="0.048">
    </testcase>
    <testcase classname="ReactJSXElementValidator does not warn when the element is directly as children" name="ReactJSXElementValidator does not warn when the element is directly as children" time="0.093">
    </testcase>
    <testcase classname="ReactJSXElementValidator does not warn when the child array contains non-elements" name="ReactJSXElementValidator does not warn when the child array contains non-elements" time="0.067">
    </testcase>
    <testcase classname="ReactJSXElementValidator should give context for PropType errors in nested components." name="ReactJSXElementValidator should give context for PropType errors in nested components." time="0.082">
    </testcase>
    <testcase classname="ReactJSXElementValidator should update component stack after receiving next element" name="ReactJSXElementValidator should update component stack after receiving next element" time="0.096">
    </testcase>
    <testcase classname="ReactJSXElementValidator gives a helpful error when passing null, undefined, or boolean" name="ReactJSXElementValidator gives a helpful error when passing null, undefined, or boolean" time="0.046">
    </testcase>
    <testcase classname="ReactJSXElementValidator should check default prop values" name="ReactJSXElementValidator should check default prop values" time="0.047">
    </testcase>
    <testcase classname="ReactJSXElementValidator should not check the default for explicit null" name="ReactJSXElementValidator should not check the default for explicit null" time="0.052">
    </testcase>
    <testcase classname="ReactJSXElementValidator should check declared prop types" name="ReactJSXElementValidator should check declared prop types" time="0.041">
    </testcase>
    <testcase classname="ReactJSXElementValidator should warn on invalid prop types" name="ReactJSXElementValidator should warn on invalid prop types" time="0.069">
    </testcase>
    <testcase classname="ReactJSXElementValidator should warn on invalid context types" name="ReactJSXElementValidator should warn on invalid context types" time="0.045">
    </testcase>
    <testcase classname="ReactJSXElementValidator should warn if getDefaultProps is specified on the class" name="ReactJSXElementValidator should warn if getDefaultProps is specified on the class" time="0.048">
    </testcase>
    <testcase classname="ReactJSXElementValidator should warn if component declares PropTypes instead of propTypes" name="ReactJSXElementValidator should warn if component declares PropTypes instead of propTypes" time="0.034">
    </testcase>
    <testcase classname="ReactJSXElementValidator warns for fragments with illegal attributes" name="ReactJSXElementValidator warns for fragments with illegal attributes" time="0.035">
    </testcase>
    <testcase classname="ReactJSXElementValidator warns for fragments with refs" name="ReactJSXElementValidator warns for fragments with refs" time="0.055">
    </testcase>
    <testcase classname="ReactJSXElementValidator does not warn for fragments of multiple elements without keys" name="ReactJSXElementValidator does not warn for fragments of multiple elements without keys" time="0.043">
    </testcase>
    <testcase classname="ReactJSXElementValidator warns for fragments of multiple elements with same key" name="ReactJSXElementValidator warns for fragments of multiple elements with same key" time="0.059">
    </testcase>
    <testcase classname="ReactJSXElementValidator does not call lazy initializers eagerly" name="ReactJSXElementValidator does not call lazy initializers eagerly" time="0.072">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactContextValidator-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:50" time="1.518" tests="18">
    <testcase classname="ReactContextValidator should filter out context not in contextTypes" name="ReactContextValidator should filter out context not in contextTypes" time="0.105">
    </testcase>
    <testcase classname="ReactContextValidator should pass next context to lifecycles" name="ReactContextValidator should pass next context to lifecycles" time="0.035">
    </testcase>
    <testcase classname="ReactContextValidator should check context types" name="ReactContextValidator should check context types" time="0.068">
    </testcase>
    <testcase classname="ReactContextValidator should check child context types" name="ReactContextValidator should check child context types" time="0.069">
    </testcase>
    <testcase classname="ReactContextValidator warns of incorrect prop types on context provider" name="ReactContextValidator warns of incorrect prop types on context provider" time="0.068">
    </testcase>
    <testcase classname="ReactContextValidator should warn (but not error) if getChildContext method is missing" name="ReactContextValidator should warn (but not error) if getChildContext method is missing" time="0.076">
    </testcase>
    <testcase classname="ReactContextValidator should pass parent context if getChildContext method is missing" name="ReactContextValidator should pass parent context if getChildContext method is missing" time="0.051">
    </testcase>
    <testcase classname="ReactContextValidator should pass next context to lifecycles" name="ReactContextValidator should pass next context to lifecycles" time="0.07">
    </testcase>
    <testcase classname="ReactContextValidator should re-render PureComponents when context Provider updates" name="ReactContextValidator should re-render PureComponents when context Provider updates" time="0.036">
    </testcase>
    <testcase classname="ReactContextValidator should warn if both contextType and contextTypes are defined" name="ReactContextValidator should warn if both contextType and contextTypes are defined" time="0.088">
    </testcase>
    <testcase classname="ReactContextValidator should warn if an invalid contextType is defined" name="ReactContextValidator should warn if an invalid contextType is defined" time="0.043">
    </testcase>
    <testcase classname="ReactContextValidator should not warn when class contextType is null" name="ReactContextValidator should not warn when class contextType is null" time="0.056">
    </testcase>
    <testcase classname="ReactContextValidator should warn when class contextType is undefined" name="ReactContextValidator should warn when class contextType is undefined" time="0.045">
    </testcase>
    <testcase classname="ReactContextValidator should warn when class contextType is an object" name="ReactContextValidator should warn when class contextType is an object" time="0.045">
    </testcase>
    <testcase classname="ReactContextValidator should warn when class contextType is a primitive" name="ReactContextValidator should warn when class contextType is a primitive" time="0.065">
    </testcase>
    <testcase classname="ReactContextValidator should warn if you define contextType on a function component" name="ReactContextValidator should warn if you define contextType on a function component" time="0.04">
    </testcase>
    <testcase classname="ReactContextValidator should honor a displayName if set on the context type" name="ReactContextValidator should honor a displayName if set on the context type" time="0.067">
    </testcase>
    <testcase classname="ReactContextValidator warns if displayName is set on the consumer type" name="ReactContextValidator warns if displayName is set on the consumer type" time="0.033">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/forwardRef-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:51" time="1.425" tests="20">
    <testcase classname="forwardRef should update refs when switching between children" name="forwardRef should update refs when switching between children" time="0.079">
    </testcase>
    <testcase classname="forwardRef should support rendering null" name="forwardRef should support rendering null" time="0.025">
    </testcase>
    <testcase classname="forwardRef should support rendering null for multiple children" name="forwardRef should support rendering null for multiple children" time="0.024">
    </testcase>
    <testcase classname="forwardRef should support propTypes and defaultProps" name="forwardRef should support propTypes and defaultProps" time="0.028">
    </testcase>
    <testcase classname="forwardRef should warn if not provided a callback during creation" name="forwardRef should warn if not provided a callback during creation" time="0.041">
    </testcase>
    <testcase classname="forwardRef should warn if no render function is provided" name="forwardRef should warn if no render function is provided" time="0.022">
    </testcase>
    <testcase classname="forwardRef should warn if the render function provided has propTypes or defaultProps attributes" name="forwardRef should warn if the render function provided has propTypes or defaultProps attributes" time="0.046">
    </testcase>
    <testcase classname="forwardRef should not warn if the render function provided does not use any parameter" name="forwardRef should not warn if the render function provided does not use any parameter" time="0.028">
    </testcase>
    <testcase classname="forwardRef should warn if the render function provided does not use the forwarded ref parameter" name="forwardRef should warn if the render function provided does not use the forwarded ref parameter" time="0.041">
    </testcase>
    <testcase classname="forwardRef should not warn if the render function provided use exactly two parameters" name="forwardRef should not warn if the render function provided use exactly two parameters" time="0.045">
    </testcase>
    <testcase classname="forwardRef should warn if the render function provided expects to use more than two parameters" name="forwardRef should warn if the render function provided expects to use more than two parameters" time="0.038">
    </testcase>
    <testcase classname="forwardRef should fall back to showing something meaningful if no displayName or name are present" name="forwardRef should fall back to showing something meaningful if no displayName or name are present" time="0.041">
    </testcase>
    <testcase classname="forwardRef should honor a displayName if set on the forwardRef wrapper in warnings" name="forwardRef should honor a displayName if set on the forwardRef wrapper in warnings" time="0.037">
    </testcase>
    <testcase classname="forwardRef should pass displayName to an anonymous inner component so it shows up in component stacks" name="forwardRef should pass displayName to an anonymous inner component so it shows up in component stacks" time="0.054">
    </testcase>
    <testcase classname="forwardRef should honor a displayName in stacks if set on the inner function" name="forwardRef should honor a displayName in stacks if set on the inner function" time="0.024">
    </testcase>
    <testcase classname="forwardRef should honor a outer displayName when wrapped component and memo component set displayName at the same time." name="forwardRef should honor a outer displayName when wrapped component and memo component set displayName at the same time." time="0.053">
    </testcase>
    <testcase classname="forwardRef should not bailout if forwardRef is not wrapped in memo" name="forwardRef should not bailout if forwardRef is not wrapped in memo" time="0.1">
    </testcase>
    <testcase classname="forwardRef should bailout if forwardRef is wrapped in memo" name="forwardRef should bailout if forwardRef is wrapped in memo" time="0.07">
    </testcase>
    <testcase classname="forwardRef should custom memo comparisons to compose" name="forwardRef should custom memo comparisons to compose" time="0.092">
    </testcase>
    <testcase classname="forwardRef warns on forwardRef(memo(...))" name="forwardRef warns on forwardRef(memo(...))" time="0.089">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactChildren-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:50" time="2.777" tests="33">
    <testcase classname="ReactChildren should support identity for simple" name="ReactChildren should support identity for simple" time="0.074">
    </testcase>
    <testcase classname="ReactChildren should support Portal components" name="ReactChildren should support Portal components" time="0.057">
    </testcase>
    <testcase classname="ReactChildren should treat single arrayless child as being in array" name="ReactChildren should treat single arrayless child as being in array" time="0.066">
    </testcase>
    <testcase classname="ReactChildren should treat single child in array as expected" name="ReactChildren should treat single child in array as expected" time="0.058">
    </testcase>
    <testcase classname="ReactChildren should be called for each child" name="ReactChildren should be called for each child" time="0.046">
    </testcase>
    <testcase classname="ReactChildren should traverse children of different kinds" name="ReactChildren should traverse children of different kinds" time="0.102">
    </testcase>
    <testcase classname="ReactChildren should be called for each child in nested structure" name="ReactChildren should be called for each child in nested structure" time="0.082">
    </testcase>
    <testcase classname="ReactChildren should retain key across two mappings" name="ReactChildren should retain key across two mappings" time="0.093">
    </testcase>
    <testcase classname="ReactChildren should be called for each child in an iterable without keys" name="ReactChildren should be called for each child in an iterable without keys" time="0.189">
    </testcase>
    <testcase classname="ReactChildren should be called for each child in an iterable with keys" name="ReactChildren should be called for each child in an iterable with keys" time="0.163">
    </testcase>
    <testcase classname="ReactChildren should not enumerate enumerable numbers (#4776)" name="ReactChildren should not enumerate enumerable numbers (#4776)" time="0.062">
    </testcase>
    <testcase classname="ReactChildren should allow extension of native prototypes" name="ReactChildren should allow extension of native prototypes" time="0.041">
    </testcase>
    <testcase classname="ReactChildren should pass key to returned component" name="ReactChildren should pass key to returned component" time="0.054">
    </testcase>
    <testcase classname="ReactChildren should invoke callback with the right context" name="ReactChildren should invoke callback with the right context" time="0.045">
    </testcase>
    <testcase classname="ReactChildren should be called for each child" name="ReactChildren should be called for each child" time="0.056">
    </testcase>
    <testcase classname="ReactChildren should be called for each child in nested structure" name="ReactChildren should be called for each child in nested structure" time="0.078">
    </testcase>
    <testcase classname="ReactChildren should retain key across two mappings" name="ReactChildren should retain key across two mappings" time="0.03">
    </testcase>
    <testcase classname="ReactChildren should not throw if key provided is a dupe with array key" name="ReactChildren should not throw if key provided is a dupe with array key" time="0.081">
    </testcase>
    <testcase classname="ReactChildren should use the same key for a cloned element" name="ReactChildren should use the same key for a cloned element" time="0.064">
    </testcase>
    <testcase classname="ReactChildren should use the same key for a cloned element with key" name="ReactChildren should use the same key for a cloned element with key" time="0.046">
    </testcase>
    <testcase classname="ReactChildren should return 0 for null children" name="ReactChildren should return 0 for null children" time="0.039">
    </testcase>
    <testcase classname="ReactChildren should return 0 for undefined children" name="ReactChildren should return 0 for undefined children" time="0.065">
    </testcase>
    <testcase classname="ReactChildren should return 1 for single child" name="ReactChildren should return 1 for single child" time="0.047">
    </testcase>
    <testcase classname="ReactChildren should count the number of children in flat structure" name="ReactChildren should count the number of children in flat structure" time="0.052">
    </testcase>
    <testcase classname="ReactChildren should count the number of children in nested structure" name="ReactChildren should count the number of children in nested structure" time="0.032">
    </testcase>
    <testcase classname="ReactChildren should flatten children to an array" name="ReactChildren should flatten children to an array" time="0.059">
    </testcase>
    <testcase classname="ReactChildren should escape keys" name="ReactChildren should escape keys" time="0.051">
    </testcase>
    <testcase classname="ReactChildren should combine keys when map returns an array" name="ReactChildren should combine keys when map returns an array" time="0.048">
    </testcase>
    <testcase classname="ReactChildren should throw on object" name="ReactChildren should throw on object" time="0.037">
    </testcase>
    <testcase classname="ReactChildren should throw on regex" name="ReactChildren should throw on regex" time="0.041">
    </testcase>
    <testcase classname="ReactChildren with fragments enabled warns for keys for arrays of elements in a fragment" name="ReactChildren with fragments enabled warns for keys for arrays of elements in a fragment" time="0.048">
    </testcase>
    <testcase classname="ReactChildren with fragments enabled does not warn when there are keys on elements in a fragment" name="ReactChildren with fragments enabled does not warn when there are keys on elements in a fragment" time="0.047">
    </testcase>
    <testcase classname="ReactChildren with fragments enabled warns for keys for arrays at the top level" name="ReactChildren with fragments enabled warns for keys for arrays at the top level" time="0.099">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactElement-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:51" time="2.387" tests="29">
    <testcase classname="ReactElement uses the fallback value when in an environment without Symbol" name="ReactElement uses the fallback value when in an environment without Symbol" time="0.082">
    </testcase>
    <testcase classname="ReactElement returns a complete element according to spec" name="ReactElement returns a complete element according to spec" time="0.043">
    </testcase>
    <testcase classname="ReactElement should warn when `key` is being accessed on composite element" name="ReactElement should warn when `key` is being accessed on composite element" time="0.074">
    </testcase>
    <testcase classname="ReactElement should warn when `key` is being accessed on a host element" name="ReactElement should warn when `key` is being accessed on a host element" time="0.055">
    </testcase>
    <testcase classname="ReactElement should warn when `ref` is being accessed" name="ReactElement should warn when `ref` is being accessed" time="0.035">
    </testcase>
    <testcase classname="ReactElement allows a string to be passed as the type" name="ReactElement allows a string to be passed as the type" time="0.092">
    </testcase>
    <testcase classname="ReactElement returns an immutable element" name="ReactElement returns an immutable element" time="0.041">
    </testcase>
    <testcase classname="ReactElement does not reuse the original config object" name="ReactElement does not reuse the original config object" time="0.056">
    </testcase>
    <testcase classname="ReactElement does not fail if config has no prototype" name="ReactElement does not fail if config has no prototype" time="0.021">
    </testcase>
    <testcase classname="ReactElement extracts key and ref from the config" name="ReactElement extracts key and ref from the config" time="0.049">
    </testcase>
    <testcase classname="ReactElement extracts null key and ref" name="ReactElement extracts null key and ref" time="0.043">
    </testcase>
    <testcase classname="ReactElement ignores undefined key and ref" name="ReactElement ignores undefined key and ref" time="0.089">
    </testcase>
    <testcase classname="ReactElement ignores key and ref warning getters" name="ReactElement ignores key and ref warning getters" time="0.057">
    </testcase>
    <testcase classname="ReactElement coerces the key to a string" name="ReactElement coerces the key to a string" time="0.051">
    </testcase>
    <testcase classname="ReactElement preserves the owner on the element" name="ReactElement preserves the owner on the element" time="0.079">
    </testcase>
    <testcase classname="ReactElement merges an additional argument onto the children prop" name="ReactElement merges an additional argument onto the children prop" time="0.048">
    </testcase>
    <testcase classname="ReactElement does not override children if no rest args are provided" name="ReactElement does not override children if no rest args are provided" time="0.056">
    </testcase>
    <testcase classname="ReactElement overrides children if null is provided as an argument" name="ReactElement overrides children if null is provided as an argument" time="0.028">
    </testcase>
    <testcase classname="ReactElement merges rest arguments onto the children prop in an array" name="ReactElement merges rest arguments onto the children prop in an array" time="0.06">
    </testcase>
    <testcase classname="ReactElement allows static methods to be called using the type property" name="ReactElement allows static methods to be called using the type property" time="0.051">
    </testcase>
    <testcase classname="ReactElement identifies valid elements" name="ReactElement identifies valid elements" time="0.038">
    </testcase>
    <testcase classname="ReactElement is indistinguishable from a plain object" name="ReactElement is indistinguishable from a plain object" time="0.048">
    </testcase>
    <testcase classname="ReactElement should use default prop value when removing a prop" name="ReactElement should use default prop value when removing a prop" time="0.047">
    </testcase>
    <testcase classname="ReactElement should normalize props with default values" name="ReactElement should normalize props with default values" time="0.028">
    </testcase>
    <testcase classname="ReactElement throws when changing a prop (in dev) after element creation" name="ReactElement throws when changing a prop (in dev) after element creation" time="0.076">
    </testcase>
    <testcase classname="ReactElement throws when adding a prop (in dev) after element creation" name="ReactElement throws when adding a prop (in dev) after element creation" time="0.044">
    </testcase>
    <testcase classname="ReactElement does not warn for NaN props" name="ReactElement does not warn for NaN props" time="0.039">
    </testcase>
    <testcase classname="ReactElement [GATED, SHOULD FAIL] identifies elements, but not JSON, if Symbols are supported" name="ReactElement [GATED, SHOULD FAIL] identifies elements, but not JSON, if Symbols are supported" time="0.057">
    </testcase>
    <testcase classname="ReactElement identifies elements, but not JSON, if Symbols are supported (with polyfill)" name="ReactElement identifies elements, but not JSON, if Symbols are supported (with polyfill)" time="0.13">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactElementClone-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:53" time="0.575" tests="23">
    <testcase classname="ReactElementClone should clone a DOM component with new props" name="ReactElementClone should clone a DOM component with new props" time="0.077">
    </testcase>
    <testcase classname="ReactElementClone should clone a composite component with new props" name="ReactElementClone should clone a composite component with new props" time="0.002">
    </testcase>
    <testcase classname="ReactElementClone does not fail if config has no prototype" name="ReactElementClone does not fail if config has no prototype" time="0">
    </testcase>
    <testcase classname="ReactElementClone should keep the original ref if it is not overridden" name="ReactElementClone should keep the original ref if it is not overridden" time="0.019">
    </testcase>
    <testcase classname="ReactElementClone should transfer the key property" name="ReactElementClone should transfer the key property" time="0.001">
    </testcase>
    <testcase classname="ReactElementClone should transfer children" name="ReactElementClone should transfer children" time="0.001">
    </testcase>
    <testcase classname="ReactElementClone should shallow clone children" name="ReactElementClone should shallow clone children" time="0.002">
    </testcase>
    <testcase classname="ReactElementClone should accept children as rest arguments" name="ReactElementClone should accept children as rest arguments" time="0.001">
    </testcase>
    <testcase classname="ReactElementClone should override children if undefined is provided as an argument" name="ReactElementClone should override children if undefined is provided as an argument" time="0">
    </testcase>
    <testcase classname="ReactElementClone should support keys and refs" name="ReactElementClone should support keys and refs" time="0.002">
    </testcase>
    <testcase classname="ReactElementClone should steal the ref if a new ref is specified" name="ReactElementClone should steal the ref if a new ref is specified" time="0.009">
    </testcase>
    <testcase classname="ReactElementClone should overwrite props" name="ReactElementClone should overwrite props" time="0.002">
    </testcase>
    <testcase classname="ReactElementClone should normalize props with default values" name="ReactElementClone should normalize props with default values" time="0">
    </testcase>
    <testcase classname="ReactElementClone warns for keys for arrays of elements in rest args" name="ReactElementClone warns for keys for arrays of elements in rest args" time="0.002">
    </testcase>
    <testcase classname="ReactElementClone does not warns for arrays of elements with keys" name="ReactElementClone does not warns for arrays of elements with keys" time="0.001">
    </testcase>
    <testcase classname="ReactElementClone does not warn when the element is directly in rest args" name="ReactElementClone does not warn when the element is directly in rest args" time="0">
    </testcase>
    <testcase classname="ReactElementClone does not warn when the array contains a non-element" name="ReactElementClone does not warn when the array contains a non-element" time="0">
    </testcase>
    <testcase classname="ReactElementClone should check declared prop types after clone" name="ReactElementClone should check declared prop types after clone" time="0.016">
    </testcase>
    <testcase classname="ReactElementClone should ignore key and ref warning getters" name="ReactElementClone should ignore key and ref warning getters" time="0">
    </testcase>
    <testcase classname="ReactElementClone should ignore undefined key and ref" name="ReactElementClone should ignore undefined key and ref" time="0.002">
    </testcase>
    <testcase classname="ReactElementClone should extract null key and ref" name="ReactElementClone should extract null key and ref" time="0.001">
    </testcase>
    <testcase classname="ReactElementClone throws an error if passed null" name="ReactElementClone throws an error if passed null" time="0.001">
    </testcase>
    <testcase classname="ReactElementClone throws an error if passed undefined" name="ReactElementClone throws an error if passed undefined" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactElementValidator-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:52" time="1.872" tests="25">
    <testcase classname="ReactElementValidator warns for keys for arrays of elements in rest args" name="ReactElementValidator warns for keys for arrays of elements in rest args" time="0.068">
    </testcase>
    <testcase classname="ReactElementValidator warns for keys for arrays of elements with owner info" name="ReactElementValidator warns for keys for arrays of elements with owner info" time="0.082">
    </testcase>
    <testcase classname="ReactElementValidator warns for keys for arrays with no owner or parent info" name="ReactElementValidator warns for keys for arrays with no owner or parent info" time="0.072">
    </testcase>
    <testcase classname="ReactElementValidator warns for keys for arrays of elements with no owner info" name="ReactElementValidator warns for keys for arrays of elements with no owner info" time="0.088">
    </testcase>
    <testcase classname="ReactElementValidator warns for keys with component stack info" name="ReactElementValidator warns for keys with component stack info" time="0.084">
    </testcase>
    <testcase classname="ReactElementValidator does not warn for keys when passing children down" name="ReactElementValidator does not warn for keys when passing children down" time="0.07">
    </testcase>
    <testcase classname="ReactElementValidator warns for keys for iterables of elements in rest args" name="ReactElementValidator warns for keys for iterables of elements in rest args" time="0.043">
    </testcase>
    <testcase classname="ReactElementValidator does not warns for arrays of elements with keys" name="ReactElementValidator does not warns for arrays of elements with keys" time="0.063">
    </testcase>
    <testcase classname="ReactElementValidator does not warns for iterable elements with keys" name="ReactElementValidator does not warns for iterable elements with keys" time="0.034">
    </testcase>
    <testcase classname="ReactElementValidator does not warn when the element is directly in rest args" name="ReactElementValidator does not warn when the element is directly in rest args" time="0.04">
    </testcase>
    <testcase classname="ReactElementValidator does not warn when the array contains a non-element" name="ReactElementValidator does not warn when the array contains a non-element" time="0.042">
    </testcase>
    <testcase classname="ReactElementValidator should give context for PropType errors in nested components." name="ReactElementValidator should give context for PropType errors in nested components." time="0.066">
    </testcase>
    <testcase classname="ReactElementValidator gives a helpful error when passing invalid types" name="ReactElementValidator gives a helpful error when passing invalid types" time="0.063">
    </testcase>
    <testcase classname="ReactElementValidator includes the owner name when passing null, undefined, boolean, or number" name="ReactElementValidator includes the owner name when passing null, undefined, boolean, or number" time="0.037">
    </testcase>
    <testcase classname="ReactElementValidator should check default prop values" name="ReactElementValidator should check default prop values" time="0.047">
    </testcase>
    <testcase classname="ReactElementValidator should not check the default for explicit null" name="ReactElementValidator should not check the default for explicit null" time="0.06">
    </testcase>
    <testcase classname="ReactElementValidator should check declared prop types" name="ReactElementValidator should check declared prop types" time="0.102">
    </testcase>
    <testcase classname="ReactElementValidator should warn if a PropType creator is used as a PropType" name="ReactElementValidator should warn if a PropType creator is used as a PropType" time="0.047">
    </testcase>
    <testcase classname="ReactElementValidator should warn if component declares PropTypes instead of propTypes" name="ReactElementValidator should warn if component declares PropTypes instead of propTypes" time="0.056">
    </testcase>
    <testcase classname="ReactElementValidator warns for fragments with illegal attributes" name="ReactElementValidator warns for fragments with illegal attributes" time="0.05">
    </testcase>
    <testcase classname="ReactElementValidator does not warn when using DOM node as children" name="ReactElementValidator does not warn when using DOM node as children" time="0.073">
    </testcase>
    <testcase classname="ReactElementValidator should not enumerate enumerable numbers (#4776)" name="ReactElementValidator should not enumerate enumerable numbers (#4776)" time="0.045">
    </testcase>
    <testcase classname="ReactElementValidator does not blow up with inlined children" name="ReactElementValidator does not blow up with inlined children" time="0.036">
    </testcase>
    <testcase classname="ReactElementValidator does not blow up on key warning with undefined type" name="ReactElementValidator does not blow up on key warning with undefined type" time="0.043">
    </testcase>
    <testcase classname="ReactElementValidator does not call lazy initializers eagerly" name="ReactElementValidator does not call lazy initializers eagerly" time="0.037">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/forwardRef-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:54" time="0.552" tests="6">
    <testcase classname="forwardRef should work without a ref to be forwarded" name="forwardRef should work without a ref to be forwarded" time="0.049">
    </testcase>
    <testcase classname="forwardRef should forward a ref for a single child" name="forwardRef should forward a ref for a single child" time="0.029">
    </testcase>
    <testcase classname="forwardRef should forward a ref for multiple children" name="forwardRef should forward a ref for multiple children" time="0.046">
    </testcase>
    <testcase classname="forwardRef should maintain child instance and ref through updates" name="forwardRef should maintain child instance and ref through updates" time="0.029">
    </testcase>
    <testcase classname="forwardRef should not break lifecycle error handling" name="forwardRef should not break lifecycle error handling" time="0.045">
    </testcase>
    <testcase classname="forwardRef should not re-run the render callback on a deep setState" name="forwardRef should not re-run the render callback on a deep setState" time="0.026">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactStartTransition-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:54" time="0.345" tests="1">
    <testcase classname="ReactStartTransition Warns if a suspicious number of fibers are updated inside startTransition" name="ReactStartTransition Warns if a suspicious number of fibers are updated inside startTransition" time="0.109">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactStrictMode-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:54" time="0.532" tests="4">
    <testcase classname="ReactStrictMode levels should default to not strict" name="ReactStrictMode levels should default to not strict" time="0.105">
    </testcase>
    <testcase classname="ReactStrictMode levels should support enabling strict mode via createRoot option" name="ReactStrictMode levels should support enabling strict mode via createRoot option" time="0.063">
    </testcase>
    <testcase classname="ReactStrictMode levels should include legacy + strict effects mode" name="ReactStrictMode levels should include legacy + strict effects mode" time="0.045">
    </testcase>
    <testcase classname="ReactStrictMode levels should allow level to be increased with nesting" name="ReactStrictMode levels should allow level to be increased with nesting" time="0.053">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactProfilerDevToolsIntegration-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:55" time="0.667" tests="3">
    <testcase classname="ReactProfiler DevTools integration should auto-Profile all fibers if the DevTools hook is detected" name="ReactProfiler DevTools integration should auto-Profile all fibers if the DevTools hook is detected" time="0.082">
    </testcase>
    <testcase classname="ReactProfiler DevTools integration should reset the fiber stack correctly after an error when profiling host roots" name="ReactProfiler DevTools integration should reset the fiber stack correctly after an error when profiling host roots" time="0.073">
    </testcase>
    <testcase classname="ReactProfiler DevTools integration regression test: #17159" name="ReactProfiler DevTools integration regression test: #17159" time="0.146">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactPureComponent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:55" time="0.928" tests="4">
    <testcase classname="ReactPureComponent should render" name="ReactPureComponent should render" time="0.079">
    </testcase>
    <testcase classname="ReactPureComponent can override shouldComponentUpdate" name="ReactPureComponent can override shouldComponentUpdate" time="0.047">
    </testcase>
    <testcase classname="ReactPureComponent extends React.Component" name="ReactPureComponent extends React.Component" time="0.004">
    </testcase>
    <testcase classname="ReactPureComponent should warn when shouldComponentUpdate is defined on React.PureComponent" name="ReactPureComponent should warn when shouldComponentUpdate is defined on React.PureComponent" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactProfiler-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:54" time="5.06" tests="57">
    <testcase classname="Profiler works in profiling and non-profiling bundles enableProfilerTimer:enabled should warn if required params are missing" name="Profiler works in profiling and non-profiling bundles enableProfilerTimer:enabled should warn if required params are missing" time="0.117">
    </testcase>
    <testcase classname="Profiler works in profiling and non-profiling bundles enableProfilerTimer:enabled should support an empty Profiler (with no children)" name="Profiler works in profiling and non-profiling bundles enableProfilerTimer:enabled should support an empty Profiler (with no children)" time="0.029">
    </testcase>
    <testcase classname="Profiler works in profiling and non-profiling bundles enableProfilerTimer:enabled should render children" name="Profiler works in profiling and non-profiling bundles enableProfilerTimer:enabled should render children" time="0.042">
    </testcase>
    <testcase classname="Profiler works in profiling and non-profiling bundles enableProfilerTimer:enabled should support nested Profilers" name="Profiler works in profiling and non-profiling bundles enableProfilerTimer:enabled should support nested Profilers" time="0.033">
    </testcase>
    <testcase classname="Profiler works in profiling and non-profiling bundles enableProfilerTimer:disabled should support an empty Profiler (with no children)" name="Profiler works in profiling and non-profiling bundles enableProfilerTimer:disabled should support an empty Profiler (with no children)" time="0.032">
    </testcase>
    <testcase classname="Profiler works in profiling and non-profiling bundles enableProfilerTimer:disabled should render children" name="Profiler works in profiling and non-profiling bundles enableProfilerTimer:disabled should render children" time="0.049">
    </testcase>
    <testcase classname="Profiler works in profiling and non-profiling bundles enableProfilerTimer:disabled should support nested Profilers" name="Profiler works in profiling and non-profiling bundles enableProfilerTimer:disabled should support nested Profilers" time="0.029">
    </testcase>
    <testcase classname="onRender should handle errors thrown" name="onRender should handle errors thrown" time="0.085">
    </testcase>
    <testcase classname="onRender is not invoked until the commit phase" name="onRender is not invoked until the commit phase" time="0.044">
    </testcase>
    <testcase classname="onRender does not record times for components outside of Profiler tree" name="onRender does not record times for components outside of Profiler tree" time="0.107">
    </testcase>
    <testcase classname="onRender does not report work done on a sibling" name="onRender does not report work done on a sibling" time="0.042">
    </testcase>
    <testcase classname="onRender logs render times for both mount and update" name="onRender logs render times for both mount and update" time="0.052">
    </testcase>
    <testcase classname="onRender includes render times of nested Profilers in their parent times" name="onRender includes render times of nested Profilers in their parent times" time="0.026">
    </testcase>
    <testcase classname="onRender traces sibling Profilers separately" name="onRender traces sibling Profilers separately" time="0.104">
    </testcase>
    <testcase classname="onRender does not include time spent outside of profile root" name="onRender does not include time spent outside of profile root" time="0.038">
    </testcase>
    <testcase classname="onRender is not called when blocked by sCU false" name="onRender is not called when blocked by sCU false" time="0.026">
    </testcase>
    <testcase classname="onRender decreases actual time but not base time when sCU prevents an update" name="onRender decreases actual time but not base time when sCU prevents an update" time="0.072">
    </testcase>
    <testcase classname="onRender includes time spent in render phase lifecycles" name="onRender includes time spent in render phase lifecycles" time="0.081">
    </testcase>
    <testcase classname="onRender should clear nested-update flag when multiple cascading renders are scheduled" name="onRender should clear nested-update flag when multiple cascading renders are scheduled" time="0.085">
    </testcase>
    <testcase classname="onRender is properly distinguish updates and nested-updates when there is more than sync remaining work" name="onRender is properly distinguish updates and nested-updates when there is more than sync remaining work" time="0.077">
    </testcase>
    <testcase classname="onRender with regard to interruptions should accumulate actual time after a scheduling interruptions" name="onRender with regard to interruptions should accumulate actual time after a scheduling interruptions" time="0.047">
    </testcase>
    <testcase classname="onRender with regard to interruptions should not include time between frames" name="onRender with regard to interruptions should not include time between frames" time="0.044">
    </testcase>
    <testcase classname="onRender with regard to interruptions should report the expected times when a high-pri update replaces a mount in-progress" name="onRender with regard to interruptions should report the expected times when a high-pri update replaces a mount in-progress" time="0.071">
    </testcase>
    <testcase classname="onRender with regard to interruptions should report the expected times when a high-priority update replaces a low-priority update" name="onRender with regard to interruptions should report the expected times when a high-priority update replaces a low-priority update" time="0.126">
    </testcase>
    <testcase classname="onRender with regard to interruptions should report the expected times when a high-priority update interrupts a low-priority update" name="onRender with regard to interruptions should report the expected times when a high-priority update interrupts a low-priority update" time="0.171">
    </testcase>
    <testcase classname="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback enabled should accumulate actual time after an error handled by componentDidCatch()" name="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback enabled should accumulate actual time after an error handled by componentDidCatch()" time="0.182">
    </testcase>
    <testcase classname="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback enabled should accumulate actual time after an error handled by getDerivedStateFromError()" name="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback enabled should accumulate actual time after an error handled by getDerivedStateFromError()" time="0.171">
    </testcase>
    <testcase classname="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback enabled should reset the fiber stack correct after a &quot;complete&quot; phase error" name="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback enabled should reset the fiber stack correct after a &quot;complete&quot; phase error" time="0.217">
    </testcase>
    <testcase classname="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback disabled should accumulate actual time after an error handled by componentDidCatch()" name="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback disabled should accumulate actual time after an error handled by componentDidCatch()" time="0.06">
    </testcase>
    <testcase classname="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback disabled should accumulate actual time after an error handled by getDerivedStateFromError()" name="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback disabled should accumulate actual time after an error handled by getDerivedStateFromError()" time="0.085">
    </testcase>
    <testcase classname="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback disabled should reset the fiber stack correct after a &quot;complete&quot; phase error" name="onRender with regard to interruptions replayFailedUnitOfWorkWithInvokeGuardedCallback disabled should reset the fiber stack correct after a &quot;complete&quot; phase error" time="0.105">
    </testcase>
    <testcase classname="onRender reflects the most recently rendered id value" name="onRender reflects the most recently rendered id value" time="0.036">
    </testcase>
    <testcase classname="onRender should not be called until after mutations" name="onRender should not be called until after mutations" time="0.018">
    </testcase>
    <testcase classname="onCommit should report time spent in layout effects and commit lifecycles" name="onCommit should report time spent in layout effects and commit lifecycles" time="0.041">
    </testcase>
    <testcase classname="onCommit should report time spent in layout effects and commit lifecycles with cascading renders" name="onCommit should report time spent in layout effects and commit lifecycles with cascading renders" time="0.066">
    </testcase>
    <testcase classname="onCommit should include time spent in ref callbacks" name="onCommit should include time spent in ref callbacks" time="0.03">
    </testcase>
    <testcase classname="onCommit should bubble time spent in layout effects to higher profilers" name="onCommit should bubble time spent in layout effects to higher profilers" time="0.04">
    </testcase>
    <testcase classname="onCommit should properly report time in layout effects even when there are errors" name="onCommit should properly report time in layout effects even when there are errors" time="0.035">
    </testcase>
    <testcase classname="onCommit should properly report time in layout effect cleanup functions even when there are errors" name="onCommit should properly report time in layout effect cleanup functions even when there are errors" time="0.044">
    </testcase>
    <testcase classname="onPostCommit should report time spent in passive effects" name="onPostCommit should report time spent in passive effects" time="0.038">
    </testcase>
    <testcase classname="onPostCommit should report time spent in passive effects with cascading renders" name="onPostCommit should report time spent in passive effects with cascading renders" time="0.025">
    </testcase>
    <testcase classname="onPostCommit should bubble time spent in effects to higher profilers" name="onPostCommit should bubble time spent in effects to higher profilers" time="0.031">
    </testcase>
    <testcase classname="onPostCommit should properly report time in passive effects even when there are errors" name="onPostCommit should properly report time in passive effects even when there are errors" time="0.071">
    </testcase>
    <testcase classname="onPostCommit should properly report time in passive effect cleanup functions even when there are errors" name="onPostCommit should properly report time in passive effect cleanup functions even when there are errors" time="0.038">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is not called when the legacy render API is used to schedule an update" name="onNestedUpdateScheduled is not called when the legacy render API is used to schedule an update" time="0.027">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is not called when the root API is used to schedule an update" name="onNestedUpdateScheduled is not called when the root API is used to schedule an update" time="0.028">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is called when a function component schedules an update during a layout effect" name="onNestedUpdateScheduled is called when a function component schedules an update during a layout effect" time="0.027">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is called when a function component schedules a batched update during a layout effect" name="onNestedUpdateScheduled is called when a function component schedules a batched update during a layout effect" time="0.027">
    </testcase>
    <testcase classname="onNestedUpdateScheduled bubbles up and calls all ancestor Profilers" name="onNestedUpdateScheduled bubbles up and calls all ancestor Profilers" time="0.036">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is not called when an update is scheduled for another doort during a layout effect" name="onNestedUpdateScheduled is not called when an update is scheduled for another doort during a layout effect" time="0.053">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is not called when a function component schedules an update during a passive effect" name="onNestedUpdateScheduled is not called when a function component schedules an update during a passive effect" time="0.026">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is not called when a function component schedules an update outside of render" name="onNestedUpdateScheduled is not called when a function component schedules an update outside of render" time="0.042">
    </testcase>
    <testcase classname="onNestedUpdateScheduled it is not called when a component schedules an update during render" name="onNestedUpdateScheduled it is not called when a component schedules an update during render" time="0.017">
    </testcase>
    <testcase classname="onNestedUpdateScheduled it is called when a component schedules an update from a ref callback" name="onNestedUpdateScheduled it is called when a component schedules an update from a ref callback" time="0.039">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is called when a class component schedules an update from the componentDidMount lifecycles" name="onNestedUpdateScheduled is called when a class component schedules an update from the componentDidMount lifecycles" time="0.026">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is called when a class component schedules an update from the componentDidUpdate lifecycles" name="onNestedUpdateScheduled is called when a class component schedules an update from the componentDidUpdate lifecycles" time="0.025">
    </testcase>
    <testcase classname="onNestedUpdateScheduled is not called when a class component schedules an update outside of render" name="onNestedUpdateScheduled is not called when a class component schedules an update outside of render" time="0.027">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactStrictMode-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:56" time="2.857" tests="22">
    <testcase classname="ReactStrictMode should appear in the client component stack" name="ReactStrictMode should appear in the client component stack" time="0.072">
    </testcase>
    <testcase classname="ReactStrictMode should appear in the SSR component stack" name="ReactStrictMode should appear in the SSR component stack" time="0.095">
    </testcase>
    <testcase classname="ReactStrictMode should invoke precommit lifecycle methods twice" name="ReactStrictMode should invoke precommit lifecycle methods twice" time="0.039">
    </testcase>
    <testcase classname="ReactStrictMode should invoke setState callbacks twice" name="ReactStrictMode should invoke setState callbacks twice" time="0.06">
    </testcase>
    <testcase classname="ReactStrictMode should invoke precommit lifecycle methods twice in DEV" name="ReactStrictMode should invoke precommit lifecycle methods twice in DEV" time="0.05">
    </testcase>
    <testcase classname="ReactStrictMode should invoke setState callbacks twice in DEV" name="ReactStrictMode should invoke setState callbacks twice in DEV" time="0.069">
    </testcase>
    <testcase classname="Concurrent Mode should warn about unsafe legacy lifecycle methods anywhere in a StrictMode tree" name="Concurrent Mode should warn about unsafe legacy lifecycle methods anywhere in a StrictMode tree" time="0.068">
    </testcase>
    <testcase classname="Concurrent Mode should coalesce warnings by lifecycle name" name="Concurrent Mode should coalesce warnings by lifecycle name" time="0.056">
    </testcase>
    <testcase classname="Concurrent Mode should warn about components not present during the initial render" name="Concurrent Mode should warn about components not present during the initial render" time="0.047">
    </testcase>
    <testcase classname="Concurrent Mode should also warn inside of &quot;strict&quot; mode trees" name="Concurrent Mode should also warn inside of &quot;strict&quot; mode trees" time="0.052">
    </testcase>
    <testcase classname="symbol checks should switch from StrictMode to a Fragment and reset state" name="symbol checks should switch from StrictMode to a Fragment and reset state" time="0.042">
    </testcase>
    <testcase classname="symbol checks should switch from a Fragment to StrictMode and reset state" name="symbol checks should switch from a Fragment to StrictMode and reset state" time="0.042">
    </testcase>
    <testcase classname="symbol checks should update with StrictMode without losing state" name="symbol checks should update with StrictMode without losing state" time="0.072">
    </testcase>
    <testcase classname="string refs should warn within a strict tree" name="string refs should warn within a strict tree" time="0.077">
    </testcase>
    <testcase classname="string refs should warn within a strict tree" name="string refs should warn within a strict tree" time="0.087">
    </testcase>
    <testcase classname="context legacy should warn if the legacy context API have been used in strict mode" name="context legacy should warn if the legacy context API have been used in strict mode" time="0.067">
    </testcase>
    <testcase classname="context legacy console logs logging does not disable logs for class double render" name="context legacy console logs logging does not disable logs for class double render" time="0.117">
    </testcase>
    <testcase classname="context legacy console logs logging does not disable logs for class double ctor" name="context legacy console logs logging does not disable logs for class double ctor" time="0.085">
    </testcase>
    <testcase classname="context legacy console logs logging does not disable logs for class double getDerivedStateFromProps" name="context legacy console logs logging does not disable logs for class double getDerivedStateFromProps" time="0.118">
    </testcase>
    <testcase classname="context legacy console logs logging does not disable logs for class double shouldComponentUpdate" name="context legacy console logs logging does not disable logs for class double shouldComponentUpdate" time="0.114">
    </testcase>
    <testcase classname="context legacy console logs logging does not disable logs for class state updaters" name="context legacy console logs logging does not disable logs for class state updaters" time="0.22">
    </testcase>
    <testcase classname="context legacy console logs logging does not disable logs for function double render" name="context legacy console logs logging does not disable logs for function double render" time="0.192">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/createReactClassIntegration-test.js" errors="0" failures="0" skipped="1" timestamp="2022-08-05T04:12:57" time="2.735" tests="28">
    <testcase classname="create-react-class-integration should throw when `render` is not specified" name="create-react-class-integration should throw when `render` is not specified" time="0.071">
    </testcase>
    <testcase classname="create-react-class-integration should copy prop types onto the Constructor" name="create-react-class-integration should copy prop types onto the Constructor" time="0.055">
    </testcase>
    <testcase classname="create-react-class-integration should warn on invalid prop types" name="create-react-class-integration should warn on invalid prop types" time="0.082">
    </testcase>
    <testcase classname="create-react-class-integration should warn on invalid context types" name="create-react-class-integration should warn on invalid context types" time="0.065">
    </testcase>
    <testcase classname="create-react-class-integration should throw on invalid child context types" name="create-react-class-integration should throw on invalid child context types" time="0.051">
    </testcase>
    <testcase classname="create-react-class-integration should warn when misspelling shouldComponentUpdate" name="create-react-class-integration should warn when misspelling shouldComponentUpdate" time="0.054">
    </testcase>
    <testcase classname="create-react-class-integration should warn when misspelling componentWillReceiveProps" name="create-react-class-integration should warn when misspelling componentWillReceiveProps" time="0.054">
    </testcase>
    <testcase classname="create-react-class-integration should warn when misspelling UNSAFE_componentWillReceiveProps" name="create-react-class-integration should warn when misspelling UNSAFE_componentWillReceiveProps" time="0.058">
    </testcase>
    <testcase classname="create-react-class-integration should throw if a reserved property is in statics" name="create-react-class-integration should throw if a reserved property is in statics" time="0.043">
    </testcase>
    <testcase classname="create-react-class-integration should warn when using deprecated non-static spec keys" name="create-react-class-integration should warn when using deprecated non-static spec keys" time="0">
      <skipped/>
    </testcase>
    <testcase classname="create-react-class-integration should support statics" name="create-react-class-integration should support statics" time="0.065">
    </testcase>
    <testcase classname="create-react-class-integration should work with object getInitialState() return values" name="create-react-class-integration should work with object getInitialState() return values" time="0.076">
    </testcase>
    <testcase classname="create-react-class-integration should work with getDerivedStateFromProps() return values" name="create-react-class-integration should work with getDerivedStateFromProps() return values" time="0.04">
    </testcase>
    <testcase classname="create-react-class-integration renders based on context getInitialState" name="create-react-class-integration renders based on context getInitialState" time="0.048">
    </testcase>
    <testcase classname="create-react-class-integration should throw with non-object getInitialState() return values" name="create-react-class-integration should throw with non-object getInitialState() return values" time="0.093">
    </testcase>
    <testcase classname="create-react-class-integration should work with a null getInitialState() return value" name="create-react-class-integration should work with a null getInitialState() return value" time="0.034">
    </testcase>
    <testcase classname="create-react-class-integration should throw when using legacy factories" name="create-react-class-integration should throw when using legacy factories" time="0.061">
    </testcase>
    <testcase classname="create-react-class-integration replaceState and callback works" name="create-react-class-integration replaceState and callback works" time="0.048">
    </testcase>
    <testcase classname="create-react-class-integration getDerivedStateFromProps updates state when props change" name="create-react-class-integration getDerivedStateFromProps updates state when props change" time="0.077">
    </testcase>
    <testcase classname="create-react-class-integration should support the new static getDerivedStateFromProps method" name="create-react-class-integration should support the new static getDerivedStateFromProps method" time="0.079">
    </testcase>
    <testcase classname="create-react-class-integration warns if getDerivedStateFromProps is not static" name="create-react-class-integration warns if getDerivedStateFromProps is not static" time="0.045">
    </testcase>
    <testcase classname="create-react-class-integration warns if getDerivedStateFromError is not static" name="create-react-class-integration warns if getDerivedStateFromError is not static" time="0.09">
    </testcase>
    <testcase classname="create-react-class-integration warns if getSnapshotBeforeUpdate is static" name="create-react-class-integration warns if getSnapshotBeforeUpdate is static" time="0.053">
    </testcase>
    <testcase classname="create-react-class-integration should warn if state is not properly initialized before getDerivedStateFromProps" name="create-react-class-integration should warn if state is not properly initialized before getDerivedStateFromProps" time="0.096">
    </testcase>
    <testcase classname="create-react-class-integration should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" name="create-react-class-integration should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new static gDSFP is present" time="0.058">
    </testcase>
    <testcase classname="create-react-class-integration should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" name="create-react-class-integration should not invoke deprecated lifecycles (cWM/cWRP/cWU) if new getSnapshotBeforeUpdate is present" time="0.066">
    </testcase>
    <testcase classname="create-react-class-integration should invoke both deprecated and new lifecycles if both are present" name="create-react-class-integration should invoke both deprecated and new lifecycles if both are present" time="0.059">
    </testcase>
    <testcase classname="create-react-class-integration isMounted works" name="create-react-class-integration isMounted works" time="0.056">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/onlyChild-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:00" time="0.371" tests="5">
    <testcase classname="onlyChild should fail when passed two children" name="onlyChild should fail when passed two children" time="0.008">
    </testcase>
    <testcase classname="onlyChild should fail when passed nully values" name="onlyChild should fail when passed nully values" time="0.001">
    </testcase>
    <testcase classname="onlyChild should fail when key/value objects" name="onlyChild should fail when key/value objects" time="0.002">
    </testcase>
    <testcase classname="onlyChild should not fail when passed interpolated single child" name="onlyChild should not fail when passed interpolated single child" time="0">
    </testcase>
    <testcase classname="onlyChild should return the only child" name="onlyChild should return the only child" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactTypeScriptClass-test.ts" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:55" time="5.684" tests="29">
    <testcase classname="ReactTypeScriptClass preserves the name of the class for use in error messages" name="ReactTypeScriptClass preserves the name of the class for use in error messages" time="0.001">
    </testcase>
    <testcase classname="ReactTypeScriptClass throws if no render function is defined" name="ReactTypeScriptClass throws if no render function is defined" time="0.013">
    </testcase>
    <testcase classname="ReactTypeScriptClass renders a simple stateless component with prop" name="ReactTypeScriptClass renders a simple stateless component with prop" time="0.007">
    </testcase>
    <testcase classname="ReactTypeScriptClass renders based on state using initial values in this.props" name="ReactTypeScriptClass renders based on state using initial values in this.props" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass renders based on state using props in the constructor" name="ReactTypeScriptClass renders based on state using props in the constructor" time="0.003">
    </testcase>
    <testcase classname="ReactTypeScriptClass sets initial state with value returned by static getDerivedStateFromProps" name="ReactTypeScriptClass sets initial state with value returned by static getDerivedStateFromProps" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass warns if getDerivedStateFromProps is not static" name="ReactTypeScriptClass warns if getDerivedStateFromProps is not static" time="0.03">
    </testcase>
    <testcase classname="ReactTypeScriptClass warns if getDerivedStateFromError is not static" name="ReactTypeScriptClass warns if getDerivedStateFromError is not static" time="0.003">
    </testcase>
    <testcase classname="ReactTypeScriptClass warns if getSnapshotBeforeUpdate is static" name="ReactTypeScriptClass warns if getSnapshotBeforeUpdate is static" time="0.003">
    </testcase>
    <testcase classname="ReactTypeScriptClass warns if state not initialized before static getDerivedStateFromProps" name="ReactTypeScriptClass warns if state not initialized before static getDerivedStateFromProps" time="0.024">
    </testcase>
    <testcase classname="ReactTypeScriptClass updates initial state with values returned by static getDerivedStateFromProps" name="ReactTypeScriptClass updates initial state with values returned by static getDerivedStateFromProps" time="0.011">
    </testcase>
    <testcase classname="ReactTypeScriptClass renders updated state with values returned by static getDerivedStateFromProps" name="ReactTypeScriptClass renders updated state with values returned by static getDerivedStateFromProps" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass renders based on context in the constructor" name="ReactTypeScriptClass renders based on context in the constructor" time="0.003">
    </testcase>
    <testcase classname="ReactTypeScriptClass renders only once when setting state in componentWillMount" name="ReactTypeScriptClass renders only once when setting state in componentWillMount" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass should warn with non-object in the initial state property" name="ReactTypeScriptClass should warn with non-object in the initial state property" time="0.016">
    </testcase>
    <testcase classname="ReactTypeScriptClass should render with null in the initial state property" name="ReactTypeScriptClass should render with null in the initial state property" time="0.001">
    </testcase>
    <testcase classname="ReactTypeScriptClass setState through an event handler" name="ReactTypeScriptClass setState through an event handler" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass should not implicitly bind event handlers" name="ReactTypeScriptClass should not implicitly bind event handlers" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass renders using forceUpdate even when there is no state" name="ReactTypeScriptClass renders using forceUpdate even when there is no state" time="0.021">
    </testcase>
    <testcase classname="ReactTypeScriptClass will call all the normal life cycle methods" name="ReactTypeScriptClass will call all the normal life cycle methods" time="0.004">
    </testcase>
    <testcase classname="ReactTypeScriptClass warns when classic properties are defined on the instance, but does not invoke them." name="ReactTypeScriptClass warns when classic properties are defined on the instance, but does not invoke them." time="0.011">
    </testcase>
    <testcase classname="ReactTypeScriptClass does not warn about getInitialState() on class components if state is also defined." name="ReactTypeScriptClass does not warn about getInitialState() on class components if state is also defined." time="0.006">
    </testcase>
    <testcase classname="ReactTypeScriptClass should warn when misspelling shouldComponentUpdate" name="ReactTypeScriptClass should warn when misspelling shouldComponentUpdate" time="0.003">
    </testcase>
    <testcase classname="ReactTypeScriptClass should warn when misspelling componentWillReceiveProps" name="ReactTypeScriptClass should warn when misspelling componentWillReceiveProps" time="0.003">
    </testcase>
    <testcase classname="ReactTypeScriptClass should warn when misspelling UNSAFE_componentWillReceiveProps" name="ReactTypeScriptClass should warn when misspelling UNSAFE_componentWillReceiveProps" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass should throw AND warn when trying to access classic APIs" name="ReactTypeScriptClass should throw AND warn when trying to access classic APIs" time="0.043">
    </testcase>
    <testcase classname="ReactTypeScriptClass supports this.context passed via getChildContext" name="ReactTypeScriptClass supports this.context passed via getChildContext" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass supports classic refs" name="ReactTypeScriptClass supports classic refs" time="0.002">
    </testcase>
    <testcase classname="ReactTypeScriptClass supports drilling through to the DOM using findDOMNode" name="ReactTypeScriptClass supports drilling through to the DOM using findDOMNode" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalErrorLogging-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:01" time="0.539" tests="4">
    <testcase classname="ReactIncrementalErrorLogging should log errors that occur during the begin phase" name="ReactIncrementalErrorLogging should log errors that occur during the begin phase" time="0.058">
    </testcase>
    <testcase classname="ReactIncrementalErrorLogging should log errors that occur during the commit phase" name="ReactIncrementalErrorLogging should log errors that occur during the commit phase" time="0.045">
    </testcase>
    <testcase classname="ReactIncrementalErrorLogging should ignore errors thrown in log method to prevent cycle" name="ReactIncrementalErrorLogging should ignore errors thrown in log method to prevent cycle" time="0.034">
    </testcase>
    <testcase classname="ReactIncrementalErrorLogging resets instance variables before unmounting failed node" name="ReactIncrementalErrorLogging resets instance variables before unmounting failed node" time="0.036">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-dom/src/events/__tests__/DOMPluginEventSystem-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:40" time="22.239" tests="110">
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled does not pool events" name="DOMPluginEventSystem enableLegacyFBSupport disabled does not pool events" time="0.11">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events" time="0.031">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events combined with sync clicks" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events combined with sync clicks" time="0.028">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between roots" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between roots" time="0.035">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between disjointed roots" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between disjointed roots" time="0.109">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between disjointed roots #2" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between disjointed roots #2" time="0.144">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between disjointed comment roots" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between disjointed comment roots" time="0.062">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between disjointed comment roots #2" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between disjointed comment roots #2" time="0.069">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between portals" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of click events between portals" time="0.07">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle click events on document.body portals" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle click events on document.body portals" time="0.04">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled does not invoke an event on a parent tree when a subtree is dehydrated" name="DOMPluginEventSystem enableLegacyFBSupport disabled does not invoke an event on a parent tree when a subtree is dehydrated" time="0.134">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle click events on dynamic portals" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle click events on dynamic portals" time="0.138">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle click events on dynamic portals #2" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle click events on dynamic portals #2" time="0.05">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled native stopPropagation on click events between portals" name="DOMPluginEventSystem enableLegacyFBSupport disabled native stopPropagation on click events between portals" time="0.076">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of focus events" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of focus events" time="0.054">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of focus events between roots" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of focus events between roots" time="0.099">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of focus events between portals" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of focus events between portals" time="0.087">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled native stopPropagation on focus events between portals" name="DOMPluginEventSystem enableLegacyFBSupport disabled native stopPropagation on focus events between portals" time="0.053">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of enter and leave events between portals" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of enter and leave events between portals" time="0.076">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of enter and leave events between portals #2" name="DOMPluginEventSystem enableLegacyFBSupport disabled handle propagation of enter and leave events between portals #2" time="0.065">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled should preserve bubble/capture order between roots and nested portals" name="DOMPluginEventSystem enableLegacyFBSupport disabled should preserve bubble/capture order between roots and nested portals" time="0.134">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle can render correctly with the ReactDOMServer" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle can render correctly with the ReactDOMServer" time="0.159">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle can render correctly with the ReactDOMServer hydration" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle can render correctly with the ReactDOMServer hydration" time="0.188">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; listener" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; listener" time="0.344">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly work for setting and clearing a basic &quot;click&quot; listener" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly work for setting and clearing a basic &quot;click&quot; listener" time="0.394">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should handle the target being a text node" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should handle the target being a text node" time="0.105">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events" time="0.191">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events mixed with onClick events" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events mixed with onClick events" time="0.152">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; listener on the outer target" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; listener on the outer target" time="0.189">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle many nested target listeners" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle many nested target listeners" time="0.077">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation correctly for target events" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation correctly for target events" time="0.185">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation correctly for many target events" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation correctly for many target events" time="0.131">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation for mixed capture/bubbling target listeners" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation for mixed capture/bubbling target listeners" time="0.126">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should work with concurrent mode updates" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should work with concurrent mode updates" time="0.138">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; window listener" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; window listener" time="0.155">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events on the window" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events on the window" time="0.174">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation for mixed listeners" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation for mixed listeners" time="0.138">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation for delegated listeners" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle should correctly handle stopPropagation for delegated listeners" time="0.133">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events on the window and document" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events on the window and document" time="0.136">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle does not support custom user events" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle does not support custom user events" time="0.142">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur and afterblur are called after a focused element is unmounted" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur and afterblur are called after a focused element is unmounted" time="0.248">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur and afterblur are called after a nested focused element is unmounted" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur and afterblur are called after a nested focused element is unmounted" time="0.447">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur should skip handlers from a deleted subtree after the focused element is unmounted" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur should skip handlers from a deleted subtree after the focused element is unmounted" time="0.285">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur and afterblur are called after a focused element is suspended" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur and afterblur are called after a focused element is suspended" time="0.223">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur should skip handlers from a deleted subtree after the focused element is suspended" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle beforeblur should skip handlers from a deleted subtree after the focused element is suspended" time="0.184">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle regression: does not fire beforeblur/afterblur if target is already hidden" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle regression: does not fire beforeblur/afterblur if target is already hidden" time="0.158">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events between disjointed comment roots" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle handle propagation of click events between disjointed comment roots" time="0.17">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle propagates known createEventHandle events through portals without inner listeners" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle propagates known createEventHandle events through portals without inner listeners" time="0.174">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle propagation of click events on a scope" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle propagation of click events on a scope" time="0.162">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle mixed propagation of click events on a scope" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle mixed propagation of click events on a scope" time="0.154">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API should not handle the target being a dangling text node within a scope" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API should not handle the target being a dangling text node within a scope" time="0.15">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (inner) correctly between scopes" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (inner) correctly between scopes" time="0.157">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (outer) correctly between scopes" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (outer) correctly between scopes" time="0.16">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (inner and outer) correctly between scopes" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (inner and outer) correctly between scopes" time="0.212">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API should be able to register handlers for events affected by the intervention" name="DOMPluginEventSystem enableLegacyFBSupport disabled ReactDOM.createEventHandle Compatibility with Scopes API should be able to register handlers for events affected by the intervention" time="0.316">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled does not pool events" name="DOMPluginEventSystem enableLegacyFBSupport enabled does not pool events" time="0.175">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events" time="0.097">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events combined with sync clicks" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events combined with sync clicks" time="0.108">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between roots" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between roots" time="0.102">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between disjointed roots" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between disjointed roots" time="0.11">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between disjointed roots #2" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between disjointed roots #2" time="0.138">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between disjointed comment roots" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between disjointed comment roots" time="0.115">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between disjointed comment roots #2" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between disjointed comment roots #2" time="0.09">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between portals" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of click events between portals" time="0.151">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle click events on document.body portals" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle click events on document.body portals" time="0.077">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled does not invoke an event on a parent tree when a subtree is dehydrated" name="DOMPluginEventSystem enableLegacyFBSupport enabled does not invoke an event on a parent tree when a subtree is dehydrated" time="0.155">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle click events on dynamic portals" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle click events on dynamic portals" time="0.127">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle click events on dynamic portals #2" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle click events on dynamic portals #2" time="0.134">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled native stopPropagation on click events between portals" name="DOMPluginEventSystem enableLegacyFBSupport enabled native stopPropagation on click events between portals" time="0.132">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of focus events" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of focus events" time="0.093">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of focus events between roots" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of focus events between roots" time="0.114">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of focus events between portals" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of focus events between portals" time="0.123">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled native stopPropagation on focus events between portals" name="DOMPluginEventSystem enableLegacyFBSupport enabled native stopPropagation on focus events between portals" time="0.1">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of enter and leave events between portals" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of enter and leave events between portals" time="0.108">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of enter and leave events between portals #2" name="DOMPluginEventSystem enableLegacyFBSupport enabled handle propagation of enter and leave events between portals #2" time="0.145">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled should preserve bubble/capture order between roots and nested portals" name="DOMPluginEventSystem enableLegacyFBSupport enabled should preserve bubble/capture order between roots and nested portals" time="0.134">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle can render correctly with the ReactDOMServer" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle can render correctly with the ReactDOMServer" time="0.17">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle can render correctly with the ReactDOMServer hydration" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle can render correctly with the ReactDOMServer hydration" time="0.153">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; listener" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; listener" time="0.169">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly work for setting and clearing a basic &quot;click&quot; listener" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly work for setting and clearing a basic &quot;click&quot; listener" time="0.152">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should handle the target being a text node" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should handle the target being a text node" time="0.487">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events" time="0.288">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events mixed with onClick events" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events mixed with onClick events" time="0.181">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; listener on the outer target" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; listener on the outer target" time="0.236">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle many nested target listeners" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle many nested target listeners" time="0.197">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation correctly for target events" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation correctly for target events" time="0.237">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation correctly for many target events" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation correctly for many target events" time="0.29">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation for mixed capture/bubbling target listeners" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation for mixed capture/bubbling target listeners" time="0.231">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should work with concurrent mode updates" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should work with concurrent mode updates" time="0.327">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; window listener" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly work for a basic &quot;click&quot; window listener" time="0.32">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events on the window" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events on the window" time="0.31">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation for mixed listeners" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation for mixed listeners" time="0.223">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation for delegated listeners" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle should correctly handle stopPropagation for delegated listeners" time="0.201">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events on the window and document" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events on the window and document" time="0.262">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle does not support custom user events" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle does not support custom user events" time="0.228">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur and afterblur are called after a focused element is unmounted" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur and afterblur are called after a focused element is unmounted" time="0.233">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur and afterblur are called after a nested focused element is unmounted" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur and afterblur are called after a nested focused element is unmounted" time="0.236">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur should skip handlers from a deleted subtree after the focused element is unmounted" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur should skip handlers from a deleted subtree after the focused element is unmounted" time="0.216">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur and afterblur are called after a focused element is suspended" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur and afterblur are called after a focused element is suspended" time="0.659">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur should skip handlers from a deleted subtree after the focused element is suspended" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle beforeblur should skip handlers from a deleted subtree after the focused element is suspended" time="0.299">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle regression: does not fire beforeblur/afterblur if target is already hidden" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle regression: does not fire beforeblur/afterblur if target is already hidden" time="0.208">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events between disjointed comment roots" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle handle propagation of click events between disjointed comment roots" time="0.22">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle propagates known createEventHandle events through portals without inner listeners" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle propagates known createEventHandle events through portals without inner listeners" time="0.227">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle propagation of click events on a scope" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle propagation of click events on a scope" time="0.298">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle mixed propagation of click events on a scope" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle mixed propagation of click events on a scope" time="0.297">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API should not handle the target being a dangling text node within a scope" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API should not handle the target being a dangling text node within a scope" time="0.324">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (inner) correctly between scopes" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (inner) correctly between scopes" time="0.354">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (outer) correctly between scopes" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (outer) correctly between scopes" time="0.302">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (inner and outer) correctly between scopes" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API handle stopPropagation (inner and outer) correctly between scopes" time="0.348">
    </testcase>
    <testcase classname="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API should be able to register handlers for events affected by the intervention" name="DOMPluginEventSystem enableLegacyFBSupport enabled ReactDOM.createEventHandle Compatibility with Scopes API should be able to register handlers for events affected by the intervention" time="0.262">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalErrorHandling-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:00" time="3.16" tests="42">
    <testcase classname="ReactIncrementalErrorHandling recovers from errors asynchronously" name="ReactIncrementalErrorHandling recovers from errors asynchronously" time="0.093">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling recovers from errors asynchronously (legacy, no getDerivedStateFromError)" name="ReactIncrementalErrorHandling recovers from errors asynchronously (legacy, no getDerivedStateFromError)" time="0.037">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling retries at a lower priority if there&apos;s additional pending work" name="ReactIncrementalErrorHandling retries at a lower priority if there&apos;s additional pending work" time="0.055">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling does not include offscreen work when retrying after an error" name="ReactIncrementalErrorHandling does not include offscreen work when retrying after an error" time="0.057">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling retries one more time before handling error" name="ReactIncrementalErrorHandling retries one more time before handling error" time="0.058">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling retries one more time if an error occurs during a render that expires midway through the tree" name="ReactIncrementalErrorHandling retries one more time if an error occurs during a render that expires midway through the tree" time="0.05">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling calls componentDidCatch multiple times for multiple errors" name="ReactIncrementalErrorHandling calls componentDidCatch multiple times for multiple errors" time="0.025">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling catches render error in a boundary during full deferred mounting" name="ReactIncrementalErrorHandling catches render error in a boundary during full deferred mounting" time="0.056">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling catches render error in a boundary during partial deferred mounting" name="ReactIncrementalErrorHandling catches render error in a boundary during partial deferred mounting" time="0.024">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling catches render error in a boundary during synchronous mounting" name="ReactIncrementalErrorHandling catches render error in a boundary during synchronous mounting" time="0.036">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling catches render error in a boundary during batched mounting" name="ReactIncrementalErrorHandling catches render error in a boundary during batched mounting" time="0.043">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling propagates an error from a noop error boundary during full deferred mounting" name="ReactIncrementalErrorHandling propagates an error from a noop error boundary during full deferred mounting" time="0.038">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling propagates an error from a noop error boundary during partial deferred mounting" name="ReactIncrementalErrorHandling propagates an error from a noop error boundary during partial deferred mounting" time="0.085">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling propagates an error from a noop error boundary during synchronous mounting" name="ReactIncrementalErrorHandling propagates an error from a noop error boundary during synchronous mounting" time="0.063">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling propagates an error from a noop error boundary during batched mounting" name="ReactIncrementalErrorHandling propagates an error from a noop error boundary during batched mounting" time="0.022">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling applies batched updates regardless despite errors in scheduling" name="ReactIncrementalErrorHandling applies batched updates regardless despite errors in scheduling" time="0.033">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling applies nested batched updates despite errors in scheduling" name="ReactIncrementalErrorHandling applies nested batched updates despite errors in scheduling" time="0.036">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling defers additional sync work to a separate event after an error" name="ReactIncrementalErrorHandling defers additional sync work to a separate event after an error" time="0.036">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling can schedule updates after uncaught error in render on mount" name="ReactIncrementalErrorHandling can schedule updates after uncaught error in render on mount" time="0.046">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling can schedule updates after uncaught error in render on update" name="ReactIncrementalErrorHandling can schedule updates after uncaught error in render on update" time="0.02">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling can schedule updates after uncaught error during unmounting" name="ReactIncrementalErrorHandling can schedule updates after uncaught error during unmounting" time="0.057">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling should not attempt to recover an unmounting error boundary" name="ReactIncrementalErrorHandling should not attempt to recover an unmounting error boundary" time="0.023">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling can unmount an error boundary before it is handled" name="ReactIncrementalErrorHandling can unmount an error boundary before it is handled" time="0.038">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling continues work on other roots despite caught errors" name="ReactIncrementalErrorHandling continues work on other roots despite caught errors" time="0.046">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling continues work on other roots despite uncaught errors" name="ReactIncrementalErrorHandling continues work on other roots despite uncaught errors" time="0.092">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling unwinds the context stack correctly on error" name="ReactIncrementalErrorHandling unwinds the context stack correctly on error" time="0.061">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling catches reconciler errors in a boundary during mounting" name="ReactIncrementalErrorHandling catches reconciler errors in a boundary during mounting" time="0.025">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling catches reconciler errors in a boundary during update" name="ReactIncrementalErrorHandling catches reconciler errors in a boundary during update" time="0.079">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling recovers from uncaught reconciler errors" name="ReactIncrementalErrorHandling recovers from uncaught reconciler errors" time="0.083">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling unmounts components with uncaught errors" name="ReactIncrementalErrorHandling unmounts components with uncaught errors" time="0.056">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling does not interrupt unmounting if detaching a ref throws" name="ReactIncrementalErrorHandling does not interrupt unmounting if detaching a ref throws" time="0.085">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling handles error thrown by host config while working on failed root" name="ReactIncrementalErrorHandling handles error thrown by host config while working on failed root" time="0.071">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling handles error thrown by top-level callback" name="ReactIncrementalErrorHandling handles error thrown by top-level callback" time="0.04">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling error boundaries capture non-errors" name="ReactIncrementalErrorHandling error boundaries capture non-errors" time="0.152">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling continues working on siblings of a component that throws" name="ReactIncrementalErrorHandling continues working on siblings of a component that throws" time="0.047">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling calls the correct lifecycles on the error boundary after catching an error (mixed)" name="ReactIncrementalErrorHandling calls the correct lifecycles on the error boundary after catching an error (mixed)" time="0.043">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling provides component stack to the error boundary with componentDidCatch" name="ReactIncrementalErrorHandling provides component stack to the error boundary with componentDidCatch" time="0.019">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling does not provide component stack to the error boundary with getDerivedStateFromError" name="ReactIncrementalErrorHandling does not provide component stack to the error boundary with getDerivedStateFromError" time="0.047">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling provides component stack even if overriding prepareStackTrace" name="ReactIncrementalErrorHandling provides component stack even if overriding prepareStackTrace" time="0.027">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling uncaught errors should be discarded if the render is aborted" name="ReactIncrementalErrorHandling uncaught errors should be discarded if the render is aborted" time="0.044">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling uncaught errors are discarded if the render is aborted, case 2" name="ReactIncrementalErrorHandling uncaught errors are discarded if the render is aborted, case 2" time="0.065">
    </testcase>
    <testcase classname="ReactIncrementalErrorHandling does not infinite loop if there&apos;s a render phase update in the same render as an error" name="ReactIncrementalErrorHandling does not infinite loop if there&apos;s a render phase update in the same render as an error" time="0.048">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/useMutableSourceHydration-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:02" time="0.7" tests="4">
    <testcase classname="useMutableSourceHydration should render and hydrate" name="useMutableSourceHydration should render and hydrate" time="0.105">
    </testcase>
    <testcase classname="useMutableSourceHydration should detect a tear before hydrating a component" name="useMutableSourceHydration should detect a tear before hydrating a component" time="0.074">
    </testcase>
    <testcase classname="useMutableSourceHydration should detect a tear between hydrating components" name="useMutableSourceHydration should detect a tear between hydrating components" time="0.05">
    </testcase>
    <testcase classname="useMutableSourceHydration should detect a tear between hydrating components reading from different parts of a source" name="useMutableSourceHydration should detect a tear between hydrating components reading from different parts of a source" time="0.071">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspense-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:00" time="2.718" tests="29">
    <testcase classname="ReactSuspense suspends rendering and continues later" name="ReactSuspense suspends rendering and continues later" time="0.066">
    </testcase>
    <testcase classname="ReactSuspense suspends siblings and later recovers each independently" name="ReactSuspense suspends siblings and later recovers each independently" time="0.067">
    </testcase>
    <testcase classname="ReactSuspense interrupts current render if promise resolves before current render phase" name="ReactSuspense interrupts current render if promise resolves before current render phase" time="0.037">
    </testcase>
    <testcase classname="ReactSuspense throttles fallback committing globally" name="ReactSuspense throttles fallback committing globally" time="0.087">
    </testcase>
    <testcase classname="ReactSuspense does not throttle fallback committing for too long" name="ReactSuspense does not throttle fallback committing for too long" time="0.025">
    </testcase>
    <testcase classname="ReactSuspense [GATED, SHOULD FAIL] interrupts current render when something suspends with a delay and we&apos;ve already skipped over a lower priority update in a parent" name="ReactSuspense [GATED, SHOULD FAIL] interrupts current render when something suspends with a delay and we&apos;ve already skipped over a lower priority update in a parent" time="0.066">
    </testcase>
    <testcase classname="ReactSuspense mounts a lazy class component in non-concurrent mode" name="ReactSuspense mounts a lazy class component in non-concurrent mode" time="0.075">
    </testcase>
    <testcase classname="ReactSuspense updates memoized child of suspense component when context updates (simple memo)" name="ReactSuspense updates memoized child of suspense component when context updates (simple memo)" time="0.046">
    </testcase>
    <testcase classname="ReactSuspense updates memoized child of suspense component when context updates (manual memo)" name="ReactSuspense updates memoized child of suspense component when context updates (manual memo)" time="0.032">
    </testcase>
    <testcase classname="ReactSuspense updates memoized child of suspense component when context updates (function)" name="ReactSuspense updates memoized child of suspense component when context updates (function)" time="0.033">
    </testcase>
    <testcase classname="ReactSuspense updates memoized child of suspense component when context updates (forwardRef)" name="ReactSuspense updates memoized child of suspense component when context updates (forwardRef)" time="0.033">
    </testcase>
    <testcase classname="ReactSuspense re-fires layout effects when re-showing Suspense" name="ReactSuspense re-fires layout effects when re-showing Suspense" time="0.018">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode a mounted class component can suspend without losing state" name="ReactSuspense outside concurrent mode a mounted class component can suspend without losing state" time="0.06">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode bails out on timed-out primary children even if they receive an update" name="ReactSuspense outside concurrent mode bails out on timed-out primary children even if they receive an update" time="0.025">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode when updating a timed-out tree, always retries the suspended component" name="ReactSuspense outside concurrent mode when updating a timed-out tree, always retries the suspended component" time="0.055">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode suspends in a class that has componentWillUnmount and is then deleted" name="ReactSuspense outside concurrent mode suspends in a class that has componentWillUnmount and is then deleted" time="0.053">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode suspends in a component that also contains useEffect" name="ReactSuspense outside concurrent mode suspends in a component that also contains useEffect" time="0.034">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode retries when an update is scheduled on a timed out tree" name="ReactSuspense outside concurrent mode retries when an update is scheduled on a timed out tree" time="0.052">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode does not remount the fallback while suspended children resolve in legacy mode" name="ReactSuspense outside concurrent mode does not remount the fallback while suspended children resolve in legacy mode" time="0.035">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode does not get stuck with fallback in concurrent mode for a large delay" name="ReactSuspense outside concurrent mode does not get stuck with fallback in concurrent mode for a large delay" time="0.05">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode reuses effects, including deletions, from the suspended tree" name="ReactSuspense outside concurrent mode reuses effects, including deletions, from the suspended tree" time="0.037">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode does not warn if an mounted component is pinged" name="ReactSuspense outside concurrent mode does not warn if an mounted component is pinged" time="0.025">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode memoizes promise listeners per thread ID to prevent redundant renders" name="ReactSuspense outside concurrent mode memoizes promise listeners per thread ID to prevent redundant renders" time="0.047">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode #14162" name="ReactSuspense outside concurrent mode #14162" time="0.016">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode updates memoized child of suspense component when context updates (simple memo)" name="ReactSuspense outside concurrent mode updates memoized child of suspense component when context updates (simple memo)" time="0.048">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode updates memoized child of suspense component when context updates (manual memo)" name="ReactSuspense outside concurrent mode updates memoized child of suspense component when context updates (manual memo)" time="0.032">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode updates memoized child of suspense component when context updates (function)" name="ReactSuspense outside concurrent mode updates memoized child of suspense component when context updates (function)" time="0.035">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode updates memoized child of suspense component when context updates (forwardRef)" name="ReactSuspense outside concurrent mode updates memoized child of suspense component when context updates (forwardRef)" time="0.034">
    </testcase>
    <testcase classname="ReactSuspense outside concurrent mode updates context consumer within child of suspended suspense component when context updates" name="ReactSuspense outside concurrent mode updates context consumer within child of suspended suspense component when context updates" time="0.047">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactTopLevelText-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:04" time="0.308" tests="2">
    <testcase classname="ReactTopLevelText should render a component returning strings directly from render" name="ReactTopLevelText should render a component returning strings directly from render" time="0.043">
    </testcase>
    <testcase classname="ReactTopLevelText should render a component returning numbers directly from render" name="ReactTopLevelText should render a component returning numbers directly from render" time="0.031">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIsomorphicAct-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:03" time="1.078" tests="7">
    <testcase classname="isomorphic act() bypasses queueMicrotask" name="isomorphic act() bypasses queueMicrotask" time="0.203">
    </testcase>
    <testcase classname="isomorphic act() return value  sync callback" name="isomorphic act() return value  sync callback" time="0.002">
    </testcase>
    <testcase classname="isomorphic act() return value  sync callback, nested" name="isomorphic act() return value  sync callback, nested" time="0.004">
    </testcase>
    <testcase classname="isomorphic act() return value  async callback" name="isomorphic act() return value  async callback" time="0.04">
    </testcase>
    <testcase classname="isomorphic act() return value  async callback, nested" name="isomorphic act() return value  async callback, nested" time="0.001">
    </testcase>
    <testcase classname="isomorphic act() in legacy mode, updates are batched" name="isomorphic act() in legacy mode, updates are batched" time="0.002">
    </testcase>
    <testcase classname="isomorphic act() in legacy mode, in an async scope, updates are batched until the first `await`" name="isomorphic act() in legacy mode, in an async scope, updates are batched until the first `await`" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactHooks-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:00" time="4.018" tests="73">
    <testcase classname="ReactHooks useDebugValue throws when used in a class component" name="ReactHooks useDebugValue throws when used in a class component" time="0.162">
    </testcase>
    <testcase classname="ReactHooks bails out in the render phase if all of the state is the same" name="ReactHooks bails out in the render phase if all of the state is the same" time="0.057">
    </testcase>
    <testcase classname="ReactHooks bails out in render phase if all the state is the same and props bail out with memo" name="ReactHooks bails out in render phase if all the state is the same and props bail out with memo" time="0.06">
    </testcase>
    <testcase classname="ReactHooks warns about setState second argument" name="ReactHooks warns about setState second argument" time="0.025">
    </testcase>
    <testcase classname="ReactHooks warns about dispatch second argument" name="ReactHooks warns about dispatch second argument" time="0.015">
    </testcase>
    <testcase classname="ReactHooks never bails out if context has changed" name="ReactHooks never bails out if context has changed" time="0.02">
    </testcase>
    <testcase classname="ReactHooks can bail out without calling render phase (as an optimization) if queue is known to be empty" name="ReactHooks can bail out without calling render phase (as an optimization) if queue is known to be empty" time="0.078">
    </testcase>
    <testcase classname="ReactHooks bails out multiple times in a row without entering render phase" name="ReactHooks bails out multiple times in a row without entering render phase" time="0.053">
    </testcase>
    <testcase classname="ReactHooks can rebase on top of a previously skipped update" name="ReactHooks can rebase on top of a previously skipped update" time="0.027">
    </testcase>
    <testcase classname="ReactHooks warns about variable number of dependencies" name="ReactHooks warns about variable number of dependencies" time="0.043">
    </testcase>
    <testcase classname="ReactHooks warns if switching from dependencies to no dependencies" name="ReactHooks warns if switching from dependencies to no dependencies" time="0.058">
    </testcase>
    <testcase classname="ReactHooks warns if deps is not an array" name="ReactHooks warns if deps is not an array" time="0.05">
    </testcase>
    <testcase classname="ReactHooks warns if deps is not an array for useImperativeHandle" name="ReactHooks warns if deps is not an array for useImperativeHandle" time="0.043">
    </testcase>
    <testcase classname="ReactHooks does not forget render phase useState updates inside an effect" name="ReactHooks does not forget render phase useState updates inside an effect" time="0.028">
    </testcase>
    <testcase classname="ReactHooks does not forget render phase useReducer updates inside an effect with hoisted reducer" name="ReactHooks does not forget render phase useReducer updates inside an effect with hoisted reducer" time="0.054">
    </testcase>
    <testcase classname="ReactHooks does not forget render phase useReducer updates inside an effect with inline reducer" name="ReactHooks does not forget render phase useReducer updates inside an effect with inline reducer" time="0.044">
    </testcase>
    <testcase classname="ReactHooks warns for bad useImperativeHandle first arg" name="ReactHooks warns for bad useImperativeHandle first arg" time="0.035">
    </testcase>
    <testcase classname="ReactHooks warns for bad useImperativeHandle second arg" name="ReactHooks warns for bad useImperativeHandle second arg" time="0.075">
    </testcase>
    <testcase classname="ReactHooks works with ReactDOMServer calls inside a component" name="ReactHooks works with ReactDOMServer calls inside a component" time="0.029">
    </testcase>
    <testcase classname="ReactHooks throws when calling hooks inside .memo&apos;s compare function" name="ReactHooks throws when calling hooks inside .memo&apos;s compare function" time="0.023">
    </testcase>
    <testcase classname="ReactHooks warns when calling hooks inside useMemo" name="ReactHooks warns when calling hooks inside useMemo" time="0.044">
    </testcase>
    <testcase classname="ReactHooks warns when reading context inside useMemo" name="ReactHooks warns when reading context inside useMemo" time="0.018">
    </testcase>
    <testcase classname="ReactHooks warns when reading context inside useMemo after reading outside it" name="ReactHooks warns when reading context inside useMemo after reading outside it" time="0.036">
    </testcase>
    <testcase classname="ReactHooks throws when reading context inside useEffect" name="ReactHooks throws when reading context inside useEffect" time="0.016">
    </testcase>
    <testcase classname="ReactHooks throws when reading context inside useLayoutEffect" name="ReactHooks throws when reading context inside useLayoutEffect" time="0.05">
    </testcase>
    <testcase classname="ReactHooks warns when reading context inside useReducer" name="ReactHooks warns when reading context inside useReducer" time="0.043">
    </testcase>
    <testcase classname="ReactHooks warns when reading context inside eager useReducer" name="ReactHooks warns when reading context inside eager useReducer" time="0.047">
    </testcase>
    <testcase classname="ReactHooks warns when calling hooks inside useReducer" name="ReactHooks warns when calling hooks inside useReducer" time="0.019">
    </testcase>
    <testcase classname="ReactHooks warns when calling hooks inside useState&apos;s initialize function" name="ReactHooks warns when calling hooks inside useState&apos;s initialize function" time="0.057">
    </testcase>
    <testcase classname="ReactHooks resets warning internal state when interrupted by an error" name="ReactHooks resets warning internal state when interrupted by an error" time="0.034">
    </testcase>
    <testcase classname="ReactHooks warns when reading context inside useMemo" name="ReactHooks warns when reading context inside useMemo" time="0.03">
    </testcase>
    <testcase classname="ReactHooks double-invokes components with Hooks in Strict Mode" name="ReactHooks double-invokes components with Hooks in Strict Mode" time="0.051">
    </testcase>
    <testcase classname="ReactHooks double-invokes useMemo in DEV StrictMode despite []" name="ReactHooks double-invokes useMemo in DEV StrictMode despite []" time="0.029">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (Callback, DeferredValue) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (Callback, DeferredValue) on subsequent renders" time="0.018">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (Callback, DeferredValue) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (Callback, DeferredValue) are used during update than mount" time="0.04">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (Context, Callback) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (Context, Callback) on subsequent renders" time="0.024">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (Context, Callback) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (Context, Callback) are used during update than mount" time="0.029">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (DebugValue, Context) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (DebugValue, Context) on subsequent renders" time="0.019">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (DebugValue, Context) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (DebugValue, Context) are used during update than mount" time="0.029">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (Effect, DebugValue) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (Effect, DebugValue) on subsequent renders" time="0.023">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (Effect, DebugValue) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (Effect, DebugValue) are used during update than mount" time="0.063">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (LayoutEffect, Effect) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (LayoutEffect, Effect) on subsequent renders" time="0.027">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (LayoutEffect, Effect) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (LayoutEffect, Effect) are used during update than mount" time="0.036">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (Memo, LayoutEffect) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (Memo, LayoutEffect) on subsequent renders" time="0.032">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (Memo, LayoutEffect) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (Memo, LayoutEffect) are used during update than mount" time="0.033">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (Reducer, Memo) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (Reducer, Memo) on subsequent renders" time="0.027">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (Reducer, Memo) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (Reducer, Memo) are used during update than mount" time="0.03">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (Ref, Reducer) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (Ref, Reducer) on subsequent renders" time="0.013">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (Ref, Reducer) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (Ref, Reducer) are used during update than mount" time="0.038">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (State, Ref) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (State, Ref) on subsequent renders" time="0.023">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (State, Ref) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (State, Ref) are used during update than mount" time="0.033">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (Transition, State) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (Transition, State) on subsequent renders" time="0.025">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (Transition, State) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (Transition, State) are used during update than mount" time="0.017">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (DeferredValue, Transition) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (DeferredValue, Transition) on subsequent renders" time="0.029">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when more hooks (DeferredValue, Transition) are used during update than mount" name="ReactHooks hook ordering warns when more hooks (DeferredValue, Transition) are used during update than mount" time="0.031">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (Callback, DeferredValue) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (Callback, DeferredValue) are used during update than mount" time="0.027">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (Effect, Callback) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (Effect, Callback) are used during update than mount" time="0.028">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (ImperativeHandle, Effect) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (ImperativeHandle, Effect) are used during update than mount" time="0.028">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (LayoutEffect, ImperativeHandle) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (LayoutEffect, ImperativeHandle) are used during update than mount" time="0.036">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (Memo, LayoutEffect) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (Memo, LayoutEffect) are used during update than mount" time="0.028">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (Reducer, Memo) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (Reducer, Memo) are used during update than mount" time="0.05">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (Ref, Reducer) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (Ref, Reducer) are used during update than mount" time="0.018">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (State, Ref) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (State, Ref) are used during update than mount" time="0.025">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (Transition, State) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (Transition, State) are used during update than mount" time="0.033">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns when fewer hooks (DeferredValue, Transition) are used during update than mount" name="ReactHooks hook ordering warns when fewer hooks (DeferredValue, Transition) are used during update than mount" time="0.035">
    </testcase>
    <testcase classname="ReactHooks hook ordering warns on using differently ordered hooks (useImperativeHandleHelper, useMemoHelper) on subsequent renders" name="ReactHooks hook ordering warns on using differently ordered hooks (useImperativeHandleHelper, useMemoHelper) on subsequent renders" time="0.026">
    </testcase>
    <testcase classname="ReactHooks hook ordering detects a bad hook order even if the component throws" name="ReactHooks hook ordering detects a bad hook order even if the component throws" time="0.028">
    </testcase>
    <testcase classname="ReactHooks does not swallow original error when updating another component in render phase" name="ReactHooks does not swallow original error when updating another component in render phase" time="0.021">
    </testcase>
    <testcase classname="ReactHooks does not fire a false positive warning when previous effect unmounts the component" name="ReactHooks does not fire a false positive warning when previous effect unmounts the component" time="0.095">
    </testcase>
    <testcase classname="ReactHooks does not fire a false positive warning when suspending memo" name="ReactHooks does not fire a false positive warning when suspending memo" time="0.08">
    </testcase>
    <testcase classname="ReactHooks does not fire a false positive warning when suspending forwardRef" name="ReactHooks does not fire a false positive warning when suspending forwardRef" time="0.042">
    </testcase>
    <testcase classname="ReactHooks does not fire a false positive warning when suspending memo(forwardRef)" name="ReactHooks does not fire a false positive warning when suspending memo(forwardRef)" time="0.058">
    </testcase>
    <testcase classname="ReactHooks resets hooks when an error is thrown in the middle of a list of hooks" name="ReactHooks resets hooks when an error is thrown in the middle of a list of hooks" time="0.102">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactUpdaters-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:04" time="1.262" tests="7">
    <testcase classname="updaters should report the (host) root as the scheduler for root-level render" name="updaters should report the (host) root as the scheduler for root-level render" time="0.153">
    </testcase>
    <testcase classname="updaters should report a function component as the scheduler for a hooks update" name="updaters should report a function component as the scheduler for a hooks update" time="0.05">
    </testcase>
    <testcase classname="updaters should report a class component as the scheduler for a setState update" name="updaters should report a class component as the scheduler for a setState update" time="0.043">
    </testcase>
    <testcase classname="updaters should cover cascading updates" name="updaters should cover cascading updates" time="0.055">
    </testcase>
    <testcase classname="updaters should cover suspense pings" name="updaters should cover suspense pings" time="0.06">
    </testcase>
    <testcase classname="updaters should cover error handling" name="updaters should cover error handling" time="0.052">
    </testcase>
    <testcase classname="updaters should distinguish between updaters in the case of interleaved work" name="updaters should distinguish between updaters in the case of interleaved work" time="0.062">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalErrorReplay-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:05" time="0.319" tests="1">
    <testcase classname="ReactIncrementalErrorReplay-test copies all keys when stashing potentially failing work" name="ReactIncrementalErrorReplay-test copies all keys when stashing potentially failing work" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspensePlaceholder-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:04" time="0.747" tests="7">
    <testcase classname="ReactSuspensePlaceholder times out children that are already hidden" name="ReactSuspensePlaceholder times out children that are already hidden" time="0.08">
    </testcase>
    <testcase classname="ReactSuspensePlaceholder times out text nodes" name="ReactSuspensePlaceholder times out text nodes" time="0.049">
    </testcase>
    <testcase classname="ReactSuspensePlaceholder preserves host context for text nodes" name="ReactSuspensePlaceholder preserves host context for text nodes" time="0.049">
    </testcase>
    <testcase classname="ReactSuspensePlaceholder profiler durations when suspending during mount properly accounts for base durations when a suspended times out in a legacy tree" name="ReactSuspensePlaceholder profiler durations when suspending during mount properly accounts for base durations when a suspended times out in a legacy tree" time="0.048">
    </testcase>
    <testcase classname="ReactSuspensePlaceholder profiler durations when suspending during mount properly accounts for base durations when a suspended times out in a concurrent tree" name="ReactSuspensePlaceholder profiler durations when suspending during mount properly accounts for base durations when a suspended times out in a concurrent tree" time="0.053">
    </testcase>
    <testcase classname="ReactSuspensePlaceholder profiler durations when suspending during update properly accounts for base durations when a suspended times out in a legacy tree" name="ReactSuspensePlaceholder profiler durations when suspending during update properly accounts for base durations when a suspended times out in a legacy tree" time="0.035">
    </testcase>
    <testcase classname="ReactSuspensePlaceholder profiler durations when suspending during update properly accounts for base durations when a suspended times out in a concurrent tree" name="ReactSuspensePlaceholder profiler durations when suspending during update properly accounts for base durations when a suspended times out in a concurrent tree" time="0.031">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactPersistentUpdatesMinimalism-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:05" time="0.585" tests="3">
    <testcase classname="ReactPersistentUpdatesMinimalism should render a simple component" name="ReactPersistentUpdatesMinimalism should render a simple component" time="0.133">
    </testcase>
    <testcase classname="ReactPersistentUpdatesMinimalism should not diff referentially equal host elements" name="ReactPersistentUpdatesMinimalism should not diff referentially equal host elements" time="0.052">
    </testcase>
    <testcase classname="ReactPersistentUpdatesMinimalism should not diff parents of setState targets" name="ReactPersistentUpdatesMinimalism should not diff parents of setState targets" time="0.08">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactNoopRendererAct-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:06" time="0.338" tests="2">
    <testcase classname="internal act() can use act to flush effects" name="internal act() can use act to flush effects" time="0.014">
    </testcase>
    <testcase classname="internal act() should work with async/await" name="internal act() should work with async/await" time="0.017">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactTransitionTracing-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:06" time="0.464" tests="2">
    <testcase classname="ReactInteractionTracing [GATED, SHOULD FAIL] should correctly trace basic interaction" name="ReactInteractionTracing [GATED, SHOULD FAIL] should correctly trace basic interaction" time="0.059">
    </testcase>
    <testcase classname="ReactInteractionTracing [GATED, SHOULD FAIL] should correctly trace interactions for async roots" name="ReactInteractionTracing [GATED, SHOULD FAIL] should correctly trace interactions for async roots" time="0.043">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:06" time="1.249" tests="16">
    <testcase classname="ReactIncrementalUpdates applies updates in order of priority" name="ReactIncrementalUpdates applies updates in order of priority" time="0.051">
    </testcase>
    <testcase classname="ReactIncrementalUpdates applies updates with equal priority in insertion order" name="ReactIncrementalUpdates applies updates with equal priority in insertion order" time="0.051">
    </testcase>
    <testcase classname="ReactIncrementalUpdates only drops updates with equal or lesser priority when replaceState is called" name="ReactIncrementalUpdates only drops updates with equal or lesser priority when replaceState is called" time="0.031">
    </testcase>
    <testcase classname="ReactIncrementalUpdates can abort an update, schedule additional updates, and resume" name="ReactIncrementalUpdates can abort an update, schedule additional updates, and resume" time="0.049">
    </testcase>
    <testcase classname="ReactIncrementalUpdates can abort an update, schedule a replaceState, and resume" name="ReactIncrementalUpdates can abort an update, schedule a replaceState, and resume" time="0.039">
    </testcase>
    <testcase classname="ReactIncrementalUpdates passes accumulation of previous updates to replaceState updater function" name="ReactIncrementalUpdates passes accumulation of previous updates to replaceState updater function" time="0.087">
    </testcase>
    <testcase classname="ReactIncrementalUpdates does not call callbacks that are scheduled by another callback until a later commit" name="ReactIncrementalUpdates does not call callbacks that are scheduled by another callback until a later commit" time="0.023">
    </testcase>
    <testcase classname="ReactIncrementalUpdates gives setState during reconciliation the same priority as whatever level is currently reconciling" name="ReactIncrementalUpdates gives setState during reconciliation the same priority as whatever level is currently reconciling" time="0.044">
    </testcase>
    <testcase classname="ReactIncrementalUpdates updates triggered from inside a class setState updater" name="ReactIncrementalUpdates updates triggered from inside a class setState updater" time="0.02">
    </testcase>
    <testcase classname="ReactIncrementalUpdates getDerivedStateFromProps should update base state of updateQueue (based on product bug)" name="ReactIncrementalUpdates getDerivedStateFromProps should update base state of updateQueue (based on product bug)" time="0.039">
    </testcase>
    <testcase classname="ReactIncrementalUpdates regression: does not expire soon due to layout effects in the last batch" name="ReactIncrementalUpdates regression: does not expire soon due to layout effects in the last batch" time="0.045">
    </testcase>
    <testcase classname="ReactIncrementalUpdates regression: does not expire soon due to previous flushSync" name="ReactIncrementalUpdates regression: does not expire soon due to previous flushSync" time="0.031">
    </testcase>
    <testcase classname="ReactIncrementalUpdates regression: does not expire soon due to previous expired work" name="ReactIncrementalUpdates regression: does not expire soon due to previous expired work" time="0.036">
    </testcase>
    <testcase classname="ReactIncrementalUpdates when rebasing, does not exclude updates that were already committed, regardless of priority" name="ReactIncrementalUpdates when rebasing, does not exclude updates that were already committed, regardless of priority" time="0.029">
    </testcase>
    <testcase classname="ReactIncrementalUpdates when rebasing, does not exclude updates that were already committed, regardless of priority (classes)" name="ReactIncrementalUpdates when rebasing, does not exclude updates that were already committed, regardless of priority (classes)" time="0.051">
    </testcase>
    <testcase classname="ReactIncrementalUpdates base state of update queue is initialized to its fiber&apos;s memoized state" name="ReactIncrementalUpdates base state of update queue is initialized to its fiber&apos;s memoized state" time="0.046">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalSideEffects-test.js" errors="0" failures="0" skipped="2" timestamp="2022-08-05T04:13:06" time="1.753" tests="23">
    <testcase classname="ReactIncrementalSideEffects can update child nodes of a host instance" name="ReactIncrementalSideEffects can update child nodes of a host instance" time="0.078">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can update child nodes of a fragment" name="ReactIncrementalSideEffects can update child nodes of a fragment" time="0.032">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can update child nodes rendering into text nodes" name="ReactIncrementalSideEffects can update child nodes rendering into text nodes" time="0.033">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can deletes children either components, host or text" name="ReactIncrementalSideEffects can deletes children either components, host or text" time="0.026">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can delete a child that changes type - implicit keys" name="ReactIncrementalSideEffects can delete a child that changes type - implicit keys" time="0.036">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can delete a child that changes type - explicit keys" name="ReactIncrementalSideEffects can delete a child that changes type - explicit keys" time="0.026">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can delete a child when it unmounts inside a portal" name="ReactIncrementalSideEffects can delete a child when it unmounts inside a portal" time="0.053">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can delete a child when it unmounts with a portal" name="ReactIncrementalSideEffects can delete a child when it unmounts with a portal" time="0.029">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects does not update child nodes if a flush is aborted" name="ReactIncrementalSideEffects does not update child nodes if a flush is aborted" time="0.038">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects preserves a previously rendered node when deprioritized" name="ReactIncrementalSideEffects preserves a previously rendered node when deprioritized" time="0.034">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can reuse side-effects after being preempted" name="ReactIncrementalSideEffects can reuse side-effects after being preempted" time="0.031">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can reuse side-effects after being preempted, if shouldComponentUpdate is false" name="ReactIncrementalSideEffects can reuse side-effects after being preempted, if shouldComponentUpdate is false" time="0.022">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can update a completed tree before it has a chance to commit" name="ReactIncrementalSideEffects can update a completed tree before it has a chance to commit" time="0.045">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects updates a child even though the old props is empty" name="ReactIncrementalSideEffects updates a child even though the old props is empty" time="0.038">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can defer side-effects and resume them later on" name="ReactIncrementalSideEffects can defer side-effects and resume them later on" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncrementalSideEffects can defer side-effects and reuse them later - complex" name="ReactIncrementalSideEffects can defer side-effects and reuse them later - complex" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncrementalSideEffects deprioritizes setStates that happens within a deprioritized tree" name="ReactIncrementalSideEffects deprioritizes setStates that happens within a deprioritized tree" time="0.055">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects calls callback after update is flushed" name="ReactIncrementalSideEffects calls callback after update is flushed" time="0.107">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects calls setState callback even if component bails out" name="ReactIncrementalSideEffects calls setState callback even if component bails out" time="0.026">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects calls componentWillUnmount after a deletion, even if nested" name="ReactIncrementalSideEffects calls componentWillUnmount after a deletion, even if nested" time="0.027">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects calls componentDidMount/Update after insertion/update" name="ReactIncrementalSideEffects calls componentDidMount/Update after insertion/update" time="0.053">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects invokes ref callbacks after insertion/update/unmount" name="ReactIncrementalSideEffects invokes ref callbacks after insertion/update/unmount" time="0.044">
    </testcase>
    <testcase classname="ReactIncrementalSideEffects supports string refs" name="ReactIncrementalSideEffects supports string refs" time="0.045">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactDisableSchedulerTimeoutBasedOnReactExpirationTime-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:07" time="0.87" tests="1">
    <testcase classname="ReactSuspenseList appends rendering tasks to the end of the priority queue" name="ReactSuspenseList appends rendering tasks to the end of the priority queue" time="0.278">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactActWarnings-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:09" time="0.64" tests="7">
    <testcase classname="act warnings warns about unwrapped updates only if environment flag is enabled" name="act warnings warns about unwrapped updates only if environment flag is enabled" time="0.043">
    </testcase>
    <testcase classname="act warnings act warns if the environment flag is not enabled" name="act warnings act warns if the environment flag is not enabled" time="0.054">
    </testcase>
    <testcase classname="act warnings warns if root update is not wrapped" name="act warnings warns if root update is not wrapped" time="0.022">
    </testcase>
    <testcase classname="act warnings warns if class update is not wrapped" name="act warnings warns if class update is not wrapped" time="0.047">
    </testcase>
    <testcase classname="act warnings warns even if update is synchronous" name="act warnings warns even if update is synchronous" time="0.048">
    </testcase>
    <testcase classname="act warnings warns if Suspense retry is not wrapped" name="act warnings warns if Suspense retry is not wrapped" time="0.029">
    </testcase>
    <testcase classname="act warnings warns if Suspense ping is not wrapped" name="act warnings warns if Suspense ping is not wrapped" time="0.023">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactFragment-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:07" time="2.424" tests="23">
    <testcase classname="ReactFragment should render a single child via noop renderer" name="ReactFragment should render a single child via noop renderer" time="0.089">
    </testcase>
    <testcase classname="ReactFragment should render zero children via noop renderer" name="ReactFragment should render zero children via noop renderer" time="0.049">
    </testcase>
    <testcase classname="ReactFragment should render multiple children via noop renderer" name="ReactFragment should render multiple children via noop renderer" time="0.048">
    </testcase>
    <testcase classname="ReactFragment should render an iterable via noop renderer" name="ReactFragment should render an iterable via noop renderer" time="0.058">
    </testcase>
    <testcase classname="ReactFragment should preserve state of children with 1 level nesting" name="ReactFragment should preserve state of children with 1 level nesting" time="0.027">
    </testcase>
    <testcase classname="ReactFragment should preserve state between top-level fragments" name="ReactFragment should preserve state between top-level fragments" time="0.048">
    </testcase>
    <testcase classname="ReactFragment should preserve state of children nested at same level" name="ReactFragment should preserve state of children nested at same level" time="0.084">
    </testcase>
    <testcase classname="ReactFragment should not preserve state in non-top-level fragment nesting" name="ReactFragment should not preserve state in non-top-level fragment nesting" time="0.053">
    </testcase>
    <testcase classname="ReactFragment should not preserve state of children if nested 2 levels without siblings" name="ReactFragment should not preserve state of children if nested 2 levels without siblings" time="0.14">
    </testcase>
    <testcase classname="ReactFragment should not preserve state of children if nested 2 levels with siblings" name="ReactFragment should not preserve state of children if nested 2 levels with siblings" time="0.083">
    </testcase>
    <testcase classname="ReactFragment should preserve state between array nested in fragment and fragment" name="ReactFragment should preserve state between array nested in fragment and fragment" time="0.104">
    </testcase>
    <testcase classname="ReactFragment should preserve state between top level fragment and array" name="ReactFragment should preserve state between top level fragment and array" time="0.22">
    </testcase>
    <testcase classname="ReactFragment should not preserve state between array nested in fragment and double nested fragment" name="ReactFragment should not preserve state between array nested in fragment and double nested fragment" time="0.123">
    </testcase>
    <testcase classname="ReactFragment should not preserve state between array nested in fragment and double nested array" name="ReactFragment should not preserve state between array nested in fragment and double nested array" time="0.035">
    </testcase>
    <testcase classname="ReactFragment should preserve state between double nested fragment and double nested array" name="ReactFragment should preserve state between double nested fragment and double nested array" time="0.049">
    </testcase>
    <testcase classname="ReactFragment should not preserve state of children when the keys are different" name="ReactFragment should not preserve state of children when the keys are different" time="0.041">
    </testcase>
    <testcase classname="ReactFragment should not preserve state between unkeyed and keyed fragment" name="ReactFragment should not preserve state between unkeyed and keyed fragment" time="0.034">
    </testcase>
    <testcase classname="ReactFragment should preserve state with reordering in multiple levels" name="ReactFragment should preserve state with reordering in multiple levels" time="0.027">
    </testcase>
    <testcase classname="ReactFragment should not preserve state when switching to a keyed fragment to an array" name="ReactFragment should not preserve state when switching to a keyed fragment to an array" time="0.043">
    </testcase>
    <testcase classname="ReactFragment should not preserve state when switching a nested unkeyed fragment to a passthrough component" name="ReactFragment should not preserve state when switching a nested unkeyed fragment to a passthrough component" time="0.056">
    </testcase>
    <testcase classname="ReactFragment should not preserve state when switching a nested keyed fragment to a passthrough component" name="ReactFragment should not preserve state when switching a nested keyed fragment to a passthrough component" time="0.04">
    </testcase>
    <testcase classname="ReactFragment should not preserve state when switching a nested keyed array to a passthrough component" name="ReactFragment should not preserve state when switching a nested keyed array to a passthrough component" time="0.015">
    </testcase>
    <testcase classname="ReactFragment should preserve state when it does not change positions" name="ReactFragment should preserve state when it does not change positions" time="0.049">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactHooksWithNoopRenderer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:04" time="6.698" tests="95">
    <testcase classname="ReactHooksWithNoopRenderer resumes after an interruption" name="ReactHooksWithNoopRenderer resumes after an interruption" time="0.058">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer throws inside class components" name="ReactHooksWithNoopRenderer throws inside class components" time="0.047">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer throws when called outside the render phase" name="ReactHooksWithNoopRenderer throws when called outside the render phase" time="0.021">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useState simple mount and update" name="ReactHooksWithNoopRenderer useState simple mount and update" time="0.035">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useState lazy state initializer" name="ReactHooksWithNoopRenderer useState lazy state initializer" time="0.042">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useState multiple states" name="ReactHooksWithNoopRenderer useState multiple states" time="0.045">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useState returns the same updater function every time" name="ReactHooksWithNoopRenderer useState returns the same updater function every time" time="0.03">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useState does not warn on set after unmount" name="ReactHooksWithNoopRenderer useState does not warn on set after unmount" time="0.026">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useState works with memo" name="ReactHooksWithNoopRenderer useState works with memo" time="0.037">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase restarts the render function and applies the new updates on top" name="ReactHooksWithNoopRenderer updates during the render phase restarts the render function and applies the new updates on top" time="0.03">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase warns about render phase update on a different component" name="ReactHooksWithNoopRenderer updates during the render phase warns about render phase update on a different component" time="0.02">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase keeps restarting until there are no more new updates" name="ReactHooksWithNoopRenderer updates during the render phase keeps restarting until there are no more new updates" time="0.013">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase updates multiple times within same render function" name="ReactHooksWithNoopRenderer updates during the render phase updates multiple times within same render function" time="0.019">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase throws after too many iterations" name="ReactHooksWithNoopRenderer updates during the render phase throws after too many iterations" time="0.018">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase works with useReducer" name="ReactHooksWithNoopRenderer updates during the render phase works with useReducer" time="0.022">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase uses reducer passed at time of render, not time of dispatch" name="ReactHooksWithNoopRenderer updates during the render phase uses reducer passed at time of render, not time of dispatch" time="0.104">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase discards render phase updates if something suspends" name="ReactHooksWithNoopRenderer updates during the render phase discards render phase updates if something suspends" time="0.024">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase discards render phase updates if something suspends, but not other updates in the same component" name="ReactHooksWithNoopRenderer updates during the render phase discards render phase updates if something suspends, but not other updates in the same component" time="0.052">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase regression: render phase updates cause lower pri work to be dropped" name="ReactHooksWithNoopRenderer updates during the render phase regression: render phase updates cause lower pri work to be dropped" time="0.037">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer updates during the render phase calling startTransition inside render phase" name="ReactHooksWithNoopRenderer updates during the render phase calling startTransition inside render phase" time="0.043">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useReducer simple mount and update" name="ReactHooksWithNoopRenderer useReducer simple mount and update" time="0.045">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useReducer lazy init" name="ReactHooksWithNoopRenderer useReducer lazy init" time="0.026">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useReducer handles dispatches with mixed priorities" name="ReactHooksWithNoopRenderer useReducer handles dispatches with mixed priorities" time="0.045">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect simple mount and update" name="ReactHooksWithNoopRenderer useEffect simple mount and update" time="0.057">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect flushes passive effects even with sibling deletions" name="ReactHooksWithNoopRenderer useEffect flushes passive effects even with sibling deletions" time="0.044">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect flushes passive effects even if siblings schedule an update" name="ReactHooksWithNoopRenderer useEffect flushes passive effects even if siblings schedule an update" time="0.034">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect flushes passive effects even if siblings schedule a new root" name="ReactHooksWithNoopRenderer useEffect flushes passive effects even if siblings schedule a new root" time="0.016">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect flushes effects serially by flushing old effects before flushing new ones, if they haven&apos;t already fired" name="ReactHooksWithNoopRenderer useEffect flushes effects serially by flushing old effects before flushing new ones, if they haven&apos;t already fired" time="0.037">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect defers passive effect destroy functions during unmount" name="ReactHooksWithNoopRenderer useEffect defers passive effect destroy functions during unmount" time="0.018">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not warn about state updates for unmounted components with pending passive unmounts" name="ReactHooksWithNoopRenderer useEffect does not warn about state updates for unmounted components with pending passive unmounts" time="0.035">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not warn about state updates for unmounted components with pending passive unmounts for alternates" name="ReactHooksWithNoopRenderer useEffect does not warn about state updates for unmounted components with pending passive unmounts for alternates" time="0.027">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not warn about state updates for unmounted components with no pending passive unmounts" name="ReactHooksWithNoopRenderer useEffect does not warn about state updates for unmounted components with no pending passive unmounts" time="0.03">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not warn if there are pending passive unmount effects but not for the current fiber" name="ReactHooksWithNoopRenderer useEffect does not warn if there are pending passive unmount effects but not for the current fiber" time="0.038">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not warn if there are updates after pending passive unmount effects have been flushed" name="ReactHooksWithNoopRenderer useEffect does not warn if there are updates after pending passive unmount effects have been flushed" time="0.021">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not show a warning when a component updates its own state from within passive unmount function" name="ReactHooksWithNoopRenderer useEffect does not show a warning when a component updates its own state from within passive unmount function" time="0.022">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not show a warning when a component updates a child state from within passive unmount function" name="ReactHooksWithNoopRenderer useEffect does not show a warning when a component updates a child state from within passive unmount function" time="0.026">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not show a warning when a component updates a parents state from within passive unmount function" name="ReactHooksWithNoopRenderer useEffect does not show a warning when a component updates a parents state from within passive unmount function" time="0.026">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect updates have async priority" name="ReactHooksWithNoopRenderer useEffect updates have async priority" time="0.057">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect updates have async priority even if effects are flushed early" name="ReactHooksWithNoopRenderer useEffect updates have async priority even if effects are flushed early" time="0.016">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect does not flush non-discrete passive effects when flushing sync" name="ReactHooksWithNoopRenderer useEffect does not flush non-discrete passive effects when flushing sync" time="0.047">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect in legacy mode, useEffect is deferred and updates finish synchronously (in a single batch)" name="ReactHooksWithNoopRenderer useEffect in legacy mode, useEffect is deferred and updates finish synchronously (in a single batch)" time="0.058">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect flushSync is not allowed" name="ReactHooksWithNoopRenderer useEffect flushSync is not allowed" time="0.077">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect unmounts previous effect" name="ReactHooksWithNoopRenderer useEffect unmounts previous effect" time="0.117">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect unmounts on deletion" name="ReactHooksWithNoopRenderer useEffect unmounts on deletion" time="0.081">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect unmounts on deletion after skipped effect" name="ReactHooksWithNoopRenderer useEffect unmounts on deletion after skipped effect" time="0.129">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect always fires effects if no dependencies are provided" name="ReactHooksWithNoopRenderer useEffect always fires effects if no dependencies are provided" time="0.102">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect skips effect if inputs have not changed" name="ReactHooksWithNoopRenderer useEffect skips effect if inputs have not changed" time="0.195">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect multiple effects" name="ReactHooksWithNoopRenderer useEffect multiple effects" time="0.184">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect unmounts all previous effects before creating any new ones" name="ReactHooksWithNoopRenderer useEffect unmounts all previous effects before creating any new ones" time="0.108">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect unmounts all previous effects between siblings before creating any new ones" name="ReactHooksWithNoopRenderer useEffect unmounts all previous effects between siblings before creating any new ones" time="0.06">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect handles errors in create on mount" name="ReactHooksWithNoopRenderer useEffect handles errors in create on mount" time="0.026">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect handles errors in create on update" name="ReactHooksWithNoopRenderer useEffect handles errors in create on update" time="0.022">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect handles errors in destroy on update" name="ReactHooksWithNoopRenderer useEffect handles errors in destroy on update" time="0.077">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect works with memo" name="ReactHooksWithNoopRenderer useEffect works with memo" time="0.036">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect errors thrown in passive destroy function within unmounted trees should use the nearest still-mounted boundary if there are no unmounted boundaries" name="ReactHooksWithNoopRenderer useEffect errors thrown in passive destroy function within unmounted trees should use the nearest still-mounted boundary if there are no unmounted boundaries" time="0.052">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect errors thrown in passive destroy function within unmounted trees should skip unmounted boundaries and use the nearest still-mounted boundary" name="ReactHooksWithNoopRenderer useEffect errors thrown in passive destroy function within unmounted trees should skip unmounted boundaries and use the nearest still-mounted boundary" time="0.025">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect errors thrown in passive destroy function within unmounted trees should call getDerivedStateFromError in the nearest still-mounted boundary" name="ReactHooksWithNoopRenderer useEffect errors thrown in passive destroy function within unmounted trees should call getDerivedStateFromError in the nearest still-mounted boundary" time="0.053">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect errors thrown in passive destroy function within unmounted trees should rethrow error if there are no still-mounted boundaries" name="ReactHooksWithNoopRenderer useEffect errors thrown in passive destroy function within unmounted trees should rethrow error if there are no still-mounted boundaries" time="0.057">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect calls passive effect destroy functions for memoized components" name="ReactHooksWithNoopRenderer useEffect calls passive effect destroy functions for memoized components" time="0.017">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect calls passive effect destroy functions for descendants of memoized components" name="ReactHooksWithNoopRenderer useEffect calls passive effect destroy functions for descendants of memoized components" time="0.039">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useEffect assumes passive effect destroy function is either a function or undefined" name="ReactHooksWithNoopRenderer useEffect assumes passive effect destroy function is either a function or undefined" time="0.028">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useInsertionEffect fires insertion effects after snapshots on update" name="ReactHooksWithNoopRenderer useInsertionEffect fires insertion effects after snapshots on update" time="0.026">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useInsertionEffect fires insertion effects before layout effects" name="ReactHooksWithNoopRenderer useInsertionEffect fires insertion effects before layout effects" time="0.049">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useInsertionEffect force flushes passive effects before firing new insertion effects" name="ReactHooksWithNoopRenderer useInsertionEffect force flushes passive effects before firing new insertion effects" time="0.031">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useInsertionEffect fires all insertion effects (interleaved) before firing any layout effects" name="ReactHooksWithNoopRenderer useInsertionEffect fires all insertion effects (interleaved) before firing any layout effects" time="0.027">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useInsertionEffect assumes insertion effect destroy function is either a function or undefined" name="ReactHooksWithNoopRenderer useInsertionEffect assumes insertion effect destroy function is either a function or undefined" time="0.029">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useInsertionEffect warns when setState is called from insertion effect setup" name="ReactHooksWithNoopRenderer useInsertionEffect warns when setState is called from insertion effect setup" time="0.055">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useInsertionEffect warns when setState is called from insertion effect cleanup" name="ReactHooksWithNoopRenderer useInsertionEffect warns when setState is called from insertion effect cleanup" time="0.054">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useLayoutEffect fires layout effects after the host has been mutated" name="ReactHooksWithNoopRenderer useLayoutEffect fires layout effects after the host has been mutated" time="0.022">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useLayoutEffect force flushes passive effects before firing new layout effects" name="ReactHooksWithNoopRenderer useLayoutEffect force flushes passive effects before firing new layout effects" time="0.031">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useLayoutEffect catches errors thrown in useLayoutEffect" name="ReactHooksWithNoopRenderer useLayoutEffect catches errors thrown in useLayoutEffect" time="0.046">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useLayoutEffect assumes layout effect destroy function is either a function or undefined" name="ReactHooksWithNoopRenderer useLayoutEffect assumes layout effect destroy function is either a function or undefined" time="0.028">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useCallback memoizes callback by comparing inputs" name="ReactHooksWithNoopRenderer useCallback memoizes callback by comparing inputs" time="0.065">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useMemo memoizes value by comparing to previous inputs" name="ReactHooksWithNoopRenderer useMemo memoizes value by comparing to previous inputs" time="0.042">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useMemo always re-computes if no inputs are provided" name="ReactHooksWithNoopRenderer useMemo always re-computes if no inputs are provided" time="0.024">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useMemo should not invoke memoized function during re-renders unless inputs change" name="ReactHooksWithNoopRenderer useMemo should not invoke memoized function during re-renders unless inputs change" time="0.081">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useImperativeHandle does not update when deps are the same" name="ReactHooksWithNoopRenderer useImperativeHandle does not update when deps are the same" time="0.024">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useImperativeHandle automatically updates when deps are not specified" name="ReactHooksWithNoopRenderer useImperativeHandle automatically updates when deps are not specified" time="0.028">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useImperativeHandle updates when deps are different" name="ReactHooksWithNoopRenderer useImperativeHandle updates when deps are different" time="0.034">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useTransition delays showing loading state until after timeout" name="ReactHooksWithNoopRenderer useTransition delays showing loading state until after timeout" time="0.038">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useDeferredValue defers text value" name="ReactHooksWithNoopRenderer useDeferredValue defers text value" time="0.059">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer progressive enhancement (not supported) mount additional state" name="ReactHooksWithNoopRenderer progressive enhancement (not supported) mount additional state" time="0.075">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer progressive enhancement (not supported) unmount state" name="ReactHooksWithNoopRenderer progressive enhancement (not supported) unmount state" time="0.056">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer progressive enhancement (not supported) unmount effects" name="ReactHooksWithNoopRenderer progressive enhancement (not supported) unmount effects" time="0.022">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useReducer does not eagerly bail out of state updates" name="ReactHooksWithNoopRenderer useReducer does not eagerly bail out of state updates" time="0.031">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useReducer does not replay previous no-op actions when other state changes" name="ReactHooksWithNoopRenderer useReducer does not replay previous no-op actions when other state changes" time="0.032">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useReducer does not replay previous no-op actions when props change" name="ReactHooksWithNoopRenderer useReducer does not replay previous no-op actions when props change" time="0.037">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer useReducer applies potential no-op changes if made relevant by other updates in the batch" name="ReactHooksWithNoopRenderer useReducer applies potential no-op changes if made relevant by other updates in the batch" time="0.043">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer state bail out edge case (#16359)" name="ReactHooksWithNoopRenderer state bail out edge case (#16359)" time="0.071">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer should update latest rendered reducer when a preceding state receives a render phase update" name="ReactHooksWithNoopRenderer should update latest rendered reducer when a preceding state receives a render phase update" time="0.017">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer should process the rest pending updates after a render phase update" name="ReactHooksWithNoopRenderer should process the rest pending updates after a render phase update" time="0.027">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer regression test: don&apos;t unmount effects on siblings of deleted nodes" name="ReactHooksWithNoopRenderer regression test: don&apos;t unmount effects on siblings of deleted nodes" time="0.024">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer regression: deleting a tree and unmounting its effects after a reorder" name="ReactHooksWithNoopRenderer regression: deleting a tree and unmounting its effects after a reorder" time="0.046">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer regression: SuspenseList causes unmounts to be dropped on deletion" name="ReactHooksWithNoopRenderer regression: SuspenseList causes unmounts to be dropped on deletion" time="0.036">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer effect dependencies are persisted after a render phase update" name="ReactHooksWithNoopRenderer effect dependencies are persisted after a render phase update" time="0.027">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ErrorBoundaryReconciliation-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:10" time="0.628" tests="8">
    <testcase classname="ErrorBoundaryReconciliation concurrent componentDidCatch can recover by rendering an element of the same type" name="ErrorBoundaryReconciliation concurrent componentDidCatch can recover by rendering an element of the same type" time="0.052">
    </testcase>
    <testcase classname="ErrorBoundaryReconciliation concurrent componentDidCatch can recover by rendering an element of a different type" name="ErrorBoundaryReconciliation concurrent componentDidCatch can recover by rendering an element of a different type" time="0.046">
    </testcase>
    <testcase classname="ErrorBoundaryReconciliation concurrent getDerivedStateFromError can recover by rendering an element of the same type" name="ErrorBoundaryReconciliation concurrent getDerivedStateFromError can recover by rendering an element of the same type" time="0.046">
    </testcase>
    <testcase classname="ErrorBoundaryReconciliation concurrent getDerivedStateFromError can recover by rendering an element of a different type" name="ErrorBoundaryReconciliation concurrent getDerivedStateFromError can recover by rendering an element of a different type" time="0.021">
    </testcase>
    <testcase classname="ErrorBoundaryReconciliation sync componentDidCatch can recover by rendering an element of the same type" name="ErrorBoundaryReconciliation sync componentDidCatch can recover by rendering an element of the same type" time="0.035">
    </testcase>
    <testcase classname="ErrorBoundaryReconciliation sync componentDidCatch can recover by rendering an element of a different type" name="ErrorBoundaryReconciliation sync componentDidCatch can recover by rendering an element of a different type" time="0.029">
    </testcase>
    <testcase classname="ErrorBoundaryReconciliation sync getDerivedStateFromError can recover by rendering an element of the same type" name="ErrorBoundaryReconciliation sync getDerivedStateFromError can recover by rendering an element of the same type" time="0.061">
    </testcase>
    <testcase classname="ErrorBoundaryReconciliation sync getDerivedStateFromError can recover by rendering an element of a different type" name="ErrorBoundaryReconciliation sync getDerivedStateFromError can recover by rendering an element of a different type" time="0.046">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/StrictEffectsMode-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:11" time="1.205" tests="11">
    <testcase classname="StrictEffectsMode should not double invoke effects in legacy mode" name="StrictEffectsMode should not double invoke effects in legacy mode" time="0.046">
    </testcase>
    <testcase classname="StrictEffectsMode double invoking for effects works properly" name="StrictEffectsMode double invoking for effects works properly" time="0.092">
    </testcase>
    <testcase classname="StrictEffectsMode multiple effects are double invoked in the right order (all mounted, all unmounted, all remounted)" name="StrictEffectsMode multiple effects are double invoked in the right order (all mounted, all unmounted, all remounted)" time="0.017">
    </testcase>
    <testcase classname="StrictEffectsMode multiple layout effects are double invoked in the right order (all mounted, all unmounted, all remounted)" name="StrictEffectsMode multiple layout effects are double invoked in the right order (all mounted, all unmounted, all remounted)" time="0.038">
    </testcase>
    <testcase classname="StrictEffectsMode useEffect and useLayoutEffect is called twice when there is no unmount" name="StrictEffectsMode useEffect and useLayoutEffect is called twice when there is no unmount" time="0.015">
    </testcase>
    <testcase classname="StrictEffectsMode passes the right context to class component lifecycles" name="StrictEffectsMode passes the right context to class component lifecycles" time="0.052">
    </testcase>
    <testcase classname="StrictEffectsMode double invoking works for class components" name="StrictEffectsMode double invoking works for class components" time="0.1">
    </testcase>
    <testcase classname="StrictEffectsMode should not double invoke class lifecycles in legacy mode" name="StrictEffectsMode should not double invoke class lifecycles in legacy mode" time="0.036">
    </testcase>
    <testcase classname="StrictEffectsMode double flushing passive effects only results in one double invoke" name="StrictEffectsMode double flushing passive effects only results in one double invoke" time="0.043">
    </testcase>
    <testcase classname="StrictEffectsMode newly mounted components after initial mount get double invoked" name="StrictEffectsMode newly mounted components after initial mount get double invoked" time="0.017">
    </testcase>
    <testcase classname="StrictEffectsMode classes and functions are double invoked together correctly" name="StrictEffectsMode classes and functions are double invoked together correctly" time="0.058">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactPersistent-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:11" time="0.844" tests="4">
    <testcase classname="ReactPersistent can update child nodes of a host instance" name="ReactPersistent can update child nodes of a host instance" time="0.066">
    </testcase>
    <testcase classname="ReactPersistent can reuse child nodes between updates" name="ReactPersistent can reuse child nodes between updates" time="0.052">
    </testcase>
    <testcase classname="ReactPersistent can update child text nodes" name="ReactPersistent can update child text nodes" time="0.016">
    </testcase>
    <testcase classname="ReactPersistent supports portals" name="ReactPersistent supports portals" time="0.145">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactCPUSuspense-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:11" time="0.787" tests="4">
    <testcase classname="ReactSuspenseWithNoopRenderer skips CPU-bound trees on initial mount" name="ReactSuspenseWithNoopRenderer skips CPU-bound trees on initial mount" time="0.092">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not skip CPU-bound trees during updates" name="ReactSuspenseWithNoopRenderer does not skip CPU-bound trees during updates" time="0.051">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer suspend inside CPU-bound tree" name="ReactSuspenseWithNoopRenderer suspend inside CPU-bound tree" time="0.081">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer nested CPU-bound trees" name="ReactSuspenseWithNoopRenderer nested CPU-bound trees" time="0.039">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalScheduling-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:12" time="0.922" tests="8">
    <testcase classname="ReactIncrementalScheduling schedules and flushes deferred work" name="ReactIncrementalScheduling schedules and flushes deferred work" time="0.057">
    </testcase>
    <testcase classname="ReactIncrementalScheduling searches for work on other roots once the current root completes" name="ReactIncrementalScheduling searches for work on other roots once the current root completes" time="0.033">
    </testcase>
    <testcase classname="ReactIncrementalScheduling schedules top-level updates in order of priority" name="ReactIncrementalScheduling schedules top-level updates in order of priority" time="0.062">
    </testcase>
    <testcase classname="ReactIncrementalScheduling schedules top-level updates with same priority in order of insertion" name="ReactIncrementalScheduling schedules top-level updates with same priority in order of insertion" time="0.087">
    </testcase>
    <testcase classname="ReactIncrementalScheduling works on deferred roots in the order they were scheduled" name="ReactIncrementalScheduling works on deferred roots in the order they were scheduled" time="0.022">
    </testcase>
    <testcase classname="ReactIncrementalScheduling schedules sync updates when inside componentDidMount/Update" name="ReactIncrementalScheduling schedules sync updates when inside componentDidMount/Update" time="0.124">
    </testcase>
    <testcase classname="ReactIncrementalScheduling can opt-in to async scheduling inside componentDidMount/Update" name="ReactIncrementalScheduling can opt-in to async scheduling inside componentDidMount/Update" time="0.077">
    </testcase>
    <testcase classname="ReactIncrementalScheduling performs Task work even after time runs out" name="ReactIncrementalScheduling performs Task work even after time runs out" time="0.02">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactUpdatePriority-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:13" time="0.878" tests="3">
    <testcase classname="ReactUpdatePriority setState inside passive effect triggered by sync update should have default priority" name="ReactUpdatePriority setState inside passive effect triggered by sync update should have default priority" time="0.108">
    </testcase>
    <testcase classname="ReactUpdatePriority setState inside passive effect triggered by idle update should have idle priority" name="ReactUpdatePriority setState inside passive effect triggered by idle update should have idle priority" time="0.02">
    </testcase>
    <testcase classname="ReactUpdatePriority continuous updates should interrupt transitions" name="ReactUpdatePriority continuous updates should interrupt transitions" time="0.078">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspenseList-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:09" time="4.909" tests="40">
    <testcase classname="ReactSuspenseList warns if an unsupported revealOrder option is used" name="ReactSuspenseList warns if an unsupported revealOrder option is used" time="0.037">
    </testcase>
    <testcase classname="ReactSuspenseList warns if a upper case revealOrder option is used" name="ReactSuspenseList warns if a upper case revealOrder option is used" time="0.02">
    </testcase>
    <testcase classname="ReactSuspenseList warns if a misspelled revealOrder option is used" name="ReactSuspenseList warns if a misspelled revealOrder option is used" time="0.104">
    </testcase>
    <testcase classname="ReactSuspenseList warns if a single element is passed to a &quot;forwards&quot; list" name="ReactSuspenseList warns if a single element is passed to a &quot;forwards&quot; list" time="0.083">
    </testcase>
    <testcase classname="ReactSuspenseList warns if a single fragment is passed to a &quot;backwards&quot; list" name="ReactSuspenseList warns if a single fragment is passed to a &quot;backwards&quot; list" time="0.022">
    </testcase>
    <testcase classname="ReactSuspenseList warns if a nested array is passed to a &quot;forwards&quot; list" name="ReactSuspenseList warns if a nested array is passed to a &quot;forwards&quot; list" time="0.059">
    </testcase>
    <testcase classname="ReactSuspenseList shows content independently by default" name="ReactSuspenseList shows content independently by default" time="0.07">
    </testcase>
    <testcase classname="ReactSuspenseList shows content independently in legacy mode regardless of option" name="ReactSuspenseList shows content independently in legacy mode regardless of option" time="0.095">
    </testcase>
    <testcase classname="ReactSuspenseList displays all &quot;together&quot;" name="ReactSuspenseList displays all &quot;together&quot;" time="0.154">
    </testcase>
    <testcase classname="ReactSuspenseList displays all &quot;together&quot; even when nested as siblings" name="ReactSuspenseList displays all &quot;together&quot; even when nested as siblings" time="0.104">
    </testcase>
    <testcase classname="ReactSuspenseList displays all &quot;together&quot; in nested SuspenseLists" name="ReactSuspenseList displays all &quot;together&quot; in nested SuspenseLists" time="0.18">
    </testcase>
    <testcase classname="ReactSuspenseList displays all &quot;together&quot; in nested SuspenseLists where the inner is default" name="ReactSuspenseList displays all &quot;together&quot; in nested SuspenseLists where the inner is default" time="0.129">
    </testcase>
    <testcase classname="ReactSuspenseList displays all &quot;together&quot; during an update" name="ReactSuspenseList displays all &quot;together&quot; during an update" time="0.2">
    </testcase>
    <testcase classname="ReactSuspenseList avoided boundaries can be coordinate with SuspenseList" name="ReactSuspenseList avoided boundaries can be coordinate with SuspenseList" time="0.045">
    </testcase>
    <testcase classname="ReactSuspenseList boundaries without fallbacks can be coordinate with SuspenseList" name="ReactSuspenseList boundaries without fallbacks can be coordinate with SuspenseList" time="0.07">
    </testcase>
    <testcase classname="ReactSuspenseList displays each items in &quot;forwards&quot; order" name="ReactSuspenseList displays each items in &quot;forwards&quot; order" time="0.145">
    </testcase>
    <testcase classname="ReactSuspenseList displays each items in &quot;backwards&quot; order" name="ReactSuspenseList displays each items in &quot;backwards&quot; order" time="0.017">
    </testcase>
    <testcase classname="ReactSuspenseList displays added row at the top &quot;together&quot; and the bottom in &quot;forwards&quot; order" name="ReactSuspenseList displays added row at the top &quot;together&quot; and the bottom in &quot;forwards&quot; order" time="0.061">
    </testcase>
    <testcase classname="ReactSuspenseList displays added row at the top &quot;together&quot; and the bottom in &quot;backwards&quot; order" name="ReactSuspenseList displays added row at the top &quot;together&quot; and the bottom in &quot;backwards&quot; order" time="0.072">
    </testcase>
    <testcase classname="ReactSuspenseList switches to rendering fallbacks if the tail takes long CPU time" name="ReactSuspenseList switches to rendering fallbacks if the tail takes long CPU time" time="0.034">
    </testcase>
    <testcase classname="ReactSuspenseList only shows one loading state at a time for &quot;collapsed&quot; tail insertions" name="ReactSuspenseList only shows one loading state at a time for &quot;collapsed&quot; tail insertions" time="0.063">
    </testcase>
    <testcase classname="ReactSuspenseList warns if an unsupported tail option is used" name="ReactSuspenseList warns if an unsupported tail option is used" time="0.049">
    </testcase>
    <testcase classname="ReactSuspenseList warns if a tail option is used with &quot;together&quot;" name="ReactSuspenseList warns if a tail option is used with &quot;together&quot;" time="0.048">
    </testcase>
    <testcase classname="ReactSuspenseList renders one &quot;collapsed&quot; fallback even if CPU time elapsed" name="ReactSuspenseList renders one &quot;collapsed&quot; fallback even if CPU time elapsed" time="0.021">
    </testcase>
    <testcase classname="ReactSuspenseList adding to the middle does not collapse insertions (forwards)" name="ReactSuspenseList adding to the middle does not collapse insertions (forwards)" time="0.117">
    </testcase>
    <testcase classname="ReactSuspenseList adding to the middle does not collapse insertions (backwards)" name="ReactSuspenseList adding to the middle does not collapse insertions (backwards)" time="0.024">
    </testcase>
    <testcase classname="ReactSuspenseList adding to the middle of committed tail does not collapse insertions" name="ReactSuspenseList adding to the middle of committed tail does not collapse insertions" time="0.155">
    </testcase>
    <testcase classname="ReactSuspenseList only shows no initial loading state &quot;hidden&quot; tail insertions" name="ReactSuspenseList only shows no initial loading state &quot;hidden&quot; tail insertions" time="0.101">
    </testcase>
    <testcase classname="ReactSuspenseList eventually resolves a nested forwards suspense list" name="ReactSuspenseList eventually resolves a nested forwards suspense list" time="0.035">
    </testcase>
    <testcase classname="ReactSuspenseList eventually resolves a nested forwards suspense list with a hidden tail" name="ReactSuspenseList eventually resolves a nested forwards suspense list with a hidden tail" time="0.078">
    </testcase>
    <testcase classname="ReactSuspenseList eventually resolves two nested forwards suspense lists with a hidden tail" name="ReactSuspenseList eventually resolves two nested forwards suspense lists with a hidden tail" time="0.053">
    </testcase>
    <testcase classname="ReactSuspenseList can do unrelated adjacent updates" name="ReactSuspenseList can do unrelated adjacent updates" time="0.024">
    </testcase>
    <testcase classname="ReactSuspenseList is able to re-suspend the last rows during an update with hidden" name="ReactSuspenseList is able to re-suspend the last rows during an update with hidden" time="0.045">
    </testcase>
    <testcase classname="ReactSuspenseList is able to re-suspend the last rows during an update with hidden" name="ReactSuspenseList is able to re-suspend the last rows during an update with hidden" time="0.053">
    </testcase>
    <testcase classname="ReactSuspenseList is able to interrupt a partially rendered tree and continue later" name="ReactSuspenseList is able to interrupt a partially rendered tree and continue later" time="0.063">
    </testcase>
    <testcase classname="ReactSuspenseList can resume class components when revealed together" name="ReactSuspenseList can resume class components when revealed together" time="0.031">
    </testcase>
    <testcase classname="ReactSuspenseList should be able to progressively show CPU expensive rows with two pass rendering" name="ReactSuspenseList should be able to progressively show CPU expensive rows with two pass rendering" time="0.034">
    </testcase>
    <testcase classname="ReactSuspenseList should be able to progressively show rows with two pass rendering and visible" name="ReactSuspenseList should be able to progressively show rows with two pass rendering and visible" time="0.062">
    </testcase>
    <testcase classname="ReactSuspenseList counts the actual duration when profiling a SuspenseList" name="ReactSuspenseList counts the actual duration when profiling a SuspenseList" time="0.048">
    </testcase>
    <testcase classname="ReactSuspenseList propagates despite a memo bailout" name="ReactSuspenseList propagates despite a memo bailout" time="0.054">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspenseFuzz-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:06" time="8.454" tests="6">
    <testcase classname="ReactSuspenseFuzz basic cases" name="ReactSuspenseFuzz basic cases" time="0.057">
    </testcase>
    <testcase classname="ReactSuspenseFuzz generative tests (random seed: default)" name="ReactSuspenseFuzz generative tests (random seed: default)" time="7.814">
    </testcase>
    <testcase classname="ReactSuspenseFuzz hard-coded cases 1" name="ReactSuspenseFuzz hard-coded cases 1" time="0.059">
    </testcase>
    <testcase classname="ReactSuspenseFuzz hard-coded cases 2" name="ReactSuspenseFuzz hard-coded cases 2" time="0.04">
    </testcase>
    <testcase classname="ReactSuspenseFuzz hard-coded cases 3" name="ReactSuspenseFuzz hard-coded cases 3" time="0.033">
    </testcase>
    <testcase classname="ReactSuspenseFuzz hard-coded cases 4" name="ReactSuspenseFuzz hard-coded cases 4" time="0.04">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/useSyncExternalStore-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:15" time="0.441" tests="1">
    <testcase classname="useSyncExternalStore detects interleaved mutations during a concurrent read before layout effects fire" name="useSyncExternalStore detects interleaved mutations during a concurrent read before layout effects fire" time="0.057">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactClassEquivalence2-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:48" time="27.83" tests="1">
    <testcase classname="ReactClassEquivalence tests the same thing for es6 classes and TypeScript" name="ReactClassEquivalence tests the same thing for es6 classes and TypeScript" time="27.522">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactContextPropagation-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:14" time="1.581" tests="14">
    <testcase classname="ReactLazyContextPropagation context change should prevent bailout of memoized component (useMemo -&gt; no intermediate fiber)" name="ReactLazyContextPropagation context change should prevent bailout of memoized component (useMemo -&gt; no intermediate fiber)" time="0.048">
    </testcase>
    <testcase classname="ReactLazyContextPropagation context change should prevent bailout of memoized component (memo HOC)" name="ReactLazyContextPropagation context change should prevent bailout of memoized component (memo HOC)" time="0.069">
    </testcase>
    <testcase classname="ReactLazyContextPropagation context change should prevent bailout of memoized component (PureComponent)" name="ReactLazyContextPropagation context change should prevent bailout of memoized component (PureComponent)" time="0.064">
    </testcase>
    <testcase classname="ReactLazyContextPropagation context consumer bails out if context hasn&apos;t changed" name="ReactLazyContextPropagation context consumer bails out if context hasn&apos;t changed" time="0.018">
    </testcase>
    <testcase classname="ReactLazyContextPropagation context is propagated across retries" name="ReactLazyContextPropagation context is propagated across retries" time="0.023">
    </testcase>
    <testcase classname="ReactLazyContextPropagation multiple contexts are propagated across retries" name="ReactLazyContextPropagation multiple contexts are propagated across retries" time="0.065">
    </testcase>
    <testcase classname="ReactLazyContextPropagation context is propagated across retries (legacy)" name="ReactLazyContextPropagation context is propagated across retries (legacy)" time="0.035">
    </testcase>
    <testcase classname="ReactLazyContextPropagation context is propagated through offscreen trees" name="ReactLazyContextPropagation context is propagated through offscreen trees" time="0.019">
    </testcase>
    <testcase classname="ReactLazyContextPropagation multiple contexts are propagated across through offscreen trees" name="ReactLazyContextPropagation multiple contexts are propagated across through offscreen trees" time="0.073">
    </testcase>
    <testcase classname="ReactLazyContextPropagation contexts are propagated through SuspenseList" name="ReactLazyContextPropagation contexts are propagated through SuspenseList" time="0.023">
    </testcase>
    <testcase classname="ReactLazyContextPropagation nested bailouts" name="ReactLazyContextPropagation nested bailouts" time="0.017">
    </testcase>
    <testcase classname="ReactLazyContextPropagation nested bailouts across retries" name="ReactLazyContextPropagation nested bailouts across retries" time="0.021">
    </testcase>
    <testcase classname="ReactLazyContextPropagation nested bailouts through offscreen trees" name="ReactLazyContextPropagation nested bailouts through offscreen trees" time="0.021">
    </testcase>
    <testcase classname="ReactLazyContextPropagation finds context consumers in multiple sibling branches" name="ReactLazyContextPropagation finds context consumers in multiple sibling branches" time="0.017">
    </testcase>
  </testsuite>
  <testsuite name="packages/react/src/__tests__/ReactClassEquivalence-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:12:48" time="27.935" tests="1">
    <testcase classname="ReactClassEquivalence tests the same thing for es6 classes and CoffeeScript" name="ReactClassEquivalence tests the same thing for es6 classes and CoffeeScript" time="27.062">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactExpiration-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:15" time="1.544" tests="14">
    <testcase classname="ReactExpiration increases priority of updates as time progresses" name="ReactExpiration increases priority of updates as time progresses" time="0.05">
    </testcase>
    <testcase classname="ReactExpiration two updates of like priority in the same event always flush within the same batch" name="ReactExpiration two updates of like priority in the same event always flush within the same batch" time="0.066">
    </testcase>
    <testcase classname="ReactExpiration two updates of like priority in the same event always flush within the same batch, even if there&apos;s a sync update in between" name="ReactExpiration two updates of like priority in the same event always flush within the same batch, even if there&apos;s a sync update in between" time="0.042">
    </testcase>
    <testcase classname="ReactExpiration cannot update at the same expiration time that is already rendering" name="ReactExpiration cannot update at the same expiration time that is already rendering" time="0.021">
    </testcase>
    <testcase classname="ReactExpiration stops yielding if CPU-bound update takes too long to finish" name="ReactExpiration stops yielding if CPU-bound update takes too long to finish" time="0.033">
    </testcase>
    <testcase classname="ReactExpiration root expiration is measured from the time of the first update" name="ReactExpiration root expiration is measured from the time of the first update" time="0.015">
    </testcase>
    <testcase classname="ReactExpiration should measure expiration times relative to module initialization" name="ReactExpiration should measure expiration times relative to module initialization" time="0.129">
    </testcase>
    <testcase classname="ReactExpiration should measure callback timeout relative to current time, not start-up time" name="ReactExpiration should measure callback timeout relative to current time, not start-up time" time="0.055">
    </testcase>
    <testcase classname="ReactExpiration prevents starvation by sync updates by disabling time slicing if too much time has elapsed" name="ReactExpiration prevents starvation by sync updates by disabling time slicing if too much time has elapsed" time="0.066">
    </testcase>
    <testcase classname="ReactExpiration idle work never expires" name="ReactExpiration idle work never expires" time="0.108">
    </testcase>
    <testcase classname="ReactExpiration when multiple lanes expire, we can finish the in-progress one without including the others" name="ReactExpiration when multiple lanes expire, we can finish the in-progress one without including the others" time="0.218">
    </testcase>
    <testcase classname="ReactExpiration updates do not expire while they are IO-bound" name="ReactExpiration updates do not expire while they are IO-bound" time="0.047">
    </testcase>
    <testcase classname="ReactExpiration flushSync should not affect expired work" name="ReactExpiration flushSync should not affect expired work" time="0.053">
    </testcase>
    <testcase classname="ReactExpiration passive effects of expired update flush after paint" name="ReactExpiration passive effects of expired update flush after paint" time="0.047">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/useMutableSource-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:14" time="3.257" tests="31">
    <testcase classname="useMutableSource should subscribe to a source and schedule updates when it changes" name="useMutableSource should subscribe to a source and schedule updates when it changes" time="0.07">
    </testcase>
    <testcase classname="useMutableSource should restart work if a new source is mutated during render" name="useMutableSource should restart work if a new source is mutated during render" time="0.043">
    </testcase>
    <testcase classname="useMutableSource should schedule an update if a new source is mutated between render and commit (subscription)" name="useMutableSource should schedule an update if a new source is mutated between render and commit (subscription)" time="0.03">
    </testcase>
    <testcase classname="useMutableSource should unsubscribe and resubscribe if a new source is used" name="useMutableSource should unsubscribe and resubscribe if a new source is used" time="0.043">
    </testcase>
    <testcase classname="useMutableSource should unsubscribe and resubscribe if a new subscribe function is provided" name="useMutableSource should unsubscribe and resubscribe if a new subscribe function is provided" time="0.055">
    </testcase>
    <testcase classname="useMutableSource should re-use previously read snapshot value when reading is unsafe" name="useMutableSource should re-use previously read snapshot value when reading is unsafe" time="0.035">
    </testcase>
    <testcase classname="useMutableSource should read from source on newly mounted subtree if no pending updates are scheduled for source" name="useMutableSource should read from source on newly mounted subtree if no pending updates are scheduled for source" time="0.026">
    </testcase>
    <testcase classname="useMutableSource should throw and restart render if source and snapshot are unavailable during an update" name="useMutableSource should throw and restart render if source and snapshot are unavailable during an update" time="0.081">
    </testcase>
    <testcase classname="useMutableSource should throw and restart render if source and snapshot are unavailable during a sync update" name="useMutableSource should throw and restart render if source and snapshot are unavailable during a sync update" time="0.049">
    </testcase>
    <testcase classname="useMutableSource should only update components whose subscriptions fire" name="useMutableSource should only update components whose subscriptions fire" time="0.035">
    </testcase>
    <testcase classname="useMutableSource should detect tearing in part of the store not yet subscribed to" name="useMutableSource should detect tearing in part of the store not yet subscribed to" time="0.034">
    </testcase>
    <testcase classname="useMutableSource does not schedule an update for subscriptions that fire with an unchanged snapshot" name="useMutableSource does not schedule an update for subscriptions that fire with an unchanged snapshot" time="0.021">
    </testcase>
    <testcase classname="useMutableSource should throw and restart if getSnapshot changes between scheduled update and re-render" name="useMutableSource should throw and restart if getSnapshot changes between scheduled update and re-render" time="0.039">
    </testcase>
    <testcase classname="useMutableSource should recover from a mutation during yield when other work is scheduled" name="useMutableSource should recover from a mutation during yield when other work is scheduled" time="0.048">
    </testcase>
    <testcase classname="useMutableSource should not throw if the new getSnapshot returns the same snapshot value" name="useMutableSource should not throw if the new getSnapshot returns the same snapshot value" time="0.075">
    </testcase>
    <testcase classname="useMutableSource should not throw if getSnapshot changes but the source can be safely read from anyway" name="useMutableSource should not throw if getSnapshot changes but the source can be safely read from anyway" time="0.023">
    </testcase>
    <testcase classname="useMutableSource should still schedule an update if an eager selector throws after a mutation" name="useMutableSource should still schedule an update if an eager selector throws after a mutation" time="0.052">
    </testcase>
    <testcase classname="useMutableSource should not warn about updates that fire between unmount and passive unsubscribe" name="useMutableSource should not warn about updates that fire between unmount and passive unsubscribe" time="0.026">
    </testcase>
    <testcase classname="useMutableSource should support inline selectors and updates that are processed after selector change" name="useMutableSource should support inline selectors and updates that are processed after selector change" time="0.048">
    </testcase>
    <testcase classname="useMutableSource should clear the update queue when getSnapshot changes with pending lower priority updates" name="useMutableSource should clear the update queue when getSnapshot changes with pending lower priority updates" time="0.144">
    </testcase>
    <testcase classname="useMutableSource should clear the update queue when source changes with pending lower priority updates" name="useMutableSource should clear the update queue when source changes with pending lower priority updates" time="0.284">
    </testcase>
    <testcase classname="useMutableSource should always treat reading as potentially unsafe when getSnapshot changes between renders" name="useMutableSource should always treat reading as potentially unsafe when getSnapshot changes between renders" time="0.28">
    </testcase>
    <testcase classname="useMutableSource getSnapshot changes and then source is mutated in between paint and passive effect phase" name="useMutableSource getSnapshot changes and then source is mutated in between paint and passive effect phase" time="0.176">
    </testcase>
    <testcase classname="useMutableSource getSnapshot changes and then source is mutated in between paint and passive effect phase, case 2" name="useMutableSource getSnapshot changes and then source is mutated in between paint and passive effect phase, case 2" time="0.046">
    </testcase>
    <testcase classname="useMutableSource if source is mutated after initial read but before subscription is set up, should still entangle all pending mutations even if snapshot of new subscription happens to match" name="useMutableSource if source is mutated after initial read but before subscription is set up, should still entangle all pending mutations even if snapshot of new subscription happens to match" time="0.078">
    </testcase>
    <testcase classname="useMutableSource warns about functions being used as snapshot values" name="useMutableSource warns about functions being used as snapshot values" time="0.024">
    </testcase>
    <testcase classname="useMutableSource getSnapshot changes and then source is mutated during interleaved event" name="useMutableSource getSnapshot changes and then source is mutated during interleaved event" time="0.064">
    </testcase>
    <testcase classname="useMutableSource should not tear with newly mounted component when updates were scheduled at a lower priority" name="useMutableSource should not tear with newly mounted component when updates were scheduled at a lower priority" time="0.061">
    </testcase>
    <testcase classname="useMutableSource dev warnings should warn if the subscribe function does not return an unsubscribe function" name="useMutableSource dev warnings should warn if the subscribe function does not return an unsubscribe function" time="0.045">
    </testcase>
    <testcase classname="useMutableSource dev warnings should error if multiple renderers of the same type use a mutable source at the same time" name="useMutableSource dev warnings should error if multiple renderers of the same type use a mutable source at the same time" time="0.082">
    </testcase>
    <testcase classname="useMutableSource dev warnings should error if multiple renderers of the same type use a mutable source at the same time with mutation between" name="useMutableSource dev warnings should error if multiple renderers of the same type use a mutable source at the same time with mutation between" time="0.108">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/StrictEffectsModeDefaults-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:16" time="1.882" tests="13">
    <testcase classname="StrictEffectsMode defaults should not double invoke effects in legacy mode" name="StrictEffectsMode defaults should not double invoke effects in legacy mode" time="0.079">
    </testcase>
    <testcase classname="StrictEffectsMode defaults should not double invoke class lifecycles in legacy mode" name="StrictEffectsMode defaults should not double invoke class lifecycles in legacy mode" time="0.067">
    </testcase>
    <testcase classname="StrictEffectsMode defaults should flush double-invoked effects within the same frame as layout effects if there are no passive effects" name="StrictEffectsMode defaults should flush double-invoked effects within the same frame as layout effects if there are no passive effects" time="0.048">
    </testcase>
    <testcase classname="StrictEffectsMode defaults should double invoke effects only for newly mounted components" name="StrictEffectsMode defaults should double invoke effects only for newly mounted components" time="0.036">
    </testcase>
    <testcase classname="StrictEffectsMode defaults double invoking for effects for modern roots" name="StrictEffectsMode defaults double invoking for effects for modern roots" time="0.059">
    </testcase>
    <testcase classname="StrictEffectsMode defaults multiple effects are double invoked in the right order (all mounted, all unmounted, all remounted)" name="StrictEffectsMode defaults multiple effects are double invoked in the right order (all mounted, all unmounted, all remounted)" time="0.021">
    </testcase>
    <testcase classname="StrictEffectsMode defaults multiple layout effects are double invoked in the right order (all mounted, all unmounted, all remounted)" name="StrictEffectsMode defaults multiple layout effects are double invoked in the right order (all mounted, all unmounted, all remounted)" time="0.017">
    </testcase>
    <testcase classname="StrictEffectsMode defaults useEffect and useLayoutEffect is called twice when there is no unmount" name="StrictEffectsMode defaults useEffect and useLayoutEffect is called twice when there is no unmount" time="0.088">
    </testcase>
    <testcase classname="StrictEffectsMode defaults passes the right context to class component lifecycles" name="StrictEffectsMode defaults passes the right context to class component lifecycles" time="0.016">
    </testcase>
    <testcase classname="StrictEffectsMode defaults double invoking works for class components" name="StrictEffectsMode defaults double invoking works for class components" time="0.059">
    </testcase>
    <testcase classname="StrictEffectsMode defaults double flushing passive effects only results in one double invoke" name="StrictEffectsMode defaults double flushing passive effects only results in one double invoke" time="0.036">
    </testcase>
    <testcase classname="StrictEffectsMode defaults newly mounted components after initial mount get double invoked" name="StrictEffectsMode defaults newly mounted components after initial mount get double invoked" time="0.081">
    </testcase>
    <testcase classname="StrictEffectsMode defaults classes and functions are double invoked together correctly" name="StrictEffectsMode defaults classes and functions are double invoked together correctly" time="0.079">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactConcurrentErrorRecovery-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:16" time="1.542" tests="4">
    <testcase classname="ReactConcurrentErrorRecovery errors during a refresh transition should not force fallbacks to display (suspend then error)" name="ReactConcurrentErrorRecovery errors during a refresh transition should not force fallbacks to display (suspend then error)" time="0.243">
    </testcase>
    <testcase classname="ReactConcurrentErrorRecovery errors during a refresh transition should not force fallbacks to display (error then suspend)" name="ReactConcurrentErrorRecovery errors during a refresh transition should not force fallbacks to display (error then suspend)" time="0.257">
    </testcase>
    <testcase classname="ReactConcurrentErrorRecovery suspending in the shell (outside a Suspense boundary) should not throw, warn, or log during a transition" name="ReactConcurrentErrorRecovery suspending in the shell (outside a Suspense boundary) should not throw, warn, or log during a transition" time="0.144">
    </testcase>
    <testcase classname="ReactConcurrentErrorRecovery errors during a suspended transition at the shell should not force fallbacks to display (error then suspend)" name="ReactConcurrentErrorRecovery errors during a suspended transition at the shell should not force fallbacks to display (error then suspend)" time="0.056">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactFlushSync-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:16" time="1.808" tests="7">
    <testcase classname="ReactFlushSync changes priority of updates in useEffect" name="ReactFlushSync changes priority of updates in useEffect" time="0.132">
    </testcase>
    <testcase classname="ReactFlushSync nested with startTransition" name="ReactFlushSync nested with startTransition" time="0.095">
    </testcase>
    <testcase classname="ReactFlushSync flushes passive effects synchronously when they are the result of a sync render" name="ReactFlushSync flushes passive effects synchronously when they are the result of a sync render" time="0.095">
    </testcase>
    <testcase classname="ReactFlushSync do not flush passive effects synchronously after render in legacy mode" name="ReactFlushSync do not flush passive effects synchronously after render in legacy mode" time="0.303">
    </testcase>
    <testcase classname="ReactFlushSync flush pending passive effects before scope is called in legacy mode" name="ReactFlushSync flush pending passive effects before scope is called in legacy mode" time="0.063">
    </testcase>
    <testcase classname="ReactFlushSync do not flush passive effects synchronously when they aren&apos;t the result of a sync render" name="ReactFlushSync do not flush passive effects synchronously when they aren&apos;t the result of a sync render" time="0.115">
    </testcase>
    <testcase classname="ReactFlushSync does not flush pending passive effects" name="ReactFlushSync does not flush pending passive effects" time="0.027">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/DebugTracing-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:17" time="1.309" tests="13">
    <testcase classname="DebugTracing should not log anything for sync render without suspends or state updates" name="DebugTracing should not log anything for sync render without suspends or state updates" time="0.062">
    </testcase>
    <testcase classname="DebugTracing should not log anything for concurrent render without suspends or state updates" name="DebugTracing should not log anything for concurrent render without suspends or state updates" time="0.085">
    </testcase>
    <testcase classname="DebugTracing should log sync render with suspense" name="DebugTracing should log sync render with suspense" time="0.112">
    </testcase>
    <testcase classname="DebugTracing should log sync render with CPU suspense" name="DebugTracing should log sync render with CPU suspense" time="0.04">
    </testcase>
    <testcase classname="DebugTracing should log concurrent render with suspense" name="DebugTracing should log concurrent render with suspense" time="0.033">
    </testcase>
    <testcase classname="DebugTracing should log concurrent render with CPU suspense" name="DebugTracing should log concurrent render with CPU suspense" time="0.054">
    </testcase>
    <testcase classname="DebugTracing should log cascading class component updates" name="DebugTracing should log cascading class component updates" time="0.044">
    </testcase>
    <testcase classname="DebugTracing should log render phase state updates for class component" name="DebugTracing should log render phase state updates for class component" time="0.075">
    </testcase>
    <testcase classname="DebugTracing should log cascading layout updates" name="DebugTracing should log cascading layout updates" time="0.083">
    </testcase>
    <testcase classname="DebugTracing should log cascading passive updates" name="DebugTracing should log cascading passive updates" time="0.021">
    </testcase>
    <testcase classname="DebugTracing should log render phase updates" name="DebugTracing should log render phase updates" time="0.032">
    </testcase>
    <testcase classname="DebugTracing should log when user code logs" name="DebugTracing should log when user code logs" time="0.028">
    </testcase>
    <testcase classname="DebugTracing should not log anything outside of a unstable_DebugTracingMode subtree" name="DebugTracing should not log anything outside of a unstable_DebugTracingMode subtree" time="0.035">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSchedulerIntegration-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:19" time="0.873" tests="5">
    <testcase classname="ReactSchedulerIntegration passive effects are called before Normal-pri scheduled in layout effects" name="ReactSchedulerIntegration passive effects are called before Normal-pri scheduled in layout effects" time="0.056">
    </testcase>
    <testcase classname="ReactSchedulerIntegration requests a paint after committing" name="ReactSchedulerIntegration requests a paint after committing" time="0.075">
    </testcase>
    <testcase classname="ReactSchedulerIntegration idle updates are not blocked by offscreen work" name="ReactSchedulerIntegration idle updates are not blocked by offscreen work" time="0.065">
    </testcase>
    <testcase classname="regression test: does not infinite loop if `shouldYield` returns true after a partial tree expires using public APIs to trigger real world scenario" name="regression test: does not infinite loop if `shouldYield` returns true after a partial tree expires using public APIs to trigger real world scenario" time="0.016">
    </testcase>
    <testcase classname="regression test: does not infinite loop if `shouldYield` returns true after a partial tree expires mock Scheduler module to check if `shouldYield` is called" name="regression test: does not infinite loop if `shouldYield` returns true after a partial tree expires mock Scheduler module to check if `shouldYield` is called" time="0.084">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactOffscreen-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:18" time="1.306" tests="10">
    <testcase classname="ReactOffscreen unstable-defer-without-hiding should never toggle the visibility of its children" name="ReactOffscreen unstable-defer-without-hiding should never toggle the visibility of its children" time="0.087">
    </testcase>
    <testcase classname="ReactOffscreen does not defer in legacy mode" name="ReactOffscreen does not defer in legacy mode" time="0.05">
    </testcase>
    <testcase classname="ReactOffscreen does defer in concurrent mode" name="ReactOffscreen does defer in concurrent mode" time="0.074">
    </testcase>
    <testcase classname="ReactOffscreen mounts without layout effects when hidden" name="ReactOffscreen mounts without layout effects when hidden" time="0.02">
    </testcase>
    <testcase classname="ReactOffscreen mounts/unmounts layout effects when visibility changes (starting visible)" name="ReactOffscreen mounts/unmounts layout effects when visibility changes (starting visible)" time="0.104">
    </testcase>
    <testcase classname="ReactOffscreen mounts/unmounts layout effects when visibility changes (starting hidden)" name="ReactOffscreen mounts/unmounts layout effects when visibility changes (starting hidden)" time="0.022">
    </testcase>
    <testcase classname="ReactOffscreen hides children of offscreen after layout effects are destroyed" name="ReactOffscreen hides children of offscreen after layout effects are destroyed" time="0.112">
    </testcase>
    <testcase classname="ReactOffscreen does not toggle effects for LegacyHidden component" name="ReactOffscreen does not toggle effects for LegacyHidden component" time="0.026">
    </testcase>
    <testcase classname="ReactOffscreen hides new insertions into an already hidden tree" name="ReactOffscreen hides new insertions into an already hidden tree" time="0.091">
    </testcase>
    <testcase classname="ReactOffscreen hides updated nodes inside an already hidden tree" name="ReactOffscreen hides updated nodes inside an already hidden tree" time="0.031">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspenseFallback-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:19" time="0.865" tests="6">
    <testcase classname="ReactSuspenseFallback suspends and shows fallback" name="ReactSuspenseFallback suspends and shows fallback" time="0.033">
    </testcase>
    <testcase classname="ReactSuspenseFallback suspends and shows null fallback" name="ReactSuspenseFallback suspends and shows null fallback" time="0.028">
    </testcase>
    <testcase classname="ReactSuspenseFallback suspends and shows undefined fallback" name="ReactSuspenseFallback suspends and shows undefined fallback" time="0.071">
    </testcase>
    <testcase classname="ReactSuspenseFallback suspends and shows inner fallback" name="ReactSuspenseFallback suspends and shows inner fallback" time="0.037">
    </testcase>
    <testcase classname="ReactSuspenseFallback suspends and shows inner undefined fallback" name="ReactSuspenseFallback suspends and shows inner undefined fallback" time="0.087">
    </testcase>
    <testcase classname="ReactSuspenseFallback suspends and shows inner null fallback" name="ReactSuspenseFallback suspends and shows inner null fallback" time="0.165">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalErrorReplay-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:20" time="0.378" tests="2">
    <testcase classname="ReactIncrementalErrorReplay should fail gracefully on error in the host environment" name="ReactIncrementalErrorReplay should fail gracefully on error in the host environment" time="0.039">
    </testcase>
    <testcase classname="ReactIncrementalErrorReplay should ignore error if it doesn&apos;t throw on retry" name="ReactIncrementalErrorReplay should ignore error if it doesn&apos;t throw on retry" time="0.053">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspenseWithNoopRenderer-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:13" time="8.054" tests="74">
    <testcase classname="ReactSuspenseWithNoopRenderer does not restart rendering for initial render" name="ReactSuspenseWithNoopRenderer does not restart rendering for initial render" time="0.084">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer suspends rendering and continues later" name="ReactSuspenseWithNoopRenderer suspends rendering and continues later" time="0.038">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer suspends siblings and later recovers each independently" name="ReactSuspenseWithNoopRenderer suspends siblings and later recovers each independently" time="0.052">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer continues rendering siblings after suspending" name="ReactSuspenseWithNoopRenderer continues rendering siblings after suspending" time="0.043">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer [GATED, SHOULD FAIL] retries on error" name="ReactSuspenseWithNoopRenderer [GATED, SHOULD FAIL] retries on error" time="0.05">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer [GATED, SHOULD FAIL] retries on error after falling back to a placeholder" name="ReactSuspenseWithNoopRenderer [GATED, SHOULD FAIL] retries on error after falling back to a placeholder" time="0.055">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer can update at a higher priority while in a suspended state" name="ReactSuspenseWithNoopRenderer can update at a higher priority while in a suspended state" time="0.059">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer keeps working on lower priority work after being pinged" name="ReactSuspenseWithNoopRenderer keeps working on lower priority work after being pinged" time="0.025">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer tries rendering a lower priority pending update even if a higher priority one suspends" name="ReactSuspenseWithNoopRenderer tries rendering a lower priority pending update even if a higher priority one suspends" time="0.09">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer tries each subsequent level after suspending" name="ReactSuspenseWithNoopRenderer tries each subsequent level after suspending" time="0.087">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer forces an expiration after an update times out" name="ReactSuspenseWithNoopRenderer forces an expiration after an update times out" time="0.09">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer switches to an inner fallback after suspending for a while" name="ReactSuspenseWithNoopRenderer switches to an inner fallback after suspending for a while" time="0.212">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer renders an expiration boundary synchronously" name="ReactSuspenseWithNoopRenderer renders an expiration boundary synchronously" time="0.213">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer suspending inside an expired expiration boundary will bubble to the next one" name="ReactSuspenseWithNoopRenderer suspending inside an expired expiration boundary will bubble to the next one" time="0.225">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer expires early by default" name="ReactSuspenseWithNoopRenderer expires early by default" time="0.026">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not expire for transitions" name="ReactSuspenseWithNoopRenderer does not expire for transitions" time="0.146">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer resolves successfully even if fallback render is pending" name="ReactSuspenseWithNoopRenderer resolves successfully even if fallback render is pending" time="0.075">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer errors when an update suspends without a placeholder during a sync update" name="ReactSuspenseWithNoopRenderer errors when an update suspends without a placeholder during a sync update" time="0.067">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer a Suspense component correctly handles more than one suspended child" name="ReactSuspenseWithNoopRenderer a Suspense component correctly handles more than one suspended child" time="0.059">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer can resume rendering earlier than a timeout" name="ReactSuspenseWithNoopRenderer can resume rendering earlier than a timeout" time="0.068">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer starts working on an update even if its priority falls between two suspended levels" name="ReactSuspenseWithNoopRenderer starts working on an update even if its priority falls between two suspended levels" time="0.068">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer flushes all expired updates in a single batch" name="ReactSuspenseWithNoopRenderer flushes all expired updates in a single batch" time="0.049">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer a suspended update that expires" name="ReactSuspenseWithNoopRenderer a suspended update that expires" time="0.04">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer legacy mode mode times out immediately" name="ReactSuspenseWithNoopRenderer legacy mode mode times out immediately" time="0.064">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer legacy mode mode times out immediately when Suspense is in legacy mode" name="ReactSuspenseWithNoopRenderer legacy mode mode times out immediately when Suspense is in legacy mode" time="0.183">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer legacy mode mode does not re-render siblings in loose mode" name="ReactSuspenseWithNoopRenderer legacy mode mode does not re-render siblings in loose mode" time="0.219">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer legacy mode mode suspends inside constructor" name="ReactSuspenseWithNoopRenderer legacy mode mode suspends inside constructor" time="0.156">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer legacy mode mode does not infinite loop if fallback contains lifecycle method" name="ReactSuspenseWithNoopRenderer legacy mode mode does not infinite loop if fallback contains lifecycle method" time="0.092">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer legacy mode mode hides/unhides suspended children before layout effects fire (mutation)" name="ReactSuspenseWithNoopRenderer legacy mode mode hides/unhides suspended children before layout effects fire (mutation)" time="0.026">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer legacy mode mode handles errors in the return path of a component that suspends" name="ReactSuspenseWithNoopRenderer legacy mode mode handles errors in the return path of a component that suspends" time="0.052">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer legacy mode mode does not drop mounted effects" name="ReactSuspenseWithNoopRenderer legacy mode mode does not drop mounted effects" time="0.111">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not call lifecycles of a suspended component" name="ReactSuspenseWithNoopRenderer does not call lifecycles of a suspended component" time="0.036">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not call lifecycles of a suspended component (hooks)" name="ReactSuspenseWithNoopRenderer does not call lifecycles of a suspended component (hooks)" time="0.032">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer suspends for longer if something took a long (CPU bound) time to render" name="ReactSuspenseWithNoopRenderer suspends for longer if something took a long (CPU bound) time to render" time="0.054">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not suspends if a fallback has been shown for a long time" name="ReactSuspenseWithNoopRenderer does not suspends if a fallback has been shown for a long time" time="0.024">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does suspend if a fallback has been shown for a short time" name="ReactSuspenseWithNoopRenderer does suspend if a fallback has been shown for a short time" time="0.074">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not suspend for very long after a higher priority update" name="ReactSuspenseWithNoopRenderer does not suspend for very long after a higher priority update" time="0.047">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not warn when a low priority update suspends inside a high priority update for functional components" name="ReactSuspenseWithNoopRenderer does not warn when a low priority update suspends inside a high priority update for functional components" time="0.034">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not warn when a low priority update suspends inside a high priority update for class components" name="ReactSuspenseWithNoopRenderer does not warn when a low priority update suspends inside a high priority update for class components" time="0.046">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not warn about wrong Suspense priority if no new fallbacks are shown" name="ReactSuspenseWithNoopRenderer does not warn about wrong Suspense priority if no new fallbacks are shown" time="0.058">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not warn when component that triggered user-blocking update is between Suspense boundary and component that suspended" name="ReactSuspenseWithNoopRenderer does not warn when component that triggered user-blocking update is between Suspense boundary and component that suspended" time="0.071">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer normal priority updates suspending do not warn for class components" name="ReactSuspenseWithNoopRenderer normal priority updates suspending do not warn for class components" time="0.072">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer normal priority updates suspending do not warn for functional components" name="ReactSuspenseWithNoopRenderer normal priority updates suspending do not warn for functional components" time="0.042">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer shows the parent fallback if the inner fallback should be avoided" name="ReactSuspenseWithNoopRenderer shows the parent fallback if the inner fallback should be avoided" time="0.032">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not show the parent fallback if the inner fallback is not defined" name="ReactSuspenseWithNoopRenderer does not show the parent fallback if the inner fallback is not defined" time="0.048">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer favors showing the inner fallback for nested top level avoided fallback" name="ReactSuspenseWithNoopRenderer favors showing the inner fallback for nested top level avoided fallback" time="0.058">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer keeps showing an avoided parent fallback if it is already showing" name="ReactSuspenseWithNoopRenderer keeps showing an avoided parent fallback if it is already showing" time="0.064">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer keeps showing an undefined fallback if it is already showing" name="ReactSuspenseWithNoopRenderer keeps showing an undefined fallback if it is already showing" time="0.05">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer commits a suspended idle pri render within a reasonable time" name="ReactSuspenseWithNoopRenderer commits a suspended idle pri render within a reasonable time" time="0.022">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer startTransition top level render" name="ReactSuspenseWithNoopRenderer startTransition top level render" time="0.07">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer startTransition hooks" name="ReactSuspenseWithNoopRenderer startTransition hooks" time="0.104">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer startTransition classes" name="ReactSuspenseWithNoopRenderer startTransition classes" time="0.047">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer delays transitions when using React.startTransition top level render" name="ReactSuspenseWithNoopRenderer delays transitions when using React.startTransition top level render" time="0.131">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer delays transitions when using React.startTransition hooks" name="ReactSuspenseWithNoopRenderer delays transitions when using React.startTransition hooks" time="0.126">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer delays transitions when using React.startTransition classes" name="ReactSuspenseWithNoopRenderer delays transitions when using React.startTransition classes" time="0.143">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer do not show placeholder when updating an avoided boundary with startTransition" name="ReactSuspenseWithNoopRenderer do not show placeholder when updating an avoided boundary with startTransition" time="0.046">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer do not show placeholder when mounting an avoided boundary with startTransition" name="ReactSuspenseWithNoopRenderer do not show placeholder when mounting an avoided boundary with startTransition" time="0.046">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer suspended commit remains suspended even if there&apos;s another update at same expiration" name="ReactSuspenseWithNoopRenderer suspended commit remains suspended even if there&apos;s another update at same expiration" time="0.033">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer regression test: resets current &quot;debug phase&quot; after suspending" name="ReactSuspenseWithNoopRenderer regression test: resets current &quot;debug phase&quot; after suspending" time="0.035">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer should not render hidden content while suspended on higher pri" name="ReactSuspenseWithNoopRenderer should not render hidden content while suspended on higher pri" time="0.098">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer should be able to unblock higher pri content before suspended hidden" name="ReactSuspenseWithNoopRenderer should be able to unblock higher pri content before suspended hidden" time="0.055">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer multiple updates originating inside a Suspense boundary at different priority levels are not dropped" name="ReactSuspenseWithNoopRenderer multiple updates originating inside a Suspense boundary at different priority levels are not dropped" time="0.042">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer multiple updates originating inside a Suspense boundary at different priority levels are not dropped, including Idle updates" name="ReactSuspenseWithNoopRenderer multiple updates originating inside a Suspense boundary at different priority levels are not dropped, including Idle updates" time="0.068">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer fallback component can update itself even after a high pri update to the primary tree suspends" name="ReactSuspenseWithNoopRenderer fallback component can update itself even after a high pri update to the primary tree suspends" time="0.027">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer regression: primary fragment fiber is not always part of setState return path" name="ReactSuspenseWithNoopRenderer regression: primary fragment fiber is not always part of setState return path" time="0.056">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer regression: primary fragment fiber is not always part of setState return path (another case)" name="ReactSuspenseWithNoopRenderer regression: primary fragment fiber is not always part of setState return path (another case)" time="0.031">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer after showing fallback, should not flip back to primary content until the update that suspended finishes" name="ReactSuspenseWithNoopRenderer after showing fallback, should not flip back to primary content until the update that suspended finishes" time="0.052">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer a high pri update can unhide a boundary that suspended at a different level" name="ReactSuspenseWithNoopRenderer a high pri update can unhide a boundary that suspended at a different level" time="0.09">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer [GATED, SHOULD FAIL] regression: ping at high priority causes update to be dropped" name="ReactSuspenseWithNoopRenderer [GATED, SHOULD FAIL] regression: ping at high priority causes update to be dropped" time="0.021">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer does not get stuck in pending state with render phase updates" name="ReactSuspenseWithNoopRenderer does not get stuck in pending state with render phase updates" time="0.052">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer regression: #18657" name="ReactSuspenseWithNoopRenderer regression: #18657" time="0.035">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer retries have lower priority than normal updates" name="ReactSuspenseWithNoopRenderer retries have lower priority than normal updates" time="0.077">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer should fire effect clean-up when deleting suspended tree" name="ReactSuspenseWithNoopRenderer should fire effect clean-up when deleting suspended tree" time="0.071">
    </testcase>
    <testcase classname="ReactSuspenseWithNoopRenderer should fire effect clean-up when deleting suspended tree (legacy)" name="ReactSuspenseWithNoopRenderer should fire effect clean-up when deleting suspended tree (legacy)" time="0.056">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactMemo-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:18" time="3.053" tests="38">
    <testcase classname="memo warns when giving a ref (simple)" name="memo warns when giving a ref (simple)" time="0.056">
    </testcase>
    <testcase classname="memo warns when giving a ref (complex)" name="memo warns when giving a ref (complex)" time="0.114">
    </testcase>
    <testcase classname="memo normal bails out on props equality" name="memo normal bails out on props equality" time="0.055">
    </testcase>
    <testcase classname="memo normal does not bail out if there&apos;s a context change" name="memo normal does not bail out if there&apos;s a context change" time="0.054">
    </testcase>
    <testcase classname="memo normal consistent behavior for reusing props object across different function component types" name="memo normal consistent behavior for reusing props object across different function component types" time="0.032">
    </testcase>
    <testcase classname="memo normal accepts custom comparison function" name="memo normal accepts custom comparison function" time="0.017">
    </testcase>
    <testcase classname="memo normal supports non-pure class components" name="memo normal supports non-pure class components" time="0.049">
    </testcase>
    <testcase classname="memo normal supports defaultProps defined on the memo() return value" name="memo normal supports defaultProps defined on the memo() return value" time="0.075">
    </testcase>
    <testcase classname="memo normal warns if the first argument is undefined" name="memo normal warns if the first argument is undefined" time="0.015">
    </testcase>
    <testcase classname="memo normal warns if the first argument is null" name="memo normal warns if the first argument is null" time="0.014">
    </testcase>
    <testcase classname="memo normal validates propTypes declared on the inner component" name="memo normal validates propTypes declared on the inner component" time="0.016">
    </testcase>
    <testcase classname="memo normal validates propTypes declared on the outer component" name="memo normal validates propTypes declared on the outer component" time="0.021">
    </testcase>
    <testcase classname="memo normal validates nested propTypes declarations" name="memo normal validates nested propTypes declarations" time="0.089">
    </testcase>
    <testcase classname="memo normal does not drop lower priority state updates when bailing out at higher pri (simple)" name="memo normal does not drop lower priority state updates when bailing out at higher pri (simple)" time="0.055">
    </testcase>
    <testcase classname="memo normal does not drop lower priority state updates when bailing out at higher pri (complex)" name="memo normal does not drop lower priority state updates when bailing out at higher pri (complex)" time="0.084">
    </testcase>
    <testcase classname="memo should fall back to showing something meaningful if no displayName or name are present" name="memo should fall back to showing something meaningful if no displayName or name are present" time="0.096">
    </testcase>
    <testcase classname="memo should honor a displayName if set on the inner component in warnings" name="memo should honor a displayName if set on the inner component in warnings" time="0.067">
    </testcase>
    <testcase classname="memo should honor a displayName if set on the memo wrapper in warnings" name="memo should honor a displayName if set on the memo wrapper in warnings" time="0.122">
    </testcase>
    <testcase classname="memo should pass displayName to an anonymous inner component so it shows up in component stacks" name="memo should pass displayName to an anonymous inner component so it shows up in component stacks" time="0.061">
    </testcase>
    <testcase classname="memo should honor a outer displayName when wrapped component and memo component set displayName at the same time." name="memo should honor a outer displayName when wrapped component and memo component set displayName at the same time." time="0.096">
    </testcase>
    <testcase classname="memo lazy bails out on props equality" name="memo lazy bails out on props equality" time="0.131">
    </testcase>
    <testcase classname="memo lazy does not bail out if there&apos;s a context change" name="memo lazy does not bail out if there&apos;s a context change" time="0.051">
    </testcase>
    <testcase classname="memo lazy consistent behavior for reusing props object across different function component types" name="memo lazy consistent behavior for reusing props object across different function component types" time="0.049">
    </testcase>
    <testcase classname="memo lazy accepts custom comparison function" name="memo lazy accepts custom comparison function" time="0.024">
    </testcase>
    <testcase classname="memo lazy supports non-pure class components" name="memo lazy supports non-pure class components" time="0.11">
    </testcase>
    <testcase classname="memo lazy supports defaultProps defined on the memo() return value" name="memo lazy supports defaultProps defined on the memo() return value" time="0.091">
    </testcase>
    <testcase classname="memo lazy warns if the first argument is undefined" name="memo lazy warns if the first argument is undefined" time="0.024">
    </testcase>
    <testcase classname="memo lazy warns if the first argument is null" name="memo lazy warns if the first argument is null" time="0.019">
    </testcase>
    <testcase classname="memo lazy validates propTypes declared on the inner component" name="memo lazy validates propTypes declared on the inner component" time="0.096">
    </testcase>
    <testcase classname="memo lazy validates propTypes declared on the outer component" name="memo lazy validates propTypes declared on the outer component" time="0.039">
    </testcase>
    <testcase classname="memo lazy validates nested propTypes declarations" name="memo lazy validates nested propTypes declarations" time="0.093">
    </testcase>
    <testcase classname="memo lazy does not drop lower priority state updates when bailing out at higher pri (simple)" name="memo lazy does not drop lower priority state updates when bailing out at higher pri (simple)" time="0.042">
    </testcase>
    <testcase classname="memo lazy does not drop lower priority state updates when bailing out at higher pri (complex)" name="memo lazy does not drop lower priority state updates when bailing out at higher pri (complex)" time="0.025">
    </testcase>
    <testcase classname="memo should fall back to showing something meaningful if no displayName or name are present" name="memo should fall back to showing something meaningful if no displayName or name are present" time="0.013">
    </testcase>
    <testcase classname="memo should honor a displayName if set on the inner component in warnings" name="memo should honor a displayName if set on the inner component in warnings" time="0.032">
    </testcase>
    <testcase classname="memo should honor a displayName if set on the memo wrapper in warnings" name="memo should honor a displayName if set on the memo wrapper in warnings" time="0.118">
    </testcase>
    <testcase classname="memo should pass displayName to an anonymous inner component so it shows up in component stacks" name="memo should pass displayName to an anonymous inner component so it shows up in component stacks" time="0.023">
    </testcase>
    <testcase classname="memo should honor a outer displayName when wrapped component and memo component set displayName at the same time." name="memo should honor a outer displayName when wrapped component and memo component set displayName at the same time." time="0.022">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactClassSetStateCallback-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:21" time="0.746" tests="1">
    <testcase classname="ReactClassSetStateCallback regression: setState callback (2nd arg) should only fire once, even after a rebase" name="ReactClassSetStateCallback regression: setState callback (2nd arg) should only fire once, even after a rebase" time="0.071">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactFiberHostContext-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:22" time="0.474" tests="2">
    <testcase classname="ReactFiberHostContext works with null host context" name="ReactFiberHostContext works with null host context" time="0.054">
    </testcase>
    <testcase classname="ReactFiberHostContext should send the context to prepareForCommit and resetAfterCommit" name="ReactFiberHostContext should send the context to prepareForCommit and resetAfterCommit" time="0.031">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactTopLevelFragment-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:21" time="1.214" tests="5">
    <testcase classname="ReactTopLevelFragment should render a simple fragment at the top of a component" name="ReactTopLevelFragment should render a simple fragment at the top of a component" time="0.038">
    </testcase>
    <testcase classname="ReactTopLevelFragment should preserve state when switching from a single child" name="ReactTopLevelFragment should preserve state when switching from a single child" time="0.056">
    </testcase>
    <testcase classname="ReactTopLevelFragment should not preserve state when switching to a nested array" name="ReactTopLevelFragment should not preserve state when switching to a nested array" time="0.024">
    </testcase>
    <testcase classname="ReactTopLevelFragment preserves state if an implicit key slot switches from/to null" name="ReactTopLevelFragment preserves state if an implicit key slot switches from/to null" time="0.051">
    </testcase>
    <testcase classname="ReactTopLevelFragment should preserve state in a reorder" name="ReactTopLevelFragment should preserve state in a reorder" time="0.041">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncremental-test.js" errors="0" failures="0" skipped="15" timestamp="2022-08-05T04:13:19" time="4.182" tests="50">
    <testcase classname="ReactIncremental should render a simple component" name="ReactIncremental should render a simple component" time="0.083">
    </testcase>
    <testcase classname="ReactIncremental should render a simple component, in steps if needed" name="ReactIncremental should render a simple component, in steps if needed" time="0.207">
    </testcase>
    <testcase classname="ReactIncremental updates a previous render" name="ReactIncremental updates a previous render" time="0.13">
    </testcase>
    <testcase classname="ReactIncremental can cancel partially rendered work and restart" name="ReactIncremental can cancel partially rendered work and restart" time="0.131">
    </testcase>
    <testcase classname="ReactIncremental should call callbacks even if updates are aborted" name="ReactIncremental should call callbacks even if updates are aborted" time="0.209">
    </testcase>
    <testcase classname="ReactIncremental can deprioritize unfinished work and resume it later" name="ReactIncremental can deprioritize unfinished work and resume it later" time="0.038">
    </testcase>
    <testcase classname="ReactIncremental can deprioritize a tree from without dropping work" name="ReactIncremental can deprioritize a tree from without dropping work" time="0.029">
    </testcase>
    <testcase classname="ReactIncremental can resume work in a subtree even when a parent bails out" name="ReactIncremental can resume work in a subtree even when a parent bails out" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental can resume work in a bailed subtree within one pass" name="ReactIncremental can resume work in a bailed subtree within one pass" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental can resume mounting a class component" name="ReactIncremental can resume mounting a class component" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental reuses the same instance when resuming a class instance" name="ReactIncremental reuses the same instance when resuming a class instance" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental can reuse work done after being preempted" name="ReactIncremental can reuse work done after being preempted" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental can reuse work that began but did not complete, after being preempted" name="ReactIncremental can reuse work that began but did not complete, after being preempted" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental can reuse work if shouldComponentUpdate is false, after being preempted" name="ReactIncremental can reuse work if shouldComponentUpdate is false, after being preempted" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental memoizes work even if shouldComponentUpdate returns false" name="ReactIncremental memoizes work even if shouldComponentUpdate returns false" time="0.053">
    </testcase>
    <testcase classname="ReactIncremental can update in the middle of a tree using setState" name="ReactIncremental can update in the middle of a tree using setState" time="0.057">
    </testcase>
    <testcase classname="ReactIncremental can queue multiple state updates" name="ReactIncremental can queue multiple state updates" time="0.047">
    </testcase>
    <testcase classname="ReactIncremental can use updater form of setState" name="ReactIncremental can use updater form of setState" time="0.037">
    </testcase>
    <testcase classname="ReactIncremental can call setState inside update callback" name="ReactIncremental can call setState inside update callback" time="0.077">
    </testcase>
    <testcase classname="ReactIncremental can replaceState" name="ReactIncremental can replaceState" time="0.08">
    </testcase>
    <testcase classname="ReactIncremental can forceUpdate" name="ReactIncremental can forceUpdate" time="0.036">
    </testcase>
    <testcase classname="ReactIncremental should clear forceUpdate after update is flushed" name="ReactIncremental should clear forceUpdate after update is flushed" time="0.076">
    </testcase>
    <testcase classname="ReactIncremental can call sCU while resuming a partly mounted component" name="ReactIncremental can call sCU while resuming a partly mounted component" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental gets new props when setting state on a partly updated component" name="ReactIncremental gets new props when setting state on a partly updated component" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental calls componentWillMount twice if the initial render is aborted" name="ReactIncremental calls componentWillMount twice if the initial render is aborted" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental uses state set in componentWillMount even if initial render was aborted" name="ReactIncremental uses state set in componentWillMount even if initial render was aborted" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental calls componentWill* twice if an update render is aborted" name="ReactIncremental calls componentWill* twice if an update render is aborted" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental calls getDerivedStateFromProps even for state-only updates" name="ReactIncremental calls getDerivedStateFromProps even for state-only updates" time="0.088">
    </testcase>
    <testcase classname="ReactIncremental does not call getDerivedStateFromProps if neither state nor props have changed" name="ReactIncremental does not call getDerivedStateFromProps if neither state nor props have changed" time="0.034">
    </testcase>
    <testcase classname="ReactIncremental does not call componentWillReceiveProps for state-only updates" name="ReactIncremental does not call componentWillReceiveProps for state-only updates" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental skips will/DidUpdate when bailing unless an update was already in progress" name="ReactIncremental skips will/DidUpdate when bailing unless an update was already in progress" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental can nest batchedUpdates" name="ReactIncremental can nest batchedUpdates" time="0.066">
    </testcase>
    <testcase classname="ReactIncremental can handle if setState callback throws" name="ReactIncremental can handle if setState callback throws" time="0.037">
    </testcase>
    <testcase classname="ReactIncremental merges and masks context" name="ReactIncremental merges and masks context" time="0.029">
    </testcase>
    <testcase classname="ReactIncremental does not leak own context into context provider" name="ReactIncremental does not leak own context into context provider" time="0.055">
    </testcase>
    <testcase classname="ReactIncremental provides context when reusing work" name="ReactIncremental provides context when reusing work" time="0.057">
    </testcase>
    <testcase classname="ReactIncremental reads context when setState is below the provider" name="ReactIncremental reads context when setState is below the provider" time="0.023">
    </testcase>
    <testcase classname="ReactIncremental reads context when setState is above the provider" name="ReactIncremental reads context when setState is above the provider" time="0.036">
    </testcase>
    <testcase classname="ReactIncremental maintains the correct context when providers bail out due to low priority" name="ReactIncremental maintains the correct context when providers bail out due to low priority" time="0.048">
    </testcase>
    <testcase classname="ReactIncremental maintains the correct context when unwinding due to an error in render" name="ReactIncremental maintains the correct context when unwinding due to an error in render" time="0.087">
    </testcase>
    <testcase classname="ReactIncremental should not recreate masked context unless inputs have changed" name="ReactIncremental should not recreate masked context unless inputs have changed" time="0.067">
    </testcase>
    <testcase classname="ReactIncremental should reuse memoized work if pointers are updated before calling lifecycles" name="ReactIncremental should reuse memoized work if pointers are updated before calling lifecycles" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactIncremental updates descendants with new context values" name="ReactIncremental updates descendants with new context values" time="0.037">
    </testcase>
    <testcase classname="ReactIncremental updates descendants with multiple context-providing ancestors with new context values" name="ReactIncremental updates descendants with multiple context-providing ancestors with new context values" time="0.046">
    </testcase>
    <testcase classname="ReactIncremental should not update descendants with new context values if shouldComponentUpdate returns false" name="ReactIncremental should not update descendants with new context values if shouldComponentUpdate returns false" time="0.029">
    </testcase>
    <testcase classname="ReactIncremental should update descendants with new context values if setState() is called in the middle of the tree" name="ReactIncremental should update descendants with new context values if setState() is called in the middle of the tree" time="0.043">
    </testcase>
    <testcase classname="ReactIncremental does not interrupt for update at same priority" name="ReactIncremental does not interrupt for update at same priority" time="0.024">
    </testcase>
    <testcase classname="ReactIncremental does not interrupt for update at lower priority" name="ReactIncremental does not interrupt for update at lower priority" time="0.071">
    </testcase>
    <testcase classname="ReactIncremental does interrupt for update at higher priority" name="ReactIncremental does interrupt for update at higher priority" time="0.027">
    </testcase>
    <testcase classname="ReactIncremental does not break with a bad Map polyfill" name="ReactIncremental does not break with a bad Map polyfill" time="0.115">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactEffectOrdering-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:23" time="0.398" tests="2">
    <testcase classname="ReactHooksWithNoopRenderer layout unmounts on deletion are fired in parent -&gt; child order" name="ReactHooksWithNoopRenderer layout unmounts on deletion are fired in parent -&gt; child order" time="0.069">
    </testcase>
    <testcase classname="ReactHooksWithNoopRenderer passive unmounts on deletion are fired in parent -&gt; child order" name="ReactHooksWithNoopRenderer passive unmounts on deletion are fired in parent -&gt; child order" time="0.022">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactCache-test.js" errors="0" failures="0" skipped="2" timestamp="2022-08-05T04:13:21" time="2.846" tests="25">
    <testcase classname="ReactCache render Cache component" name="ReactCache render Cache component" time="0.073">
    </testcase>
    <testcase classname="ReactCache mount new data" name="ReactCache mount new data" time="0.039">
    </testcase>
    <testcase classname="ReactCache root acts as implicit cache boundary" name="ReactCache root acts as implicit cache boundary" time="0.08">
    </testcase>
    <testcase classname="ReactCache multiple new Cache boundaries in the same mount share the same, fresh root cache" name="ReactCache multiple new Cache boundaries in the same mount share the same, fresh root cache" time="0.061">
    </testcase>
    <testcase classname="ReactCache multiple new Cache boundaries in the same update share the same, fresh cache" name="ReactCache multiple new Cache boundaries in the same update share the same, fresh cache" time="0.026">
    </testcase>
    <testcase classname="ReactCache nested cache boundaries share the same cache as the root during the initial render" name="ReactCache nested cache boundaries share the same cache as the root during the initial render" time="0.088">
    </testcase>
    <testcase classname="ReactCache new content inside an existing Cache boundary should re-use already cached data" name="ReactCache new content inside an existing Cache boundary should re-use already cached data" time="0.033">
    </testcase>
    <testcase classname="ReactCache a new Cache boundary uses fresh cache" name="ReactCache a new Cache boundary uses fresh cache" time="0.065">
    </testcase>
    <testcase classname="ReactCache inner/outer cache boundaries uses the same cache instance on initial render" name="ReactCache inner/outer cache boundaries uses the same cache instance on initial render" time="0.038">
    </testcase>
    <testcase classname="ReactCache inner/ outer cache boundaries added in the same update use the same cache instance" name="ReactCache inner/ outer cache boundaries added in the same update use the same cache instance" time="0.084">
    </testcase>
    <testcase classname="ReactCache refresh a cache boundary" name="ReactCache refresh a cache boundary" time="0.167">
    </testcase>
    <testcase classname="ReactCache refresh the root cache" name="ReactCache refresh the root cache" time="0.113">
    </testcase>
    <testcase classname="ReactCache refresh the root cache without a transition" name="ReactCache refresh the root cache without a transition" time="0.064">
    </testcase>
    <testcase classname="ReactCache refresh a cache with seed data" name="ReactCache refresh a cache with seed data" time="0.037">
    </testcase>
    <testcase classname="ReactCache refreshing a parent cache also refreshes its children" name="ReactCache refreshing a parent cache also refreshes its children" time="0.026">
    </testcase>
    <testcase classname="ReactCache refreshing a cache boundary does not refresh the other boundaries that mounted at the same time (i.e. the ones that share the same cache)" name="ReactCache refreshing a cache boundary does not refresh the other boundaries that mounted at the same time (i.e. the ones that share the same cache)" time="0.098">
    </testcase>
    <testcase classname="ReactCache mount a new Cache boundary in a sibling while simultaneously resolving a Suspense boundary" name="ReactCache mount a new Cache boundary in a sibling while simultaneously resolving a Suspense boundary" time="0.032">
    </testcase>
    <testcase classname="ReactCache cache pool is cleared once transitions that depend on it commit their shell" name="ReactCache cache pool is cleared once transitions that depend on it commit their shell" time="0.036">
    </testcase>
    <testcase classname="ReactCache cache pool is not cleared by arbitrary commits" name="ReactCache cache pool is not cleared by arbitrary commits" time="0.046">
    </testcase>
    <testcase classname="ReactCache cache boundary uses a fresh cache when its key changes" name="ReactCache cache boundary uses a fresh cache when its key changes" time="0.035">
    </testcase>
    <testcase classname="ReactCache overlapping transitions after an initial mount use the same fresh cache" name="ReactCache overlapping transitions after an initial mount use the same fresh cache" time="0.05">
    </testcase>
    <testcase classname="ReactCache overlapping updates after an initial mount use the same fresh cache" name="ReactCache overlapping updates after an initial mount use the same fresh cache" time="0.102">
    </testcase>
    <testcase classname="ReactCache cleans up cache only used in an aborted transition" name="ReactCache cleans up cache only used in an aborted transition" time="0.085">
    </testcase>
    <testcase classname="ReactCache if a root cache refresh never commits its fresh cache is released" name="ReactCache if a root cache refresh never commits its fresh cache is released" time="0">
      <skipped/>
    </testcase>
    <testcase classname="ReactCache if a cache boundary refresh never commits its fresh cache is released" name="ReactCache if a cache boundary refresh never commits its fresh cache is released" time="0">
      <skipped/>
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspenseEffectsSemantics-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:20" time="3.876" tests="24">
    <testcase classname="ReactSuspenseEffectsSemantics when a component suspends during initial mount should not change behavior in concurrent mode" name="ReactSuspenseEffectsSemantics when a component suspends during initial mount should not change behavior in concurrent mode" time="0.068">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics when a component suspends during initial mount should not change behavior in sync" name="ReactSuspenseEffectsSemantics when a component suspends during initial mount should not change behavior in sync" time="0.083">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should not be destroyed or recreated in legacy roots" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should not be destroyed or recreated in legacy roots" time="0.106">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be destroyed and recreated for function components" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be destroyed and recreated for function components" time="0.049">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be destroyed and recreated for class components" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be destroyed and recreated for class components" time="0.067">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be destroyed and recreated when nested below host components" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be destroyed and recreated when nested below host components" time="0.03">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be destroyed and recreated even if there is a bailout because of memoization" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be destroyed and recreated even if there is a bailout because of memoization" time="0.048">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should respect nested suspense boundaries" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should respect nested suspense boundaries" time="0.073">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should show nested host nodes if multiple boundaries resolve at the same time" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should show nested host nodes if multiple boundaries resolve at the same time" time="0.094">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be cleaned up inside of a fallback that suspends" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be cleaned up inside of a fallback that suspends" time="0.028">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be cleaned up inside of a fallback that suspends (alternate)" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be cleaned up inside of a fallback that suspends (alternate)" time="0.043">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be cleaned up deeper inside of a subtree that suspends" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be cleaned up deeper inside of a subtree that suspends" time="0.04">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update that throw errors are properly handled for componentDidMount" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update that throw errors are properly handled for componentDidMount" time="0.056">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update that throw errors are properly handled for componentWillUnmount" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update that throw errors are properly handled for componentWillUnmount" time="0.041">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update that throw errors are properly handled for layout effect creation" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update that throw errors are properly handled for layout effect creation" time="0.111">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update that throw errors are properly handled for layout effect destruction" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update that throw errors are properly handled for layout effect destruction" time="0.062">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be only destroy layout effects once if a tree suspends in multiple places" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be only destroy layout effects once if a tree suspends in multiple places" time="0.027">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be only destroy layout effects once if a component suspends multiple times" name="ReactSuspenseEffectsSemantics layout effects within a tree that re-suspends in an update should be only destroy layout effects once if a component suspends multiple times" time="0.03">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should not be cleared within legacy roots" name="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should not be cleared within legacy roots" time="0.065">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should be cleared and reset for host components" name="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should be cleared and reset for host components" time="0.028">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should be cleared and reset for class components" name="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should be cleared and reset for class components" time="0.044">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should be cleared and reset for function components with useImperativeHandle" name="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should be cleared and reset for function components with useImperativeHandle" time="0.155">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should not reset for user-managed values" name="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update should not reset for user-managed values" time="0.198">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update that throw errors are properly handled in ref callbacks" name="ReactSuspenseEffectsSemantics refs within a tree that re-suspends in an update that throw errors are properly handled in ref callbacks" time="0.235">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactBatching-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:24" time="0.612" tests="4">
    <testcase classname="ReactBlockingMode updates flush without yielding in the next event" name="ReactBlockingMode updates flush without yielding in the next event" time="0.06">
    </testcase>
    <testcase classname="ReactBlockingMode layout updates flush synchronously in same event" name="ReactBlockingMode layout updates flush synchronously in same event" time="0.049">
    </testcase>
    <testcase classname="ReactBlockingMode uses proper Suspense semantics, not legacy ones" name="ReactBlockingMode uses proper Suspense semantics, not legacy ones" time="0.05">
    </testcase>
    <testcase classname="ReactBlockingMode flushSync does not flush batched work" name="ReactBlockingMode flushSync does not flush batched work" time="0.07">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactDeferredValue-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:23" time="1.286" tests="4">
    <testcase classname="ReactDeferredValue does not cause an infinite defer loop if the original value isn	 memoized" name="ReactDeferredValue does not cause an infinite defer loop if the original value isn	 memoized" time="0.079">
    </testcase>
    <testcase classname="ReactDeferredValue does not defer during a transition" name="ReactDeferredValue does not defer during a transition" time="0.041">
    </testcase>
    <testcase classname="ReactDeferredValue works if there&apos;s a render phase update" name="ReactDeferredValue works if there&apos;s a render phase update" time="0.026">
    </testcase>
    <testcase classname="ReactDeferredValue regression test: during urgent update, reuse previous value, not initial value" name="ReactDeferredValue regression test: during urgent update, reuse previous value, not initial value" time="0.106">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactScope-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:23" time="1.554" tests="10">
    <testcase classname="ReactScope ReactDOM DO_NOT_USE_queryAllNodes() works as intended" name="ReactScope ReactDOM DO_NOT_USE_queryAllNodes() works as intended" time="0.196">
    </testcase>
    <testcase classname="ReactScope ReactDOM DO_NOT_USE_queryAllNodes() provides the correct host instance" name="ReactScope ReactDOM DO_NOT_USE_queryAllNodes() provides the correct host instance" time="0.06">
    </testcase>
    <testcase classname="ReactScope ReactDOM DO_NOT_USE_queryFirstNode() works as intended" name="ReactScope ReactDOM DO_NOT_USE_queryFirstNode() works as intended" time="0.08">
    </testcase>
    <testcase classname="ReactScope ReactDOM containsNode() works as intended" name="ReactScope ReactDOM containsNode() works as intended" time="0.062">
    </testcase>
    <testcase classname="ReactScope ReactDOM scopes support server-side rendering and hydration" name="ReactScope ReactDOM scopes support server-side rendering and hydration" time="0.123">
    </testcase>
    <testcase classname="ReactScope ReactDOM getChildContextValues() works as intended" name="ReactScope ReactDOM getChildContextValues() works as intended" time="0.043">
    </testcase>
    <testcase classname="ReactScope ReactDOM correctly works with suspended boundaries that are hydrated" name="ReactScope ReactDOM correctly works with suspended boundaries that are hydrated" time="0.082">
    </testcase>
    <testcase classname="ReactScope ReactTestRenderer DO_NOT_USE_queryAllNodes() works as intended" name="ReactScope ReactTestRenderer DO_NOT_USE_queryAllNodes() works as intended" time="0.05">
    </testcase>
    <testcase classname="ReactScope ReactTestRenderer DO_NOT_USE_queryFirstNode() works as intended" name="ReactScope ReactTestRenderer DO_NOT_USE_queryFirstNode() works as intended" time="0.03">
    </testcase>
    <testcase classname="ReactScope ReactTestRenderer containsNode() works as intended" name="ReactScope ReactTestRenderer containsNode() works as intended" time="0.145">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactInterleavedUpdates-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:25" time="0.475" tests="3">
    <testcase classname="ReactInterleavedUpdates update during an interleaved event is not processed during the current render" name="ReactInterleavedUpdates update during an interleaved event is not processed during the current render" time="0.049">
    </testcase>
    <testcase classname="ReactInterleavedUpdates [GATED, SHOULD FAIL] low priority update during an interleaved event is not processed during the current render" name="ReactInterleavedUpdates [GATED, SHOULD FAIL] low priority update during an interleaved event is not processed during the current render" time="0.041">
    </testcase>
    <testcase classname="ReactInterleavedUpdates regression for #24350: does not add to main update queue until interleaved update queue has been cleared" name="ReactInterleavedUpdates regression for #24350: does not add to main update queue until interleaved update queue has been cleared" time="0.036">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalUpdatesMinimalism-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:25" time="0.601" tests="3">
    <testcase classname="ReactIncrementalUpdatesMinimalism should render a simple component" name="ReactIncrementalUpdatesMinimalism should render a simple component" time="0.077">
    </testcase>
    <testcase classname="ReactIncrementalUpdatesMinimalism should not diff referentially equal host elements" name="ReactIncrementalUpdatesMinimalism should not diff referentially equal host elements" time="0.035">
    </testcase>
    <testcase classname="ReactIncrementalUpdatesMinimalism should not diff parents of setState targets" name="ReactIncrementalUpdatesMinimalism should not diff parents of setState targets" time="0.073">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactTransition-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:24" time="1.437" tests="10">
    <testcase classname="ReactTransition isPending works even if called from outside an input event" name="ReactTransition isPending works even if called from outside an input event" time="0.061">
    </testcase>
    <testcase classname="ReactTransition when multiple transitions update the same queue, only the most recent one is allowed to finish (no intermediate states)" name="ReactTransition when multiple transitions update the same queue, only the most recent one is allowed to finish (no intermediate states)" time="0.041">
    </testcase>
    <testcase classname="ReactTransition when multiple transitions update the same queue, only the most recent one is allowed to finish (no intermediate states) (classes)" name="ReactTransition when multiple transitions update the same queue, only the most recent one is allowed to finish (no intermediate states) (classes)" time="0.048">
    </testcase>
    <testcase classname="ReactTransition when multiple transitions update overlapping queues, all the transitions across all the queues are entangled" name="ReactTransition when multiple transitions update overlapping queues, all the transitions across all the queues are entangled" time="0.072">
    </testcase>
    <testcase classname="ReactTransition interrupt a refresh transition if a new transition is scheduled" name="ReactTransition interrupt a refresh transition if a new transition is scheduled" time="0.23">
    </testcase>
    <testcase classname="ReactTransition interrupt a refresh transition when something suspends and we&apos;ve already bailed out on another transition in a parent" name="ReactTransition interrupt a refresh transition when something suspends and we&apos;ve already bailed out on another transition in a parent" time="0.139">
    </testcase>
    <testcase classname="ReactTransition interrupt a refresh transition when something suspends and a parent component received an interleaved update after its queue was processed" name="ReactTransition interrupt a refresh transition when something suspends and a parent component received an interleaved update after its queue was processed" time="0.057">
    </testcase>
    <testcase classname="ReactTransition should render normal pri updates scheduled after transitions before transitions" name="ReactTransition should render normal pri updates scheduled after transitions before transitions" time="0.053">
    </testcase>
    <testcase classname="ReactTransition should render normal pri updates before transition suspense retries" name="ReactTransition should render normal pri updates before transition suspense retries" time="0.124">
    </testcase>
    <testcase classname="ReactTransition should not interrupt transitions with normal pri updates" name="ReactTransition should not interrupt transitions with normal pri updates" time="0.017">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/useRef-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:25" time="0.736" tests="11">
    <testcase classname="useRef creates a ref object initialized with the provided value" name="useRef creates a ref object initialized with the provided value" time="0.04">
    </testcase>
    <testcase classname="useRef should return the same ref during re-renders" name="useRef should return the same ref during re-renders" time="0.002">
    </testcase>
    <testcase classname="useRef should never warn when attaching to children" name="useRef should never warn when attaching to children" time="0.002">
    </testcase>
    <testcase classname="useRef should warn about reads during render" name="useRef should warn about reads during render" time="0.002">
    </testcase>
    <testcase classname="useRef should not warn about lazy init during render" name="useRef should not warn about lazy init during render" time="0.004">
    </testcase>
    <testcase classname="useRef should not warn about lazy init outside of render" name="useRef should not warn about lazy init outside of render" time="0.001">
    </testcase>
    <testcase classname="useRef should warn about unconditional lazy init during render" name="useRef should warn about unconditional lazy init during render" time="0.002">
    </testcase>
    <testcase classname="useRef should warn about reads to ref after lazy init pattern" name="useRef should warn about reads to ref after lazy init pattern" time="0.022">
    </testcase>
    <testcase classname="useRef should warn about writes to ref after lazy init pattern" name="useRef should warn about writes to ref after lazy init pattern" time="0.002">
    </testcase>
    <testcase classname="useRef should not warn about reads or writes within effect" name="useRef should not warn about reads or writes within effect" time="0.002">
    </testcase>
    <testcase classname="useRef should not warn about reads or writes outside of render phase (e.g. event handler)" name="useRef should not warn about reads or writes outside of render phase (e.g. event handler)" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalReflection-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:26" time="0.524" tests="3">
    <testcase classname="ReactIncrementalReflection handles isMounted even when the initial render is deferred" name="ReactIncrementalReflection handles isMounted even when the initial render is deferred" time="0.047">
    </testcase>
    <testcase classname="ReactIncrementalReflection handles isMounted when an unmount is deferred" name="ReactIncrementalReflection handles isMounted when an unmount is deferred" time="0.045">
    </testcase>
    <testcase classname="ReactIncrementalReflection finds no node before insertion and correct node before deletion" name="ReactIncrementalReflection finds no node before insertion and correct node before deletion" time="0.113">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspenseCallback-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:26" time="0.615" tests="5">
    <testcase classname="ReactSuspense check type" name="ReactSuspense check type" time="0.048">
    </testcase>
    <testcase classname="ReactSuspense 1 then 0 suspense callback" name="ReactSuspense 1 then 0 suspense callback" time="0.043">
    </testcase>
    <testcase classname="ReactSuspense 2 then 1 then 0 suspense callback" name="ReactSuspense 2 then 1 then 0 suspense callback" time="0.037">
    </testcase>
    <testcase classname="ReactSuspense nested suspense promises are reported only for their tier" name="ReactSuspense nested suspense promises are reported only for their tier" time="0.029">
    </testcase>
    <testcase classname="ReactSuspense competing suspense promises" name="ReactSuspense competing suspense promises" time="0.038">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSubtreeFlagsWarning-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:27" time="0.352" tests="1">
    <testcase classname="ReactSuspenseWithNoopRenderer regression: false positive for legacy suspense" name="ReactSuspenseWithNoopRenderer regression: false positive for legacy suspense" time="0.059">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactLazy-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:23" time="3.69" tests="39">
    <testcase classname="ReactLazy suspends until module has loaded" name="ReactLazy suspends until module has loaded" time="0.077">
    </testcase>
    <testcase classname="ReactLazy can resolve synchronously without suspending" name="ReactLazy can resolve synchronously without suspending" time="0.055">
    </testcase>
    <testcase classname="ReactLazy can reject synchronously without suspending" name="ReactLazy can reject synchronously without suspending" time="0.094">
    </testcase>
    <testcase classname="ReactLazy multiple lazy components" name="ReactLazy multiple lazy components" time="0.036">
    </testcase>
    <testcase classname="ReactLazy does not support arbitrary promises, only module objects" name="ReactLazy does not support arbitrary promises, only module objects" time="0.096">
    </testcase>
    <testcase classname="ReactLazy throws if promise rejects" name="ReactLazy throws if promise rejects" time="0.024">
    </testcase>
    <testcase classname="ReactLazy mount and reorder" name="ReactLazy mount and reorder" time="0.041">
    </testcase>
    <testcase classname="ReactLazy resolves defaultProps, on mount and update" name="ReactLazy resolves defaultProps, on mount and update" time="0.038">
    </testcase>
    <testcase classname="ReactLazy resolves defaultProps without breaking memoization" name="ReactLazy resolves defaultProps without breaking memoization" time="0.069">
    </testcase>
    <testcase classname="ReactLazy resolves defaultProps without breaking bailout due to unchanged props and state, #17151" name="ReactLazy resolves defaultProps without breaking bailout due to unchanged props and state, #17151" time="0.035">
    </testcase>
    <testcase classname="ReactLazy resolves defaultProps without breaking bailout in PureComponent, #17151" name="ReactLazy resolves defaultProps without breaking bailout in PureComponent, #17151" time="0.075">
    </testcase>
    <testcase classname="ReactLazy sets defaultProps for modern lifecycles" name="ReactLazy sets defaultProps for modern lifecycles" time="0.035">
    </testcase>
    <testcase classname="ReactLazy sets defaultProps for legacy lifecycles" name="ReactLazy sets defaultProps for legacy lifecycles" time="0.034">
    </testcase>
    <testcase classname="ReactLazy resolves defaultProps on the outer wrapper but warns" name="ReactLazy resolves defaultProps on the outer wrapper but warns" time="0.058">
    </testcase>
    <testcase classname="ReactLazy throws with a useful error when wrapping invalid type with lazy()" name="ReactLazy throws with a useful error when wrapping invalid type with lazy()" time="0.026">
    </testcase>
    <testcase classname="ReactLazy throws with a useful error when wrapping lazy() multiple times" name="ReactLazy throws with a useful error when wrapping lazy() multiple times" time="0.045">
    </testcase>
    <testcase classname="ReactLazy warns about defining propTypes on the outer wrapper" name="ReactLazy warns about defining propTypes on the outer wrapper" time="0.066">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on function component with defaultProps" name="ReactLazy respects propTypes on function component with defaultProps" time="0.039">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on function component without defaultProps" name="ReactLazy respects propTypes on function component without defaultProps" time="0.049">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on class component with defaultProps" name="ReactLazy respects propTypes on class component with defaultProps" time="0.041">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on class component without defaultProps" name="ReactLazy respects propTypes on class component without defaultProps" time="0.04">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on forwardRef component with defaultProps" name="ReactLazy respects propTypes on forwardRef component with defaultProps" time="0.036">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on forwardRef component without defaultProps" name="ReactLazy respects propTypes on forwardRef component without defaultProps" time="0.04">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on outer memo component with defaultProps" name="ReactLazy respects propTypes on outer memo component with defaultProps" time="0.046">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on outer memo component without defaultProps" name="ReactLazy respects propTypes on outer memo component without defaultProps" time="0.018">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on inner memo component with defaultProps" name="ReactLazy respects propTypes on inner memo component with defaultProps" time="0.168">
    </testcase>
    <testcase classname="ReactLazy respects propTypes on inner memo component without defaultProps" name="ReactLazy respects propTypes on inner memo component without defaultProps" time="0.119">
    </testcase>
    <testcase classname="ReactLazy uses outer resolved props for validating propTypes on memo" name="ReactLazy uses outer resolved props for validating propTypes on memo" time="0.06">
    </testcase>
    <testcase classname="ReactLazy includes lazy-loaded component in warning stack" name="ReactLazy includes lazy-loaded component in warning stack" time="0.18">
    </testcase>
    <testcase classname="ReactLazy supports class and forwardRef components" name="ReactLazy supports class and forwardRef components" time="0.03">
    </testcase>
    <testcase classname="ReactLazy supports defaultProps defined on the memo() return value" name="ReactLazy supports defaultProps defined on the memo() return value" time="0.045">
    </testcase>
    <testcase classname="ReactLazy merges defaultProps in the correct order" name="ReactLazy merges defaultProps in the correct order" time="0.058">
    </testcase>
    <testcase classname="ReactLazy warns about ref on functions for lazy-loaded components" name="ReactLazy warns about ref on functions for lazy-loaded components" time="0.031">
    </testcase>
    <testcase classname="ReactLazy should error with a component stack naming the resolved component" name="ReactLazy should error with a component stack naming the resolved component" time="0.043">
    </testcase>
    <testcase classname="ReactLazy should error with a component stack containing Lazy if unresolved" name="ReactLazy should error with a component stack containing Lazy if unresolved" time="0.045">
    </testcase>
    <testcase classname="ReactLazy mount and reorder lazy types" name="ReactLazy mount and reorder lazy types" time="0.059">
    </testcase>
    <testcase classname="ReactLazy mount and reorder lazy types (legacy mode)" name="ReactLazy mount and reorder lazy types (legacy mode)" time="0.034">
    </testcase>
    <testcase classname="ReactLazy mount and reorder lazy elements" name="ReactLazy mount and reorder lazy elements" time="0.037">
    </testcase>
    <testcase classname="ReactLazy mount and reorder lazy elements (legacy mode)" name="ReactLazy mount and reorder lazy elements (legacy mode)" time="0.045">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactSuspenseEffectsSemanticsDOM-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:26" time="1.162" tests="7">
    <testcase classname="ReactSuspenseEffectsSemanticsDOM should not cause a cycle when combined with a render phase update" name="ReactSuspenseEffectsSemanticsDOM should not cause a cycle when combined with a render phase update" time="0.139">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemanticsDOM does not destroy ref cleanup twice when hidden child is removed" name="ReactSuspenseEffectsSemanticsDOM does not destroy ref cleanup twice when hidden child is removed" time="0.091">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemanticsDOM does not call componentWillUnmount twice when hidden child is removed" name="ReactSuspenseEffectsSemanticsDOM does not call componentWillUnmount twice when hidden child is removed" time="0.046">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemanticsDOM does not destroy layout effects twice when parent suspense is removed" name="ReactSuspenseEffectsSemanticsDOM does not destroy layout effects twice when parent suspense is removed" time="0.072">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemanticsDOM does not destroy ref cleanup twice when parent suspense is removed" name="ReactSuspenseEffectsSemanticsDOM does not destroy ref cleanup twice when parent suspense is removed" time="0.042">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemanticsDOM does not call componentWillUnmount twice when parent suspense is removed" name="ReactSuspenseEffectsSemanticsDOM does not call componentWillUnmount twice when parent suspense is removed" time="0.087">
    </testcase>
    <testcase classname="ReactSuspenseEffectsSemanticsDOM regression: unmount hidden tree, in legacy mode" name="ReactSuspenseEffectsSemanticsDOM regression: unmount hidden tree, in legacy mode" time="0.055">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-server-dom-relay/src/__tests__/ReactDOMServerFB-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:28" time="0.645" tests="7">
    <testcase classname="ReactDOMServerFB should be able to render basic HTML" name="ReactDOMServerFB should be able to render basic HTML" time="0.146">
    </testcase>
    <testcase classname="ReactDOMServerFB should emit bootstrap script src at the end" name="ReactDOMServerFB should emit bootstrap script src at the end" time="0.038">
    </testcase>
    <testcase classname="ReactDOMServerFB emits all HTML as one unit if we wait until the end to start" name="ReactDOMServerFB emits all HTML as one unit if we wait until the end to start" time="0.01">
    </testcase>
    <testcase classname="ReactDOMServerFB should throw an error when an error is thrown at the root" name="ReactDOMServerFB should throw an error when an error is thrown at the root" time="0.009">
    </testcase>
    <testcase classname="ReactDOMServerFB should throw an error when an error is thrown inside a fallback" name="ReactDOMServerFB should throw an error when an error is thrown inside a fallback" time="0.014">
    </testcase>
    <testcase classname="ReactDOMServerFB should not throw an error when an error is thrown inside suspense boundary" name="ReactDOMServerFB should not throw an error when an error is thrown inside suspense boundary" time="0.05">
    </testcase>
    <testcase classname="ReactDOMServerFB should be able to complete by aborting even if the promise never resolves" name="ReactDOMServerFB should be able to complete by aborting even if the promise never resolves" time="0.013">
    </testcase>
  </testsuite>
  <testsuite name="scripts/shared/__tests__/evalToString-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:28" time="0.631" tests="3">
    <testcase classname="evalToString should support StringLiteral" name="evalToString should support StringLiteral" time="0.007">
    </testcase>
    <testcase classname="evalToString should support string concat (`+`)" name="evalToString should support string concat (`+`)" time="0.003">
    </testcase>
    <testcase classname="evalToString should throw when it finds other types" name="evalToString should throw when it finds other types" time="0.033">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-server-dom-relay/src/__tests__/ReactFlightDOMRelay-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:28" time="1.348" tests="6">
    <testcase classname="ReactFlightDOMRelay can render a server component" name="ReactFlightDOMRelay can render a server component" time="0.584">
    </testcase>
    <testcase classname="ReactFlightDOMRelay can render a client component using a module reference and render there" name="ReactFlightDOMRelay can render a client component using a module reference and render there" time="0.081">
    </testcase>
    <testcase classname="ReactFlightDOMRelay can reasonably handle different element types" name="ReactFlightDOMRelay can reasonably handle different element types" time="0.053">
    </testcase>
    <testcase classname="ReactFlightDOMRelay can handle a subset of Hooks" name="ReactFlightDOMRelay can handle a subset of Hooks" time="0.067">
    </testcase>
    <testcase classname="ReactFlightDOMRelay can handle a subset of Hooks, with element as root" name="ReactFlightDOMRelay can handle a subset of Hooks, with element as root" time="0.047">
    </testcase>
    <testcase classname="ReactFlightDOMRelay should warn in DEV if a class instance polyfill is passed to a host component" name="ReactFlightDOMRelay should warn in DEV if a class instance polyfill is passed to a host component" time="0.064">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-client/src/__tests__/ReactFlight-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:27" time="2.259" tests="22">
    <testcase classname="ReactFlight can render a server component" name="ReactFlight can render a server component" time="0.307">
    </testcase>
    <testcase classname="ReactFlight can render a client component using a module reference and render there" name="ReactFlight can render a client component using a module reference and render there" time="0.117">
    </testcase>
    <testcase classname="ReactFlight can render a lazy component as a shared component on the server" name="ReactFlight can render a lazy component as a shared component on the server" time="0.1">
    </testcase>
    <testcase classname="ReactFlight errors on a Lazy element being used in Component position" name="ReactFlight errors on a Lazy element being used in Component position" time="0.067">
    </testcase>
    <testcase classname="ReactFlight can render a lazy element" name="ReactFlight can render a lazy element" time="0.127">
    </testcase>
    <testcase classname="ReactFlight errors with lazy value in element position that resolves to Component" name="ReactFlight errors with lazy value in element position that resolves to Component" time="0.073">
    </testcase>
    <testcase classname="ReactFlight can render a lazy module reference" name="ReactFlight can render a lazy module reference" time="0.107">
    </testcase>
    <testcase classname="ReactFlight should error if a non-serializable value is passed to a host component" name="ReactFlight should error if a non-serializable value is passed to a host component" time="0.162">
    </testcase>
    <testcase classname="ReactFlight should trigger the inner most error boundary inside a client component" name="ReactFlight should trigger the inner most error boundary inside a client component" time="0.074">
    </testcase>
    <testcase classname="ReactFlight should warn in DEV if a toJSON instance is passed to a host component" name="ReactFlight should warn in DEV if a toJSON instance is passed to a host component" time="0.047">
    </testcase>
    <testcase classname="ReactFlight should warn in DEV if a special object is passed to a host component" name="ReactFlight should warn in DEV if a special object is passed to a host component" time="0.033">
    </testcase>
    <testcase classname="ReactFlight should NOT warn in DEV for key getters" name="ReactFlight should NOT warn in DEV for key getters" time="0.038">
    </testcase>
    <testcase classname="ReactFlight should warn in DEV if an object with symbols is passed to a host component" name="ReactFlight should warn in DEV if an object with symbols is passed to a host component" time="0.046">
    </testcase>
    <testcase classname="ReactFlight should warn in DEV if a class instance is passed to a host component" name="ReactFlight should warn in DEV if a class instance is passed to a host component" time="0.037">
    </testcase>
    <testcase classname="ReactFlight ServerContext supports basic createServerContext usage" name="ReactFlight ServerContext supports basic createServerContext usage" time="0.025">
    </testcase>
    <testcase classname="ReactFlight ServerContext propagates ServerContext providers in flight" name="ReactFlight ServerContext propagates ServerContext providers in flight" time="0.026">
    </testcase>
    <testcase classname="ReactFlight ServerContext errors if you try passing JSX through ServerContext value" name="ReactFlight ServerContext errors if you try passing JSX through ServerContext value" time="0.019">
    </testcase>
    <testcase classname="ReactFlight ServerContext propagates ServerContext and cleansup providers in flight" name="ReactFlight ServerContext propagates ServerContext and cleansup providers in flight" time="0.045">
    </testcase>
    <testcase classname="ReactFlight ServerContext propagates ServerContext providers in flight after suspending" name="ReactFlight ServerContext propagates ServerContext providers in flight after suspending" time="0.055">
    </testcase>
    <testcase classname="ReactFlight ServerContext serializes ServerContext to client" name="ReactFlight ServerContext serializes ServerContext to client" time="0.02">
    </testcase>
    <testcase classname="ReactFlight ServerContext takes ServerContext from client for refetching usecases" name="ReactFlight ServerContext takes ServerContext from client for refetching usecases" time="0.035">
    </testcase>
    <testcase classname="ReactFlight ServerContext sets default initial value when defined lazily on server or client" name="ReactFlight ServerContext sets default initial value when defined lazily on server or client" time="0.07">
    </testcase>
  </testsuite>
  <testsuite name="scripts/babel/__tests__/transform-prevent-infinite-loops-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:29" time="0.505" tests="2">
    <testcase classname="transform-prevent-infinite-loops fails the test for `while` loops" name="transform-prevent-infinite-loops fails the test for `while` loops" time="0.013">
    </testcase>
    <testcase classname="transform-prevent-infinite-loops fails the test for `for` loops" name="transform-prevent-infinite-loops fails the test for `for` loops" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="scripts/babel/__tests__/transform-test-gate-pragma-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:29" time="0.535" tests="29">
    <testcase classname="transform-test-gate-pragma no pragma" name="transform-test-gate-pragma no pragma" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma no pragma, unrelated comment" name="transform-test-gate-pragma no pragma, unrelated comment" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma basic positive test" name="transform-test-gate-pragma basic positive test" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma basic negative test" name="transform-test-gate-pragma basic negative test" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma it method" name="transform-test-gate-pragma it method" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma test.only" name="transform-test-gate-pragma test.only" time="0.006">
    </testcase>
    <testcase classname="transform-test-gate-pragma it.only" name="transform-test-gate-pragma it.only" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma fit" name="transform-test-gate-pragma fit" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma flag negation" name="transform-test-gate-pragma flag negation" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma multiple gates" name="transform-test-gate-pragma multiple gates" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma multiple gates 2" name="transform-test-gate-pragma multiple gates 2" time="0.003">
    </testcase>
    <testcase classname="transform-test-gate-pragma &amp;&amp;" name="transform-test-gate-pragma &amp;&amp;" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma ||" name="transform-test-gate-pragma ||" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma groups" name="transform-test-gate-pragma groups" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma ==" name="transform-test-gate-pragma ==" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma ===" name="transform-test-gate-pragma ===" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma !=" name="transform-test-gate-pragma !=" time="0.043">
    </testcase>
    <testcase classname="transform-test-gate-pragma !==" name="transform-test-gate-pragma !==" time="0.004">
    </testcase>
    <testcase classname="transform-test-gate-pragma true" name="transform-test-gate-pragma true" time="0">
    </testcase>
    <testcase classname="transform-test-gate-pragma false" name="transform-test-gate-pragma false" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma double quoted strings" name="transform-test-gate-pragma double quoted strings" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma single quoted strings" name="transform-test-gate-pragma single quoted strings" time="0.001">
    </testcase>
    <testcase classname="transform-test-gate-pragma line comment" name="transform-test-gate-pragma line comment" time="0">
    </testcase>
    <testcase classname="transform test-gate-pragma: actual runtime __DEV__" name="transform test-gate-pragma: actual runtime __DEV__" time="0">
    </testcase>
    <testcase classname="transform test-gate-pragma: actual runtime strings" name="transform test-gate-pragma: actual runtime strings" time="0">
    </testcase>
    <testcase classname="transform test-gate-pragma: actual runtime [GATED, SHOULD FAIL] works with console.error tracking" name="transform test-gate-pragma: actual runtime [GATED, SHOULD FAIL] works with console.error tracking" time="0.002">
    </testcase>
    <testcase classname="transform test-gate-pragma: actual runtime [GATED, SHOULD FAIL] works with console.warn tracking" name="transform test-gate-pragma: actual runtime [GATED, SHOULD FAIL] works with console.warn tracking" time="0">
    </testcase>
    <testcase classname="transform test-gate-pragma: actual runtime [GATED, SHOULD FAIL] works with console tracking if error is thrown before end of test" name="transform test-gate-pragma: actual runtime [GATED, SHOULD FAIL] works with console tracking if error is thrown before end of test" time="0">
    </testcase>
    <testcase classname="dynamic gate method returns same conditions as pragma" name="dynamic gate method returns same conditions as pragma" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="packages/use-subscription/src/__tests__/useSubscription-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:27" time="2.881" tests="9">
    <testcase classname="useSubscription supports basic subscription pattern" name="useSubscription supports basic subscription pattern" time="1.116">
    </testcase>
    <testcase classname="useSubscription should support observable types like RxJS ReplaySubject" name="useSubscription should support observable types like RxJS ReplaySubject" time="0.27">
    </testcase>
    <testcase classname="useSubscription should unsubscribe from old sources and subscribe to new sources when memoized props change" name="useSubscription should unsubscribe from old sources and subscribe to new sources when memoized props change" time="0.152">
    </testcase>
    <testcase classname="useSubscription should unsubscribe from old sources and subscribe to new sources when useCallback functions change" name="useSubscription should unsubscribe from old sources and subscribe to new sources when useCallback functions change" time="0.157">
    </testcase>
    <testcase classname="useSubscription should ignore values emitted by a new subscribable until the commit phase" name="useSubscription should ignore values emitted by a new subscribable until the commit phase" time="0.128">
    </testcase>
    <testcase classname="useSubscription should not drop values emitted between updates" name="useSubscription should not drop values emitted between updates" time="0.122">
    </testcase>
    <testcase classname="useSubscription should guard against updates that happen after unmounting" name="useSubscription should guard against updates that happen after unmounting" time="0.165">
    </testcase>
    <testcase classname="useSubscription does not return a value from the previous subscription if the source is updated" name="useSubscription does not return a value from the previous subscription if the source is updated" time="0.117">
    </testcase>
    <testcase classname="useSubscription should not tear if a mutation occurs during a concurrent update" name="useSubscription should not tear if a mutation occurs during a concurrent update" time="0.126">
    </testcase>
  </testsuite>
  <testsuite name="scripts/error-codes/__tests__/invertObject-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:30" time="0.626" tests="4">
    <testcase classname="invertObject should return an empty object for an empty input" name="invertObject should return an empty object for an empty input" time="0.001">
    </testcase>
    <testcase classname="invertObject should invert key-values" name="invertObject should invert key-values" time="0.001">
    </testcase>
    <testcase classname="invertObject should take the last value when there are duplications in vals" name="invertObject should take the last value when there are duplications in vals" time="0">
    </testcase>
    <testcase classname="invertObject should preserve the original order" name="invertObject should preserve the original order" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="scripts/eslint-rules/__tests__/no-primitive-constructors-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:30" time="0.886" tests="5">
    <testcase classname="eslint-rules/no-primitive-constructors valid !!obj" name="eslint-rules/no-primitive-constructors valid !!obj" time="0.159">
    </testcase>
    <testcase classname="eslint-rules/no-primitive-constructors valid +string" name="eslint-rules/no-primitive-constructors valid +string" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/no-primitive-constructors invalid Boolean(obj)" name="eslint-rules/no-primitive-constructors invalid Boolean(obj)" time="0.004">
    </testcase>
    <testcase classname="eslint-rules/no-primitive-constructors invalid new String(obj)" name="eslint-rules/no-primitive-constructors invalid new String(obj)" time="0.001">
    </testcase>
    <testcase classname="eslint-rules/no-primitive-constructors invalid Number(string)" name="eslint-rules/no-primitive-constructors invalid Number(string)" time="0.019">
    </testcase>
  </testsuite>
  <testsuite name="scripts/error-codes/__tests__/transform-error-messages.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:30" time="2.122" tests="9">
    <testcase classname="error transform should replace error constructors" name="error transform should replace error constructors" time="1.18">
    </testcase>
    <testcase classname="error transform should replace error constructors (no new)" name="error transform should replace error constructors (no new)" time="0.008">
    </testcase>
    <testcase classname="error transform should output FIXME for errors that don&apos;t have a matching error code" name="error transform should output FIXME for errors that don&apos;t have a matching error code" time="0.004">
    </testcase>
    <testcase classname="error transform should output FIXME for errors that don&apos;t have a matching error code, unless opted out with a comment" name="error transform should output FIXME for errors that don&apos;t have a matching error code, unless opted out with a comment" time="0.024">
    </testcase>
    <testcase classname="error transform should not touch other calls or new expressions" name="error transform should not touch other calls or new expressions" time="0.023">
    </testcase>
    <testcase classname="error transform should support interpolating arguments with template strings" name="error transform should support interpolating arguments with template strings" time="0.006">
    </testcase>
    <testcase classname="error transform should support interpolating arguments with concatenation" name="error transform should support interpolating arguments with concatenation" time="0.023">
    </testcase>
    <testcase classname="error transform should support error constructors with concatenated messages" name="error transform should support error constructors with concatenated messages" time="0.004">
    </testcase>
    <testcase classname="error transform handles escaped backticks in template string" name="error transform handles escaped backticks in template string" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="scripts/eslint-rules/__tests__/no-production-logging-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:31" time="1.631" tests="24">
    <testcase classname="no-production-logging valid 
        if (__DEV__) {
          console.error(&apos;Oh no&apos;);
        }
      " name="no-production-logging valid 
        if (__DEV__) {
          console.error(&apos;Oh no&apos;);
        }
      " time="0.118">
    </testcase>
    <testcase classname="no-production-logging valid 
        if (__DEV__) {
          console.error(&apos;Hello %s&apos;, foo)
        }
      " name="no-production-logging valid 
        if (__DEV__) {
          console.error(&apos;Hello %s&apos;, foo)
        }
      " time="0.009">
    </testcase>
    <testcase classname="no-production-logging valid 
        if (__DEV__) {
          console.error(&apos;Hello %s %s&apos;, foo, bar)
        }
      " name="no-production-logging valid 
        if (__DEV__) {
          console.error(&apos;Hello %s %s&apos;, foo, bar)
        }
      " time="0.003">
    </testcase>
    <testcase classname="no-production-logging valid 
        if (__DEV__) {
          console.warn(&apos;Oh no&apos;);
        }
      " name="no-production-logging valid 
        if (__DEV__) {
          console.warn(&apos;Oh no&apos;);
        }
      " time="0.003">
    </testcase>
    <testcase classname="no-production-logging valid 
        if (__DEV__) {
          console.warn(&apos;Oh no&apos;);
        }
      " name="no-production-logging valid 
        if (__DEV__) {
          console.warn(&apos;Oh no&apos;);
        }
      " time="0.002">
    </testcase>
    <testcase classname="no-production-logging valid 
        if (__DEV__) {
          if (potato) {
            while (true) {
              console.error(&apos;Oh no&apos;);
            }
          }
        }" name="no-production-logging valid 
        if (__DEV__) {
          if (potato) {
            while (true) {
              console.error(&apos;Oh no&apos;);
            }
          }
        }" time="0.004">
    </testcase>
    <testcase classname="no-production-logging valid 
        var f;
        if (__DEV__) {
          f = function() {
            if (potato) {
              while (true) {
                console.error(&apos;Oh no&apos;);
              }
            }
          };
        }" name="no-production-logging valid 
        var f;
        if (__DEV__) {
          f = function() {
            if (potato) {
              while (true) {
                console.error(&apos;Oh no&apos;);
              }
            }
          };
        }" time="0.064">
    </testcase>
    <testcase classname="no-production-logging valid normalFunctionCall(test);" name="no-production-logging valid normalFunctionCall(test);" time="0.008">
    </testcase>
    <testcase classname="no-production-logging valid invariant(test);" name="no-production-logging valid invariant(test);" time="0.001">
    </testcase>
    <testcase classname="no-production-logging valid 
        if (__DEV__) {
          normalFunctionCall(test);
        }
      " name="no-production-logging valid 
        if (__DEV__) {
          normalFunctionCall(test);
        }
      " time="0.005">
    </testcase>
    <testcase classname="no-production-logging valid 
        if (__DEV__) {
          if (foo) {
            if (__DEV__) {
            } else {
              console.error(&apos;Oh no&apos;);
            }
          }
        }" name="no-production-logging valid 
        if (__DEV__) {
          if (foo) {
            if (__DEV__) {
            } else {
              console.error(&apos;Oh no&apos;);
            }
          }
        }" time="0.004">
    </testcase>
    <testcase classname="no-production-logging valid 
        console[&apos;error&apos;](&apos;Oh no&apos;);
      " name="no-production-logging valid 
        console[&apos;error&apos;](&apos;Oh no&apos;);
      " time="0.022">
    </testcase>
    <testcase classname="no-production-logging invalid console.error(&apos;Oh no&apos;);" name="no-production-logging invalid console.error(&apos;Oh no&apos;);" time="0.006">
    </testcase>
    <testcase classname="no-production-logging invalid console.warn(&apos;Oh no&apos;);" name="no-production-logging invalid console.warn(&apos;Oh no&apos;);" time="0.003">
    </testcase>
    <testcase classname="no-production-logging invalid console.warn(&apos;Oh no&apos;)" name="no-production-logging invalid console.warn(&apos;Oh no&apos;)" time="0.035">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (potato) {
          console.warn(&apos;Oh no&apos;);
        }
      " name="no-production-logging invalid 
        if (potato) {
          console.warn(&apos;Oh no&apos;);
        }
      " time="0.005">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (__DEV__ || potato &amp;&amp; true) {
          console.error(&apos;Oh no&apos;);
        }
      " name="no-production-logging invalid 
        if (__DEV__ || potato &amp;&amp; true) {
          console.error(&apos;Oh no&apos;);
        }
      " time="0.004">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (banana &amp;&amp; __DEV__ &amp;&amp; potato &amp;&amp; kitten) {
          console.error(&apos;Oh no&apos;);
        }
      " name="no-production-logging invalid 
        if (banana &amp;&amp; __DEV__ &amp;&amp; potato &amp;&amp; kitten) {
          console.error(&apos;Oh no&apos;);
        }
      " time="0.04">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (!__DEV__) {
          console.error(&apos;Oh no&apos;);
        }
      " name="no-production-logging invalid 
        if (!__DEV__) {
          console.error(&apos;Oh no&apos;);
        }
      " time="0.003">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (foo || x &amp;&amp; __DEV__) {
          console.error(&apos;Oh no&apos;);
        }
      " name="no-production-logging invalid 
        if (foo || x &amp;&amp; __DEV__) {
          console.error(&apos;Oh no&apos;);
        }
      " time="0.004">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (__DEV__) {
        } else {
          console.error(&apos;Oh no&apos;);
        }
      " name="no-production-logging invalid 
        if (__DEV__) {
        } else {
          console.error(&apos;Oh no&apos;);
        }
      " time="0.023">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (__DEV__) {
        } else {
          if (__DEV__) {
          } else {
            console.error(&apos;Oh no&apos;);
          }
        }
      " name="no-production-logging invalid 
        if (__DEV__) {
        } else {
          if (__DEV__) {
          } else {
            console.error(&apos;Oh no&apos;);
          }
        }
      " time="0.004">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (__DEV__) {
          console.log(&apos;Oh no&apos;);
        }
      " name="no-production-logging invalid 
        if (__DEV__) {
          console.log(&apos;Oh no&apos;);
        }
      " time="0.001">
    </testcase>
    <testcase classname="no-production-logging invalid 
        if (__DEV__) {
          console.log.apply(console, &apos;Oh no&apos;);
        }
      " name="no-production-logging invalid 
        if (__DEV__) {
          console.log.apply(console, &apos;Oh no&apos;);
        }
      " time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="scripts/eslint-rules/__tests__/no-cross-fork-imports-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:31" time="1.175" tests="11">
    <testcase classname="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop&apos;;" name="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop&apos;;" time="0.103">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.new&apos;;" name="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.new&apos;;" time="0.004">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.new.js&apos;;" name="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.new.js&apos;;" time="0.03">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.old&apos;;" name="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.old&apos;;" time="0.011">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.old.js&apos;;" name="eslint-rules/no-cross-fork-imports valid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.old.js&apos;;" time="0.004">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports invalid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.new&apos;;" name="eslint-rules/no-cross-fork-imports invalid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.new&apos;;" time="0.039">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports invalid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.new.js&apos;;" name="eslint-rules/no-cross-fork-imports invalid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.new.js&apos;;" time="0.027">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports invalid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.old&apos;;" name="eslint-rules/no-cross-fork-imports invalid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.old&apos;;" time="0.006">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports invalid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.old.js&apos;;" name="eslint-rules/no-cross-fork-imports invalid import {scheduleUpdateOnFiber} from &apos;./ReactFiberWorkLoop.old.js&apos;;" time="0.048">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports invalid export {DiscreteEventPriority} from &apos;./ReactFiberLane.old.js&apos;;" name="eslint-rules/no-cross-fork-imports invalid export {DiscreteEventPriority} from &apos;./ReactFiberLane.old.js&apos;;" time="0.005">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-imports invalid export {DiscreteEventPriority} from &apos;./ReactFiberLane.new.js&apos;;" name="eslint-rules/no-cross-fork-imports invalid export {DiscreteEventPriority} from &apos;./ReactFiberLane.new.js&apos;;" time="0.026">
    </testcase>
  </testsuite>
  <testsuite name="scripts/eslint-rules/__tests__/warning-args-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:32" time="0.736" tests="10">
    <testcase classname="eslint-rules/warning-args valid console.error(&apos;hello, world&apos;);" name="eslint-rules/warning-args valid console.error(&apos;hello, world&apos;);" time="0.063">
    </testcase>
    <testcase classname="eslint-rules/warning-args valid console.error(&apos;expected %s, got %s&apos;, 42, 24);" name="eslint-rules/warning-args valid console.error(&apos;expected %s, got %s&apos;, 42, 24);" time="0.007">
    </testcase>
    <testcase classname="eslint-rules/warning-args valid arbitraryFunction(a, b)" name="eslint-rules/warning-args valid arbitraryFunction(a, b)" time="0.001">
    </testcase>
    <testcase classname="eslint-rules/warning-args invalid console.error(null);" name="eslint-rules/warning-args invalid console.error(null);" time="0.001">
    </testcase>
    <testcase classname="eslint-rules/warning-args invalid console.warn(null);" name="eslint-rules/warning-args invalid console.warn(null);" time="0.007">
    </testcase>
    <testcase classname="eslint-rules/warning-args invalid var g = 5; console.error(g);" name="eslint-rules/warning-args invalid var g = 5; console.error(g);" time="0.013">
    </testcase>
    <testcase classname="eslint-rules/warning-args invalid console.error(&apos;expected %s, got %s&apos;);" name="eslint-rules/warning-args invalid console.error(&apos;expected %s, got %s&apos;);" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/warning-args invalid console.error(&apos;foo is a bar under foobar&apos;, &apos;junk argument&apos;);" name="eslint-rules/warning-args invalid console.error(&apos;foo is a bar under foobar&apos;, &apos;junk argument&apos;);" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/warning-args invalid console.error(&apos;error!&apos;);" name="eslint-rules/warning-args invalid console.error(&apos;error!&apos;);" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/warning-args invalid console.error(&apos;%s %s, %s %s: %s (%s)&apos;, 1, 2, 3, 4, 5, 6);" name="eslint-rules/warning-args invalid console.error(&apos;%s %s, %s %s: %s (%s)&apos;, 1, 2, 3, 4, 5, 6);" time="0.028">
    </testcase>
  </testsuite>
  <testsuite name="scripts/eslint-rules/__tests__/no-to-warn-dev-within-to-throw-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:31" time="1.526" tests="3">
    <testcase classname="eslint-rules/no-to-warn-dev-within-to-throw valid expect(callback).toWarnDev(&quot;warning&quot;);" name="eslint-rules/no-to-warn-dev-within-to-throw valid expect(callback).toWarnDev(&quot;warning&quot;);" time="0.094">
    </testcase>
    <testcase classname="eslint-rules/no-to-warn-dev-within-to-throw valid expect(function() { expect(callback).toThrow(&quot;error&quot;) }).toWarnDev(&quot;warning&quot;);" name="eslint-rules/no-to-warn-dev-within-to-throw valid expect(function() { expect(callback).toThrow(&quot;error&quot;) }).toWarnDev(&quot;warning&quot;);" time="0.006">
    </testcase>
    <testcase classname="eslint-rules/no-to-warn-dev-within-to-throw invalid expect(function() { expect(callback).toWarnDev(&quot;warning&quot;) }).toThrow(&quot;error&quot;);" name="eslint-rules/no-to-warn-dev-within-to-throw invalid expect(function() { expect(callback).toWarnDev(&quot;warning&quot;) }).toThrow(&quot;error&quot;);" time="0.006">
    </testcase>
  </testsuite>
  <testsuite name="scripts/jest/matchers/__tests__/toWarnDev-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:33" time="0.343" tests="26">
    <testcase classname="toErrorDev does not fail if a warning contains a stack" name="toErrorDev does not fail if a warning contains a stack" time="0.001">
    </testcase>
    <testcase classname="toErrorDev does not fail if all warnings contain a stack" name="toErrorDev does not fail if all warnings contain a stack" time="0.001">
    </testcase>
    <testcase classname="toErrorDev does not fail if warnings without stack explicitly opt out" name="toErrorDev does not fail if warnings without stack explicitly opt out" time="0">
    </testcase>
    <testcase classname="toErrorDev does not fail when expected stack-less warning number matches the actual one" name="toErrorDev does not fail when expected stack-less warning number matches the actual one" time="0">
    </testcase>
    <testcase classname="toErrorDev fails if a warning does not contain a stack" name="toErrorDev fails if a warning does not contain a stack" time="0.001">
    </testcase>
    <testcase classname="toErrorDev fails if some warnings do not contain a stack" name="toErrorDev fails if some warnings do not contain a stack" time="0.004">
    </testcase>
    <testcase classname="toErrorDev fails if warning is expected to not have a stack, but does" name="toErrorDev fails if warning is expected to not have a stack, but does" time="0.007">
    </testcase>
    <testcase classname="toErrorDev fails if expected stack-less warning number does not match the actual one" name="toErrorDev fails if expected stack-less warning number does not match the actual one" time="0">
    </testcase>
    <testcase classname="toErrorDev fails if withoutStack is invalid" name="toErrorDev fails if withoutStack is invalid" time="0.002">
    </testcase>
    <testcase classname="toErrorDev fails if the argument number does not match" name="toErrorDev fails if the argument number does not match" time="0.001">
    </testcase>
    <testcase classname="toErrorDev fails if stack is passed twice" name="toErrorDev fails if stack is passed twice" time="0.001">
    </testcase>
    <testcase classname="toErrorDev fails if multiple strings are passed without an array wrapper" name="toErrorDev fails if multiple strings are passed without an array wrapper" time="0.001">
    </testcase>
    <testcase classname="toErrorDev fails on more than two arguments" name="toErrorDev fails on more than two arguments" time="0">
    </testcase>
    <testcase classname="toWarnDev does not fail if a warning contains a stack" name="toWarnDev does not fail if a warning contains a stack" time="0">
    </testcase>
    <testcase classname="toWarnDev does not fail if all warnings contain a stack" name="toWarnDev does not fail if all warnings contain a stack" time="0.001">
    </testcase>
    <testcase classname="toWarnDev does not fail if warnings without stack explicitly opt out" name="toWarnDev does not fail if warnings without stack explicitly opt out" time="0">
    </testcase>
    <testcase classname="toWarnDev does not fail when expected stack-less warning number matches the actual one" name="toWarnDev does not fail when expected stack-less warning number matches the actual one" time="0">
    </testcase>
    <testcase classname="toWarnDev fails if a warning does not contain a stack" name="toWarnDev fails if a warning does not contain a stack" time="0.001">
    </testcase>
    <testcase classname="toWarnDev fails if some warnings do not contain a stack" name="toWarnDev fails if some warnings do not contain a stack" time="0.001">
    </testcase>
    <testcase classname="toWarnDev fails if warning is expected to not have a stack, but does" name="toWarnDev fails if warning is expected to not have a stack, but does" time="0.01">
    </testcase>
    <testcase classname="toWarnDev fails if expected stack-less warning number does not match the actual one" name="toWarnDev fails if expected stack-less warning number does not match the actual one" time="0.001">
    </testcase>
    <testcase classname="toWarnDev fails if withoutStack is invalid" name="toWarnDev fails if withoutStack is invalid" time="0.001">
    </testcase>
    <testcase classname="toWarnDev fails if the argument number does not match" name="toWarnDev fails if the argument number does not match" time="0.001">
    </testcase>
    <testcase classname="toWarnDev fails if stack is passed twice" name="toWarnDev fails if stack is passed twice" time="0">
    </testcase>
    <testcase classname="toWarnDev fails if multiple strings are passed without an array wrapper" name="toWarnDev fails if multiple strings are passed without an array wrapper" time="0.001">
    </testcase>
    <testcase classname="toWarnDev fails on more than two arguments" name="toWarnDev fails on more than two arguments" time="0">
    </testcase>
  </testsuite>
  <testsuite name="scripts/eslint-rules/__tests__/prod-error-codes-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:33" time="0.518" tests="8">
    <testcase classname="eslint-rules/prod-error-codes valid arbitraryFunction(a, b)" name="eslint-rules/prod-error-codes valid arbitraryFunction(a, b)" time="0.058">
    </testcase>
    <testcase classname="eslint-rules/prod-error-codes valid Error(`Expected ${foo} target to be an array; got ${bar}`)" name="eslint-rules/prod-error-codes valid Error(`Expected ${foo} target to be an array; got ${bar}`)" time="0.004">
    </testcase>
    <testcase classname="eslint-rules/prod-error-codes valid Error(&apos;Expected &apos; + foo + &apos; target to be an array; got &apos; + bar)" name="eslint-rules/prod-error-codes valid Error(&apos;Expected &apos; + foo + &apos; target to be an array; got &apos; + bar)" time="0.003">
    </testcase>
    <testcase classname="eslint-rules/prod-error-codes valid Error(`Expected ${foo} target to ` + `be an array; got ${bar}`)" name="eslint-rules/prod-error-codes valid Error(`Expected ${foo} target to ` + `be an array; got ${bar}`)" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/prod-error-codes invalid Error(&apos;Not in error map&apos;)" name="eslint-rules/prod-error-codes invalid Error(&apos;Not in error map&apos;)" time="0.001">
    </testcase>
    <testcase classname="eslint-rules/prod-error-codes invalid Error(&apos;Not in &apos; + &apos;error map&apos;)" name="eslint-rules/prod-error-codes invalid Error(&apos;Not in &apos; + &apos;error map&apos;)" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/prod-error-codes invalid Error(`Not in ` + `error map`)" name="eslint-rules/prod-error-codes invalid Error(`Not in ` + `error map`)" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/prod-error-codes invalid Error(`Not in ${&apos;error&apos;} map`)" name="eslint-rules/prod-error-codes invalid Error(`Not in ${&apos;error&apos;} map`)" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="scripts/eslint-rules/__tests__/no-cross-fork-types-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:33" time="0.832" tests="9">
    <testcase classname="eslint-rules/no-cross-fork-types valid 
const a = obj.key_old;
const b = obj.key_new;
const {key_old, key_new} = obj;
" name="eslint-rules/no-cross-fork-types valid 
const a = obj.key_old;
const b = obj.key_new;
const {key_old, key_new} = obj;
" time="0.031">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-types valid 
const a = obj.key_old;
const {key_old} = obj;
" name="eslint-rules/no-cross-fork-types valid 
const a = obj.key_old;
const {key_old} = obj;
" time="0.019">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-types valid 
const a = obj.key_new;
const {key_new} = obj;
" name="eslint-rules/no-cross-fork-types valid 
const a = obj.key_new;
const {key_new} = obj;
" time="0.004">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-types invalid const a = obj.key_new;" name="eslint-rules/no-cross-fork-types invalid const a = obj.key_new;" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-types invalid const a = obj.key_old;" name="eslint-rules/no-cross-fork-types invalid const a = obj.key_old;" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-types invalid const {key_new} = obj;" name="eslint-rules/no-cross-fork-types invalid const {key_new} = obj;" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-types invalid const {key_old} = obj;" name="eslint-rules/no-cross-fork-types invalid const {key_old} = obj;" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-types invalid const subtreeFlags = obj.subtreeFlags;" name="eslint-rules/no-cross-fork-types invalid const subtreeFlags = obj.subtreeFlags;" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/no-cross-fork-types invalid const firstEffect = obj.firstEffect;" name="eslint-rules/no-cross-fork-types invalid const firstEffect = obj.firstEffect;" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="scripts/eslint-rules/__tests__/safe-string-coercion-test.internal.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:33" time="1.29" tests="33">
    <testcase classname="eslint-rules/safe-string-coercion valid String(obj)" name="eslint-rules/safe-string-coercion valid String(obj)" time="0.037">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid String(obj)" name="eslint-rules/safe-string-coercion valid String(obj)" time="0.003">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid &apos;a&apos; + obj" name="eslint-rules/safe-string-coercion valid &apos;a&apos; + obj" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid 
      function getValueForAttribute(
        node,
        name,
        expected
      ) {
        if (__DEV__) {
          var value = node.getAttribute(name);
          if (__DEV__) {
            checkAttributeStringCoercion(expected, name);
          }
          if (value === &apos;&apos; + expected) {
            return expected;
          }
          return value;
        }
      }
    " name="eslint-rules/safe-string-coercion valid 
      function getValueForAttribute(
        node,
        name,
        expected
      ) {
        if (__DEV__) {
          var value = node.getAttribute(name);
          if (__DEV__) {
            checkAttributeStringCoercion(expected, name);
          }
          if (value === &apos;&apos; + expected) {
            return expected;
          }
          return value;
        }
      }
    " time="0.01">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid 
      if (__DEV__) { checkFormFieldValueStringCoercion (obj) } 
      &apos;&apos; + obj;
    " name="eslint-rules/safe-string-coercion valid 
      if (__DEV__) { checkFormFieldValueStringCoercion (obj) } 
      &apos;&apos; + obj;
    " time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid 
      function f(a, index) {
        if (typeof a === &apos;object&apos; &amp;&amp; a !== null &amp;&amp; a.key != null) {
          if (__DEV__) {
            checkKeyStringCoercion(a.key);
          }
          return f(&apos;&apos; + a.key);
        }
        return a;
      }
    " name="eslint-rules/safe-string-coercion valid 
      function f(a, index) {
        if (typeof a === &apos;object&apos; &amp;&amp; a !== null &amp;&amp; a.key != null) {
          if (__DEV__) {
            checkKeyStringCoercion(a.key);
          }
          return f(&apos;&apos; + a.key);
        }
        return a;
      }
    " time="0.007">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid &apos;&apos; + i++" name="eslint-rules/safe-string-coercion valid &apos;&apos; + i++" time="0.001">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid &apos;&apos; + +i" name="eslint-rules/safe-string-coercion valid &apos;&apos; + +i" time="0.001">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid &apos;&apos; + +i" name="eslint-rules/safe-string-coercion valid &apos;&apos; + +i" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid +i + &apos;&apos;" name="eslint-rules/safe-string-coercion valid +i + &apos;&apos;" time="0.001">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos;) { &apos;&apos; + obj }" name="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos;) { &apos;&apos; + obj }" time="0.014">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos; || typeof obj === &apos;number&apos;) { &apos;&apos; + obj }" name="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos; || typeof obj === &apos;number&apos;) { &apos;&apos; + obj }" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos; &amp;&amp; somethingElse) { &apos;&apos; + obj }" name="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos; &amp;&amp; somethingElse) { &apos;&apos; + obj }" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;number&apos; &amp;&amp; somethingElse) { &apos;&apos; + obj }" name="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;number&apos; &amp;&amp; somethingElse) { &apos;&apos; + obj }" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;bigint&apos; &amp;&amp; somethingElse) { &apos;&apos; + obj }" name="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;bigint&apos; &amp;&amp; somethingElse) { &apos;&apos; + obj }" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;undefined&apos; &amp;&amp; somethingElse) { &apos;&apos; + obj }" name="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;undefined&apos; &amp;&amp; somethingElse) { &apos;&apos; + obj }" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof nextProp === &apos;number&apos;) { setTextContent(domElement, &apos;&apos; + nextProp); }" name="eslint-rules/safe-string-coercion valid if (typeof nextProp === &apos;number&apos;) { setTextContent(domElement, &apos;&apos; + nextProp); }" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos;) { if (typeof obj === &apos;string&apos; &amp;&amp; obj.length) {} else {&apos;&apos; + obj} }" name="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos;) { if (typeof obj === &apos;string&apos; &amp;&amp; obj.length) {} else {&apos;&apos; + obj} }" time="0.003">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos;) if (typeof obj === &apos;string&apos; &amp;&amp; obj.length) {} else {&apos;&apos; + obj}" name="eslint-rules/safe-string-coercion valid if (typeof obj === &apos;string&apos;) if (typeof obj === &apos;string&apos; &amp;&amp; obj.length) {} else {&apos;&apos; + obj}" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid &apos;&apos; + obj" name="eslint-rules/safe-string-coercion invalid &apos;&apos; + obj" time="0.005">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid obj + &apos;&apos;" name="eslint-rules/safe-string-coercion invalid obj + &apos;&apos;" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid String(obj)" name="eslint-rules/safe-string-coercion invalid String(obj)" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid if (typeof obj === &apos;object&apos;) { &apos;&apos; + obj }" name="eslint-rules/safe-string-coercion invalid if (typeof obj === &apos;object&apos;) { &apos;&apos; + obj }" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid if (typeof obj === &apos;string&apos;) { } else if (typeof obj === &apos;object&apos;) {&apos;&apos; + obj}" name="eslint-rules/safe-string-coercion invalid if (typeof obj === &apos;string&apos;) { } else if (typeof obj === &apos;object&apos;) {&apos;&apos; + obj}" time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid if (typeof obj === &apos;string&apos; &amp;&amp; obj.length) {} else {&apos;&apos; + obj}" name="eslint-rules/safe-string-coercion invalid if (typeof obj === &apos;string&apos; &amp;&amp; obj.length) {} else {&apos;&apos; + obj}" time="0.004">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid 
          if (__D__) { checkFormFieldValueStringCoercion (obj) } 
          &apos;&apos; + obj;
        " name="eslint-rules/safe-string-coercion invalid 
          if (__D__) { checkFormFieldValueStringCoercion (obj) } 
          &apos;&apos; + obj;
        " time="0.003">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) { checkFormFieldValueStringCoercion (obj) } 
          &apos;&apos; + notobjj;
        " name="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) { checkFormFieldValueStringCoercion (obj) } 
          &apos;&apos; + notobjj;
        " time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) { checkFormFieldValueStringCoercion (obj) }
          // must be right before the check call
          someOtherCode(); 
          &apos;&apos; + objj;
        " name="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) { checkFormFieldValueStringCoercion (obj) }
          // must be right before the check call
          someOtherCode(); 
          &apos;&apos; + objj;
        " time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) { chexxxxBadNameCoercion (obj) }
          &apos;&apos; + objj;
        " name="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) { chexxxxBadNameCoercion (obj) }
          &apos;&apos; + objj;
        " time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) {  }
          &apos;&apos; + objj;
        " name="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) {  }
          &apos;&apos; + objj;
        " time="0.001">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) { if (x) {} }
          &apos;&apos; + objj;
        " name="eslint-rules/safe-string-coercion invalid 
          if (__DEV__) { if (x) {} }
          &apos;&apos; + objj;
        " time="0.002">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid 
        if (a) {
          if (__DEV__) {
            // can&apos;t have additional code before the check call
            if (b) {
              checkKeyStringCoercion(obj);
            }
          }
          g = f( c, d + (b ? &apos;&apos; + obj : &apos;&apos;) + e);
        }
      " name="eslint-rules/safe-string-coercion invalid 
        if (a) {
          if (__DEV__) {
            // can&apos;t have additional code before the check call
            if (b) {
              checkKeyStringCoercion(obj);
            }
          }
          g = f( c, d + (b ? &apos;&apos; + obj : &apos;&apos;) + e);
        }
      " time="0.005">
    </testcase>
    <testcase classname="eslint-rules/safe-string-coercion invalid 
        if (__DEV__) {
          checkAttributeStringCoercion(expected, name);
        }
        // DEV check should be inside the if block
        if (a &amp;&amp; b) {
          f(&apos;&apos; + expected);
        }
      " name="eslint-rules/safe-string-coercion invalid 
        if (__DEV__) {
          checkAttributeStringCoercion(expected, name);
        }
        // DEV check should be inside the if block
        if (a &amp;&amp; b) {
          f(&apos;&apos; + expected);
        }
      " time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactNewContext-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:25" time="9.364" tests="99">
    <testcase classname="ReactNewContext reading context with Context.Consumer simple mount and update" name="ReactNewContext reading context with Context.Consumer simple mount and update" time="0.038">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer propagates through shouldComponentUpdate false" name="ReactNewContext reading context with Context.Consumer propagates through shouldComponentUpdate false" time="0.06">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer consumers bail out if context value is the same" name="ReactNewContext reading context with Context.Consumer consumers bail out if context value is the same" time="0.05">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer nested providers" name="ReactNewContext reading context with Context.Consumer nested providers" time="0.061">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer should provide the correct (default) values to consumers outside of a provider" name="ReactNewContext reading context with Context.Consumer should provide the correct (default) values to consumers outside of a provider" time="0.032">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer multiple consumers in different branches" name="ReactNewContext reading context with Context.Consumer multiple consumers in different branches" time="0.033">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer compares context values with Object.is semantics" name="ReactNewContext reading context with Context.Consumer compares context values with Object.is semantics" time="0.025">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer context unwinds when interrupted" name="ReactNewContext reading context with Context.Consumer context unwinds when interrupted" time="0.077">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer does not re-render if there&apos;s an update in a child" name="ReactNewContext reading context with Context.Consumer does not re-render if there&apos;s an update in a child" time="0.036">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer consumer bails out if value is unchanged and something above bailed out" name="ReactNewContext reading context with Context.Consumer consumer bails out if value is unchanged and something above bailed out" time="0.061">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer context consumer doesn&apos;t bail out inside hidden subtree" name="ReactNewContext reading context with Context.Consumer context consumer doesn&apos;t bail out inside hidden subtree" time="0.029">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer does not run into an infinite loop" name="ReactNewContext reading context with Context.Consumer does not run into an infinite loop" time="0.025">
    </testcase>
    <testcase classname="ReactNewContext reading context with Context.Consumer does not skip some siblings" name="ReactNewContext reading context with Context.Consumer does not skip some siblings" time="0.053">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component simple mount and update" name="ReactNewContext reading context with useContext inside function component simple mount and update" time="0.021">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component propagates through shouldComponentUpdate false" name="ReactNewContext reading context with useContext inside function component propagates through shouldComponentUpdate false" time="0.021">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component consumers bail out if context value is the same" name="ReactNewContext reading context with useContext inside function component consumers bail out if context value is the same" time="0.04">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component nested providers" name="ReactNewContext reading context with useContext inside function component nested providers" time="0.03">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component should provide the correct (default) values to consumers outside of a provider" name="ReactNewContext reading context with useContext inside function component should provide the correct (default) values to consumers outside of a provider" time="0.037">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component multiple consumers in different branches" name="ReactNewContext reading context with useContext inside function component multiple consumers in different branches" time="0.026">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component compares context values with Object.is semantics" name="ReactNewContext reading context with useContext inside function component compares context values with Object.is semantics" time="0.06">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component context unwinds when interrupted" name="ReactNewContext reading context with useContext inside function component context unwinds when interrupted" time="0.04">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component does not re-render if there&apos;s an update in a child" name="ReactNewContext reading context with useContext inside function component does not re-render if there&apos;s an update in a child" time="0.027">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component consumer bails out if value is unchanged and something above bailed out" name="ReactNewContext reading context with useContext inside function component consumer bails out if value is unchanged and something above bailed out" time="0.062">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component context consumer doesn&apos;t bail out inside hidden subtree" name="ReactNewContext reading context with useContext inside function component context consumer doesn&apos;t bail out inside hidden subtree" time="0.044">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component does not run into an infinite loop" name="ReactNewContext reading context with useContext inside function component does not run into an infinite loop" time="0.07">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside function component does not skip some siblings" name="ReactNewContext reading context with useContext inside function component does not skip some siblings" time="0.115">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component simple mount and update" name="ReactNewContext reading context with useContext inside forwardRef component simple mount and update" time="0.059">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component propagates through shouldComponentUpdate false" name="ReactNewContext reading context with useContext inside forwardRef component propagates through shouldComponentUpdate false" time="0.117">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component consumers bail out if context value is the same" name="ReactNewContext reading context with useContext inside forwardRef component consumers bail out if context value is the same" time="0.016">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component nested providers" name="ReactNewContext reading context with useContext inside forwardRef component nested providers" time="0.072">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component should provide the correct (default) values to consumers outside of a provider" name="ReactNewContext reading context with useContext inside forwardRef component should provide the correct (default) values to consumers outside of a provider" time="0.048">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component multiple consumers in different branches" name="ReactNewContext reading context with useContext inside forwardRef component multiple consumers in different branches" time="0.041">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component compares context values with Object.is semantics" name="ReactNewContext reading context with useContext inside forwardRef component compares context values with Object.is semantics" time="0.044">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component context unwinds when interrupted" name="ReactNewContext reading context with useContext inside forwardRef component context unwinds when interrupted" time="0.049">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component does not re-render if there&apos;s an update in a child" name="ReactNewContext reading context with useContext inside forwardRef component does not re-render if there&apos;s an update in a child" time="0.032">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component consumer bails out if value is unchanged and something above bailed out" name="ReactNewContext reading context with useContext inside forwardRef component consumer bails out if value is unchanged and something above bailed out" time="0.065">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component context consumer doesn&apos;t bail out inside hidden subtree" name="ReactNewContext reading context with useContext inside forwardRef component context consumer doesn&apos;t bail out inside hidden subtree" time="0.03">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component does not run into an infinite loop" name="ReactNewContext reading context with useContext inside forwardRef component does not run into an infinite loop" time="0.052">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside forwardRef component does not skip some siblings" name="ReactNewContext reading context with useContext inside forwardRef component does not skip some siblings" time="0.033">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component simple mount and update" name="ReactNewContext reading context with useContext inside memoized function component simple mount and update" time="0.037">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component propagates through shouldComponentUpdate false" name="ReactNewContext reading context with useContext inside memoized function component propagates through shouldComponentUpdate false" time="0.034">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component consumers bail out if context value is the same" name="ReactNewContext reading context with useContext inside memoized function component consumers bail out if context value is the same" time="0.034">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component nested providers" name="ReactNewContext reading context with useContext inside memoized function component nested providers" time="0.027">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component should provide the correct (default) values to consumers outside of a provider" name="ReactNewContext reading context with useContext inside memoized function component should provide the correct (default) values to consumers outside of a provider" time="0.037">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component multiple consumers in different branches" name="ReactNewContext reading context with useContext inside memoized function component multiple consumers in different branches" time="0.035">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component compares context values with Object.is semantics" name="ReactNewContext reading context with useContext inside memoized function component compares context values with Object.is semantics" time="0.07">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component context unwinds when interrupted" name="ReactNewContext reading context with useContext inside memoized function component context unwinds when interrupted" time="0.071">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component does not re-render if there&apos;s an update in a child" name="ReactNewContext reading context with useContext inside memoized function component does not re-render if there&apos;s an update in a child" time="0.037">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component consumer bails out if value is unchanged and something above bailed out" name="ReactNewContext reading context with useContext inside memoized function component consumer bails out if value is unchanged and something above bailed out" time="0.046">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component context consumer doesn&apos;t bail out inside hidden subtree" name="ReactNewContext reading context with useContext inside memoized function component context consumer doesn&apos;t bail out inside hidden subtree" time="0.033">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component does not run into an infinite loop" name="ReactNewContext reading context with useContext inside memoized function component does not run into an infinite loop" time="0.03">
    </testcase>
    <testcase classname="ReactNewContext reading context with useContext inside memoized function component does not skip some siblings" name="ReactNewContext reading context with useContext inside memoized function component does not skip some siblings" time="0.049">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component simple mount and update" name="ReactNewContext reading context with readContext(Context) inside class component simple mount and update" time="0.036">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component propagates through shouldComponentUpdate false" name="ReactNewContext reading context with readContext(Context) inside class component propagates through shouldComponentUpdate false" time="0.058">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component consumers bail out if context value is the same" name="ReactNewContext reading context with readContext(Context) inside class component consumers bail out if context value is the same" time="0.029">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component nested providers" name="ReactNewContext reading context with readContext(Context) inside class component nested providers" time="0.019">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component should provide the correct (default) values to consumers outside of a provider" name="ReactNewContext reading context with readContext(Context) inside class component should provide the correct (default) values to consumers outside of a provider" time="0.034">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component multiple consumers in different branches" name="ReactNewContext reading context with readContext(Context) inside class component multiple consumers in different branches" time="0.027">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component compares context values with Object.is semantics" name="ReactNewContext reading context with readContext(Context) inside class component compares context values with Object.is semantics" time="0.049">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component context unwinds when interrupted" name="ReactNewContext reading context with readContext(Context) inside class component context unwinds when interrupted" time="0.033">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component does not re-render if there&apos;s an update in a child" name="ReactNewContext reading context with readContext(Context) inside class component does not re-render if there&apos;s an update in a child" time="0.045">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component consumer bails out if value is unchanged and something above bailed out" name="ReactNewContext reading context with readContext(Context) inside class component consumer bails out if value is unchanged and something above bailed out" time="0.039">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component context consumer doesn&apos;t bail out inside hidden subtree" name="ReactNewContext reading context with readContext(Context) inside class component context consumer doesn&apos;t bail out inside hidden subtree" time="0.028">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component does not run into an infinite loop" name="ReactNewContext reading context with readContext(Context) inside class component does not run into an infinite loop" time="0.05">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside class component does not skip some siblings" name="ReactNewContext reading context with readContext(Context) inside class component does not skip some siblings" time="0.059">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component simple mount and update" name="ReactNewContext reading context with readContext(Context) inside pure class component simple mount and update" time="0.066">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component propagates through shouldComponentUpdate false" name="ReactNewContext reading context with readContext(Context) inside pure class component propagates through shouldComponentUpdate false" time="0.04">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component consumers bail out if context value is the same" name="ReactNewContext reading context with readContext(Context) inside pure class component consumers bail out if context value is the same" time="0.019">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component nested providers" name="ReactNewContext reading context with readContext(Context) inside pure class component nested providers" time="0.019">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component should provide the correct (default) values to consumers outside of a provider" name="ReactNewContext reading context with readContext(Context) inside pure class component should provide the correct (default) values to consumers outside of a provider" time="0.048">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component multiple consumers in different branches" name="ReactNewContext reading context with readContext(Context) inside pure class component multiple consumers in different branches" time="0.095">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component compares context values with Object.is semantics" name="ReactNewContext reading context with readContext(Context) inside pure class component compares context values with Object.is semantics" time="0.029">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component context unwinds when interrupted" name="ReactNewContext reading context with readContext(Context) inside pure class component context unwinds when interrupted" time="0.057">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component does not re-render if there&apos;s an update in a child" name="ReactNewContext reading context with readContext(Context) inside pure class component does not re-render if there&apos;s an update in a child" time="0.057">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component consumer bails out if value is unchanged and something above bailed out" name="ReactNewContext reading context with readContext(Context) inside pure class component consumer bails out if value is unchanged and something above bailed out" time="0.125">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component context consumer doesn&apos;t bail out inside hidden subtree" name="ReactNewContext reading context with readContext(Context) inside pure class component context consumer doesn&apos;t bail out inside hidden subtree" time="0.111">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component does not run into an infinite loop" name="ReactNewContext reading context with readContext(Context) inside pure class component does not run into an infinite loop" time="0.094">
    </testcase>
    <testcase classname="ReactNewContext reading context with readContext(Context) inside pure class component does not skip some siblings" name="ReactNewContext reading context with readContext(Context) inside pure class component does not skip some siblings" time="0.117">
    </testcase>
    <testcase classname="ReactNewContext Context.Provider warns if no value prop provided" name="ReactNewContext Context.Provider warns if no value prop provided" time="0.082">
    </testcase>
    <testcase classname="ReactNewContext Context.Provider warns if multiple renderers concurrently render the same context" name="ReactNewContext Context.Provider warns if multiple renderers concurrently render the same context" time="0.105">
    </testcase>
    <testcase classname="ReactNewContext Context.Provider provider bails out if children and value are unchanged (like sCU)" name="ReactNewContext Context.Provider provider bails out if children and value are unchanged (like sCU)" time="0.043">
    </testcase>
    <testcase classname="ReactNewContext Context.Provider provider does not bail out if legacy context changed above" name="ReactNewContext Context.Provider provider does not bail out if legacy context changed above" time="0.041">
    </testcase>
    <testcase classname="ReactNewContext Context.Consumer warns if child is not a function" name="ReactNewContext Context.Consumer warns if child is not a function" time="0.047">
    </testcase>
    <testcase classname="ReactNewContext Context.Consumer can read other contexts inside consumer render prop" name="ReactNewContext Context.Consumer can read other contexts inside consumer render prop" time="0.052">
    </testcase>
    <testcase classname="ReactNewContext Context.Consumer consumer does not bail out if there were no bailouts above it" name="ReactNewContext Context.Consumer consumer does not bail out if there were no bailouts above it" time="0.065">
    </testcase>
    <testcase classname="ReactNewContext readContext [GATED, SHOULD FAIL] can read the same context multiple times in the same function" name="ReactNewContext readContext [GATED, SHOULD FAIL] can read the same context multiple times in the same function" time="0.064">
    </testcase>
    <testcase classname="ReactNewContext readContext does not bail out if there were no bailouts above it" name="ReactNewContext readContext does not bail out if there were no bailouts above it" time="0.031">
    </testcase>
    <testcase classname="ReactNewContext readContext warns when reading context inside render phase class setState updater" name="ReactNewContext readContext warns when reading context inside render phase class setState updater" time="0.071">
    </testcase>
    <testcase classname="ReactNewContext useContext throws when used in a class component" name="ReactNewContext useContext throws when used in a class component" time="0.043">
    </testcase>
    <testcase classname="ReactNewContext useContext warns when passed a consumer" name="ReactNewContext useContext warns when passed a consumer" time="0.074">
    </testcase>
    <testcase classname="ReactNewContext useContext warns when passed a provider" name="ReactNewContext useContext warns when passed a provider" time="0.024">
    </testcase>
    <testcase classname="ReactNewContext useContext does not bail out if there were no bailouts above it" name="ReactNewContext useContext does not bail out if there were no bailouts above it" time="0.046">
    </testcase>
    <testcase classname="ReactNewContext unwinds after errors in complete phase" name="ReactNewContext unwinds after errors in complete phase" time="0.081">
    </testcase>
    <testcase classname="ReactNewContext fuzz test hard-coded tests" name="ReactNewContext fuzz test hard-coded tests" time="0.197">
    </testcase>
    <testcase classname="ReactNewContext fuzz test generated tests" name="ReactNewContext fuzz test generated tests" time="2.904">
    </testcase>
    <testcase classname="ReactNewContext should warn with an error message when using context as a consumer in DEV" name="ReactNewContext should warn with an error message when using context as a consumer in DEV" time="0.02">
    </testcase>
    <testcase classname="ReactNewContext should not warn when using Consumer from React &lt; 16.6 with newer renderer" name="ReactNewContext should not warn when using Consumer from React &lt; 16.6 with newer renderer" time="0.014">
    </testcase>
    <testcase classname="ReactNewContext should warn with an error message when using nested context consumers in DEV" name="ReactNewContext should warn with an error message when using nested context consumers in DEV" time="0.016">
    </testcase>
    <testcase classname="ReactNewContext should warn with an error message when using Context.Consumer.Provider DEV" name="ReactNewContext should warn with an error message when using Context.Consumer.Provider DEV" time="0.014">
    </testcase>
  </testsuite>
  <testsuite name="packages/react-reconciler/src/__tests__/ReactIncrementalTriangle-test.js" errors="0" failures="0" skipped="0" timestamp="2022-08-05T04:13:16" time="20.709" tests="4">
    <testcase classname="ReactIncrementalTriangle single root hard-coded tests" name="ReactIncrementalTriangle single root hard-coded tests" time="0.573">
    </testcase>
    <testcase classname="ReactIncrementalTriangle single root generative tests" name="ReactIncrementalTriangle single root generative tests" time="16.267">
    </testcase>
    <testcase classname="ReactIncrementalTriangle multiple roots hard-coded tests" name="ReactIncrementalTriangle multiple roots hard-coded tests" time="0.185">
    </testcase>
    <testcase classname="ReactIncrementalTriangle multiple roots generative tests" name="ReactIncrementalTriangle multiple roots generative tests" time="2.409">
    </testcase>
  </testsuite>
</testsuites>